module.exports = { contents: "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nvar minMax = function (type, row, args, ptr, prev) {\r\n    var key = args[0];\r\n    if (ptr[0] === 0)\r\n        prev[key] = type === -1 ? Number.MAX_VALUE : Number.MIN_VALUE;\r\n    var nextRow = {};\r\n    if (type === -1 ? parseFloat(row[key]) < parseFloat(prev[key]) : parseFloat(row[key]) > parseFloat(prev[key])) {\r\n        nextRow = row;\r\n    }\r\n    else {\r\n        nextRow = prev;\r\n    }\r\n    if (ptr[0] === ptr[1]) {\r\n        var r = index_1._assign(nextRow);\r\n        r[type === -1 ? \"MIN\" : \"MAX\"] = nextRow[key];\r\n        return r;\r\n    }\r\n    else {\r\n        return nextRow;\r\n    }\r\n};\r\nexports._functions = {\r\n    SUM: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.SUM = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    MIN: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(-1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    MAX: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    AVG: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.AVG = (prev / (ptr[1] + 1)) || prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    COUNT: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            if (args[0] === \"*\") {\r\n                prev++;\r\n            }\r\n            else {\r\n                prev += row[args[0]] ? 1 : 0;\r\n            }\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.COUNT = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    }\r\n};\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(database) {\r\n        this._db = database;\r\n    }\r\n    _NanoSQLQuery.prototype._doQuery = function (query) {\r\n        var t = this;\r\n        t._tableID = index_1.NanoSQLInstance._hash(query.table);\r\n        t._mod = [];\r\n        t._act = undefined;\r\n        var simpleQuery = [];\r\n        query.query.forEach(function (q) {\r\n            if ([\"upsert\", \"select\", \"delete\", \"drop\"].indexOf(q.type) >= 0) {\r\n                t._act = q;\r\n                if (q.type === \"select\")\r\n                    t._queryHash = index_1.NanoSQLInstance._hash(JSON.stringify(query.query));\r\n            }\r\n            else if ([\"show tables\", \"describe\"].indexOf(q.type) >= 0) {\r\n                simpleQuery.push(q);\r\n            }\r\n            else {\r\n                t._mod.push(q);\r\n            }\r\n        });\r\n        if (simpleQuery.length) {\r\n            switch (simpleQuery[0].type) {\r\n                case \"show tables\":\r\n                    query.onSuccess([{ tables: Object.keys(t._db._store._tables).map(function (ta) { return t._db._store._tables[ta]._name; }) }], \"info\", []);\r\n                    break;\r\n                case \"describe\":\r\n                    var getTable_1;\r\n                    var tableName_1 = t._tableID;\r\n                    var rows = {};\r\n                    Object.keys(t._db._store._tables).forEach(function (ta) {\r\n                        if (parseInt(ta) === t._tableID) {\r\n                            getTable_1 = index_1._assign(t._db._store._models[ta]);\r\n                            tableName_1 = t._db._store._tables[ta]._name;\r\n                        }\r\n                    });\r\n                    rows[tableName_1] = getTable_1;\r\n                    query.onSuccess([rows], \"info\", []);\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            t._execQuery(function (result, changeType, affectedRows) {\r\n                query.onSuccess(result, changeType, affectedRows);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getMod = function (name) {\r\n        return this._mod.filter(function (v) { return v.type === name; }).pop();\r\n    };\r\n    _NanoSQLQuery.prototype._execQuery = function (callBack) {\r\n        var t = this;\r\n        if (!t._act)\r\n            return;\r\n        var doQuery = function (rows) {\r\n            if (!t._act)\r\n                return;\r\n            switch (t._act.type) {\r\n                case \"upsert\":\r\n                    t._upsert(rows, callBack);\r\n                    break;\r\n                case \"select\":\r\n                    t._select(rows, callBack);\r\n                    break;\r\n                case \"drop\":\r\n                    t._db._store._read(tableData._name, \"all\", function (rows) {\r\n                        t._remove(rows, callBack);\r\n                    });\r\n                    break;\r\n                case \"delete\":\r\n                    t._remove(rows, callBack);\r\n                    break;\r\n            }\r\n        };\r\n        var tableData = t._db._store._tables[t._tableID];\r\n        if (!t._getMod(\"join\") && t._act.type !== \"drop\") {\r\n            if (t._getMod(\"where\")) {\r\n                var whereArgs_1 = t._getMod(\"where\").args;\r\n                var isOptimizedWhere_1 = function (wArgs) {\r\n                    if ([\"=\", \"IN\", \"BETWEEN\"].indexOf(wArgs[1]) !== -1) {\r\n                        if (wArgs[0] === tableData._pk || tableData._secondaryIndexes.indexOf(wArgs[0]) !== -1) {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                    return 1;\r\n                };\r\n                var doFastWhere_1 = function (wArgs, callBack) {\r\n                    var tableName = wArgs[0] === tableData._pk ? tableData._name : \"_\" + tableData._name + \"_idx_\" + wArgs[0];\r\n                    var isSecondaryIdx = wArgs[0] !== tableData._pk;\r\n                    switch (wArgs[1]) {\r\n                        case \"=\":\r\n                            t._db._store._read(tableName, isSecondaryIdx ? String(wArgs[2]).toLowerCase() : wArgs[2], function (rows) {\r\n                                callBack(rows);\r\n                            });\r\n                            break;\r\n                        case \"IN\":\r\n                            var ptr = 0;\r\n                            var resultRows = [];\r\n                            t._db._store._readArray(tableName, isSecondaryIdx ? String(wArgs[2]).toLowerCase() : wArgs[2], function (rows) {\r\n                                callBack(rows);\r\n                            });\r\n                            break;\r\n                        case \"BETWEEN\":\r\n                            if (isSecondaryIdx)\r\n                                wArgs[2].map(function (a) { return String(a).toLowerCase(); });\r\n                            t._db._store._readRange(tableName, wArgs[0], wArgs[2], callBack);\r\n                            break;\r\n                    }\r\n                };\r\n                var doFastRead = false;\r\n                if (typeof whereArgs_1[0] === \"string\") {\r\n                    doFastRead = isOptimizedWhere_1(whereArgs_1) === 0;\r\n                }\r\n                else {\r\n                    doFastRead = whereArgs_1.reduce(function (prev, cur, i) {\r\n                        if (i % 2 === 1)\r\n                            return prev;\r\n                        return prev + isOptimizedWhere_1(cur);\r\n                    }, 0) === 0;\r\n                }\r\n                if (doFastRead) {\r\n                    if (typeof whereArgs_1[0] === \"string\") {\r\n                        doFastWhere_1(whereArgs_1, doQuery);\r\n                    }\r\n                    else {\r\n                        var resultRows_1 = [];\r\n                        var lastCommand_1 = \"\";\r\n                        new db_index_1._fnForEach().loop(whereArgs_1, function (wArg, next) {\r\n                            doFastWhere_1(wArg, function (rows) {\r\n                                if (lastCommand_1 === \"AND\") {\r\n                                    var idx_1 = rows.map(function (r) { return r[tableData._pk]; });\r\n                                    resultRows_1 = resultRows_1.filter(function (row) {\r\n                                        return idx_1.indexOf(row[tableData._pk]) !== -1;\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    resultRows_1 = resultRows_1.concat(rows);\r\n                                }\r\n                                next();\r\n                            });\r\n                        }).then(function () {\r\n                            doQuery(resultRows_1);\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    t._db._store._read(tableData._name, function (row) {\r\n                        return row && t._where(row, whereArgs_1);\r\n                    }, function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n            }\r\n            else if (t._getMod(\"range\")) {\r\n                var rangeArgs = t._getMod(\"range\").args;\r\n                t._getRange(rangeArgs[0], rangeArgs[1], doQuery);\r\n            }\r\n            else if (t._getMod(\"trie\")) {\r\n                var trieArgs = t._getMod(\"trie\").args;\r\n                var words = tableData._trieObjects[trieArgs[0]].getPrefix(trieArgs[1]);\r\n                var indexTable = \"_\" + tableData._name + \"_idx_\" + trieArgs[0];\r\n                t._db._store._readArray(indexTable, words, function (rows) {\r\n                    doQuery(rows);\r\n                });\r\n            }\r\n            else {\r\n                if (t._act.type !== \"upsert\") {\r\n                    t._db._store._read(tableData._name, \"all\", function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n                else {\r\n                    doQuery([]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            doQuery([]);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getRange = function (limit, offset, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var startIndex = table._index[offset];\r\n        var endIndex = table._index[offset + (limit - 1)];\r\n        if (!startIndex) {\r\n            callBack([]);\r\n        }\r\n        else {\r\n            t._db._store._readRange(table._name, table._pk, [startIndex, endIndex], function (rows) {\r\n                callBack(rows);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._updateRow = function (rowPK, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var qArgs = t._act.args;\r\n        var oldRow = {};\r\n        var updateType = (function () {\r\n            return t._act ? t._act.type : \"\";\r\n        })();\r\n        var updateSecondaryIndex = function (newRow, rem) {\r\n            if (table._name.indexOf(\"_\") !== 0) {\r\n                var emptyColumns_1 = [];\r\n                var updateIndex_1 = function (tableName, rowID, key) {\r\n                    t._db._store._read(tableName, rowID, function (rows) {\r\n                        var indexedRows = [];\r\n                        if (rows.length && rows[0].rowPK)\r\n                            indexedRows = indexedRows.concat(rows[0].rowPK);\r\n                        if (!rem)\r\n                            indexedRows.push(newRow[table._pk]);\r\n                        indexedRows = indexedRows.filter(function (item, pos) {\r\n                            return indexedRows.indexOf(item) === pos || !(rem && item === newRow[table._pk]);\r\n                        });\r\n                        if (indexedRows.length) {\r\n                            t._db._store._upsert(tableName, rowID, {\r\n                                id: rowID,\r\n                                rowPK: indexedRows\r\n                            }, function () { });\r\n                        }\r\n                        else {\r\n                            emptyColumns_1.push(key);\r\n                            t._db._store._delete(tableName, rowID);\r\n                        }\r\n                    }, true);\r\n                };\r\n                table._secondaryIndexes.forEach(function (key) {\r\n                    var idxTable = \"_\" + table._name + \"_idx_\" + key;\r\n                    var rowID = String(newRow[key]).toLowerCase();\r\n                    var oldRowID = String(oldRow[key]).toLowerCase();\r\n                    if (rowID !== oldRowID && oldRow[key]) {\r\n                        t._db._store._read(idxTable, oldRowID, function (oldRowIndex) {\r\n                            var indexes = oldRowIndex[0] ? index_1._assign(oldRowIndex[0].rowPK || []) : [];\r\n                            var oldRowLoc = indexes.indexOf(oldRowID[table._pk]);\r\n                            if (oldRowLoc !== -1)\r\n                                indexes.splice(oldRowLoc, 1);\r\n                            t._db._store._upsert(idxTable, oldRowID, {\r\n                                id: oldRowID,\r\n                                rowPK: indexes\r\n                            }, function () {\r\n                                updateIndex_1(idxTable, rowID, key);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        if (newRow[key] !== undefined)\r\n                            updateIndex_1(idxTable, rowID, key);\r\n                    }\r\n                });\r\n                table._trieColumns.forEach(function (key) {\r\n                    var word = String(newRow[key]).toLocaleLowerCase();\r\n                    if (emptyColumns_1.indexOf(key) !== -1) {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].removeWord(word);\r\n                    }\r\n                    else {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].addWord(word);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        var writeChanges = function (newRow) {\r\n            if (updateType === \"upsert\") {\r\n                t._db._store._upsert(table._name, rowPK, newRow, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n            else {\r\n                t._db._store._delete(table._name, rowPK, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n        };\r\n        if (t._db._store._doingTransaction) {\r\n            if (updateType === \"upsert\") {\r\n                t._db._store._tables[t._tableID]._keys.forEach(function (k, i) {\r\n                    var def = table._defaults[i];\r\n                    if (qArgs[k] === undefined && def !== undefined)\r\n                        qArgs[k] = def;\r\n                });\r\n                writeChanges(qArgs);\r\n            }\r\n            else {\r\n                writeChanges({});\r\n            }\r\n            return;\r\n        }\r\n        t._db._store._read(table._name, rowPK, function (rows) {\r\n            oldRow = rows[0] || {};\r\n            var newRow = index_1._assign(rows[0] || {});\r\n            var doRemove = false;\r\n            var finishUpdate = function (histDataID) {\r\n                if (table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory && table._pk.length) {\r\n                    t._db._store._read(\"_\" + table._name + \"_hist__meta\", rowPK, function (rows) {\r\n                        if (!rows.length || !rows[0]) {\r\n                            rows[0] = {};\r\n                            rows[0][db_index_1._str(2)] = 0;\r\n                            rows[0][db_index_1._str(3)] = [];\r\n                            rows[0].id = rowPK;\r\n                        }\r\n                        else {\r\n                            rows = index_1._assign(rows);\r\n                        }\r\n                        rows[0][db_index_1._str(3)].unshift(histDataID);\r\n                        t._db._store._upsert(\"_\" + table._name + \"_hist__meta\", rowPK, rows[0]);\r\n                    });\r\n                }\r\n                updateSecondaryIndex(updateType === \"upsert\" ? newRow : {});\r\n                writeChanges(newRow);\r\n            };\r\n            var doHistory = function () {\r\n                if (!doRemove && table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                    var histTable = \"_\" + table._name + \"_hist__data\";\r\n                    var tah = index_1.NanoSQLInstance._hash(histTable);\r\n                    newRow[db_index_1._str(4)] = t._db._store._tables[tah]._index.length;\r\n                    t._db._store._upsert(histTable, null, newRow, function (rowID) {\r\n                        finishUpdate(rowID);\r\n                    });\r\n                }\r\n                else {\r\n                    finishUpdate(0);\r\n                }\r\n            };\r\n            switch (updateType) {\r\n                case \"upsert\":\r\n                    Object.getOwnPropertyNames(qArgs).forEach(function (k) {\r\n                        newRow[k] = qArgs[k];\r\n                    });\r\n                    var table_1 = t._db._store._tables[t._tableID];\r\n                    table_1._keys.forEach(function (k, i) {\r\n                        var def = table_1._defaults[i];\r\n                        if (!newRow[k] && def !== undefined)\r\n                            newRow[k] = def;\r\n                    });\r\n                    doHistory();\r\n                    break;\r\n                case \"delete\":\r\n                    if (qArgs && qArgs.length) {\r\n                        qArgs.forEach(function (column) {\r\n                            newRow[column] = null;\r\n                        });\r\n                    }\r\n                    else {\r\n                        doRemove = true;\r\n                        newRow = {};\r\n                        if (t._db._store._tables[t._tableID]._relations.length) {\r\n                            t._db._store._tables[t._tableID]._relations.forEach(function (rel) {\r\n                                if (rel.mapTo.length) {\r\n                                    var relatedPK = t._db._store._tables[index_1.NanoSQLInstance._hash(rel.table)]._pk;\r\n                                    var related = oldRow[rel.key] || [];\r\n                                    if (!Array.isArray(related))\r\n                                        related = [related];\r\n                                    t._db._parent.table(rel.table).updateORM(\"delete\", rel.mapTo, [rowPK]).where([relatedPK, \"IN\", related]).exec().then(function () {\r\n                                        doHistory();\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            doHistory();\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._tableChanged = function (updatedRowPKs, describe, callBack) {\r\n        var _this = this;\r\n        var t = this, k = 0, j = 0;\r\n        if (t._db._store._doingTransaction) {\r\n            callBack([], \"trans\", []);\r\n            return;\r\n        }\r\n        if (updatedRowPKs.length > 0) {\r\n            var triggerComplete_1 = function () {\r\n                var table = t._db._store._tables[_this._tableID];\r\n                t._db._invalidateCache(t._tableID, [], \"\");\r\n                t._db._store._readArray(table._name, updatedRowPKs, function (rows) {\r\n                    callBack([{ msg: updatedRowPKs.length + \" row(s) \" + describe }], describe, rows);\r\n                });\r\n            };\r\n            var completeChange_1 = function () {\r\n                if (t._db._store._doHistory) {\r\n                    if (!t._db._store._doingTransaction && t._db._store._historyPoint === 0) {\r\n                        t._db._store._historyLength++;\r\n                    }\r\n                    t._db._store._utility(\"w\", \"historyLength\", t._db._store._historyLength);\r\n                    t._db._store._utility(\"w\", \"historyPoint\", t._db._store._historyPoint);\r\n                    var histPoint_1 = t._db._store._historyLength - t._db._store._historyPoint;\r\n                    t._db._store._upsert(db_index_1._str(1), null, {\r\n                        historyPoint: histPoint_1,\r\n                        tableID: t._tableID,\r\n                        rowKeys: updatedRowPKs,\r\n                        type: describe\r\n                    }, function (rowID) {\r\n                        if (!t._db._store._historyPointIndex[histPoint_1]) {\r\n                            t._db._store._historyPointIndex[histPoint_1] = [];\r\n                        }\r\n                        t._db._store._historyPointIndex[histPoint_1].push(rowID);\r\n                        triggerComplete_1();\r\n                    });\r\n                }\r\n                else {\r\n                    triggerComplete_1();\r\n                }\r\n            };\r\n            if (t._db._store._doHistory) {\r\n                if (t._db._store._historyPoint > 0) {\r\n                    var histPoints = [];\r\n                    var startIndex = (t._db._store._historyLength - t._db._store._historyPoint) + 1;\r\n                    while (t._db._store._historyPointIndex[startIndex]) {\r\n                        histPoints = histPoints.concat(t._db._store._historyPointIndex[startIndex].slice());\r\n                        delete t._db._store._historyPointIndex[startIndex];\r\n                        startIndex++;\r\n                    }\r\n                    t._db._store._readArray(db_index_1._str(1), histPoints, function (historyPoints) {\r\n                        j = 0;\r\n                        var nextPoint = function () {\r\n                            if (j < historyPoints.length) {\r\n                                var tableName_2 = t._db._store._tables[historyPoints[j].tableID]._name;\r\n                                k = 0;\r\n                                var nextRow_1 = function () {\r\n                                    if (k < historyPoints[j].rowKeys.length) {\r\n                                        t._db._store._read(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], function (rows) {\r\n                                            rows[0] = index_1._assign(rows[0]);\r\n                                            rows[0][db_index_1._str(2)] = 0;\r\n                                            var del = rows[0][db_index_1._str(3)].shift();\r\n                                            t._db._store._upsert(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], rows[0], function () {\r\n                                                if (del) {\r\n                                                    t._db._store._delete(\"_\" + tableName_2 + \"_hist__data\", del, function () {\r\n                                                        k++;\r\n                                                        nextRow_1();\r\n                                                    });\r\n                                                }\r\n                                                else {\r\n                                                    k++;\r\n                                                    nextRow_1();\r\n                                                }\r\n                                            });\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        j++;\r\n                                        nextPoint();\r\n                                    }\r\n                                };\r\n                                t._db._store._delete(db_index_1._str(1), historyPoints[j].id, function () {\r\n                                    nextRow_1();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._db._store._historyLength -= t._db._store._historyPoint;\r\n                                t._db._store._historyPoint = 0;\r\n                                completeChange_1();\r\n                                return;\r\n                            }\r\n                        };\r\n                        nextPoint();\r\n                    });\r\n                }\r\n                else {\r\n                    completeChange_1();\r\n                }\r\n            }\r\n            else {\r\n                completeChange_1();\r\n            }\r\n        }\r\n        else {\r\n            callBack([{ msg: \"0 rows \" + describe }], describe, []);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._upsert = function (queryRows, callBack) {\r\n        var t = this;\r\n        var scribe = \"\", i, changedPKs = [];\r\n        var qArgs = t._act.args || {}, table = t._db._store._tables[t._tableID], pk = table._pk, whereMod = t._getMod(\"where\");\r\n        if (whereMod) {\r\n            scribe = \"modified\";\r\n            changedPKs = queryRows.map(function (r) { return r[table._pk]; });\r\n            i = 0;\r\n            var update_1 = function () {\r\n                if (i < queryRows.length) {\r\n                    t._updateRow(queryRows[i][pk], function () {\r\n                        i++;\r\n                        update_1();\r\n                    });\r\n                }\r\n                else {\r\n                    t._tableChanged(changedPKs, scribe, callBack);\r\n                }\r\n            };\r\n            update_1();\r\n        }\r\n        else {\r\n            scribe = \"inserted\";\r\n            if (!qArgs[pk]) {\r\n                switch (table._pkType) {\r\n                    case \"int\":\r\n                        qArgs[pk] = table._incriment++;\r\n                        break;\r\n                    case \"uuid\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.uuid();\r\n                        break;\r\n                    case \"timeId\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid();\r\n                        break;\r\n                    case \"timeIdms\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid(true);\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (table._pkType === \"int\") {\r\n                    table._incriment = Math.max(qArgs[pk] + 1, table._incriment);\r\n                }\r\n            }\r\n            var objPK = qArgs[pk] ? qArgs[pk] : table._index.length;\r\n            changedPKs = [objPK];\r\n            if (!table._trieIndex.getPrefix(String(objPK)).length) {\r\n                var tableName = t._db._store._tables[t._tableID]._name;\r\n                if (tableName.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                    var histTable = \"_\" + tableName + \"_hist__meta\";\r\n                    var histRow = {};\r\n                    histRow[db_index_1._str(2)] = 0;\r\n                    histRow[db_index_1._str(3)] = [0];\r\n                    t._db._store._upsert(histTable, objPK, histRow);\r\n                }\r\n            }\r\n            t._updateRow(objPK, function () {\r\n                t._tableChanged(changedPKs, scribe, callBack);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getTableID = function () {\r\n        return this._joinTable ? this._joinTable : this._tableID;\r\n    };\r\n    _NanoSQLQuery.prototype._select = function (queryRows, callBack) {\r\n        var t = this;\r\n        if (t._db._queryCache[t._tableID][t._queryHash]) {\r\n        }\r\n        var mods = [\"join\", \"groupby\", \"having\", \"orderby\", \"offset\", \"limit\", \"orm\"];\r\n        var curMod, column, i, k, rows, obj, rowData, groups = {};\r\n        var sortObj = function (objA, objB, columns) {\r\n            return Object.keys(columns).reduce(function (prev, cur) {\r\n                var A = objA[cur];\r\n                var B = objB[cur];\r\n                if (cur.split(\".\").pop() === \"length\") {\r\n                    A = objA[cur.replace(\".length\", \"\")].length;\r\n                    B = objB[cur.replace(\".length\", \"\")].length;\r\n                }\r\n                if (!prev) {\r\n                    if (A === B)\r\n                        return 0;\r\n                    return (A > B ? 1 : -1) * (columns[cur] === \"desc\" ? -1 : 1);\r\n                }\r\n                else {\r\n                    return prev;\r\n                }\r\n            }, 0);\r\n        };\r\n        var modifyQuery = function (tableResult, modIndex, next) {\r\n            curMod = t._getMod(mods[modIndex]);\r\n            if (modIndex === 2) {\r\n                var functions_1 = [];\r\n                if (qArgs.length) {\r\n                    var funcs_1 = Object.keys(exports._functions).map(function (f) { return f + \"(\"; });\r\n                    var keepColumns_1 = [];\r\n                    functions_1 = qArgs.filter(function (q) {\r\n                        var hasFunc = funcs_1.reduce(function (prev, cur) {\r\n                            return (q.indexOf(cur) < 0 ? 0 : 1) + prev;\r\n                        }, 0) || 0;\r\n                        if (hasFunc > 0) {\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            keepColumns_1.push(q);\r\n                            return false;\r\n                        }\r\n                    }).map(function (selectString) {\r\n                        var regex = selectString.match(/(.*)\\((.*)\\)/);\r\n                        var funcName = regex[1].trim();\r\n                        var columnName = (selectString.match(/\\sAS\\s(.*)/) || []).pop() || funcName;\r\n                        var args = regex[2].split(\",\").map(function (s) { return s.trim(); });\r\n                        if (exports._functions[funcName].type === \"simple\" && columnName === funcName) {\r\n                            columnName = args[0];\r\n                        }\r\n                        keepColumns_1.push(columnName);\r\n                        return {\r\n                            name: funcName,\r\n                            args: args,\r\n                            as: columnName.trim(),\r\n                            type: exports._functions[funcName].type\r\n                        };\r\n                    });\r\n                    var rows_1 = [];\r\n                    if (functions_1.length) {\r\n                        var prevFunc_1;\r\n                        var doFunctions_1 = function (rows) {\r\n                            return functions_1.sort(function (a, b) {\r\n                                return a.type > b.type ? 1 : -1;\r\n                            }).reduce(function (prev, curr) {\r\n                                var len = prev.length - 1;\r\n                                if (curr.type === \"aggregate\") {\r\n                                    var newRows = rows.slice();\r\n                                    len = newRows.length - 1;\r\n                                    newRows = [newRows.reduce(function (p, v, i) {\r\n                                            return exports._functions[curr.name].call(v, curr.args, [i, len], p);\r\n                                        }, {})];\r\n                                    if (prevFunc_1) {\r\n                                        newRows[0][prevFunc_1] = prev[0][prevFunc_1];\r\n                                    }\r\n                                    prev = newRows;\r\n                                    prevFunc_1 = curr.name;\r\n                                }\r\n                                else {\r\n                                    prev = prev.map(function (v, i) {\r\n                                        return exports._functions[curr.name].call(v, curr.args, [i, len]);\r\n                                    });\r\n                                }\r\n                                if (curr.name !== curr.as) {\r\n                                    keepColumns_1.push(curr.name + \" AS \" + curr.as);\r\n                                }\r\n                                else {\r\n                                    keepColumns_1.push(curr.name);\r\n                                }\r\n                                return prev;\r\n                            }, rows.slice());\r\n                        };\r\n                        var groupKeys = Object.keys(groups);\r\n                        if (groupKeys.length) {\r\n                            rows_1 = groupKeys\r\n                                .map(function (k) { return prevFunc_1 = null, doFunctions_1(groups[k]); })\r\n                                .reduce(function (prev, curr) {\r\n                                return prev = prev.concat(curr), prev;\r\n                            }, []);\r\n                        }\r\n                        else {\r\n                            rows_1 = doFunctions_1(tableResult);\r\n                        }\r\n                    }\r\n                    else {\r\n                        rows_1 = tableResult;\r\n                    }\r\n                    var convertKeys_1 = keepColumns_1.map(function (n) {\r\n                        return n.match(/(.*)\\sAS\\s(.*)/) || n;\r\n                    }).filter(function (n) { return n; }) || [];\r\n                    if (convertKeys_1.length) {\r\n                        rows_1 = rows_1.map(function (r) {\r\n                            r = index_1._assign(r);\r\n                            var newRow = {};\r\n                            convertKeys_1.forEach(function (key) {\r\n                                if (typeof key === \"string\") {\r\n                                    if (key.indexOf(\".length\") !== -1) {\r\n                                        var newKey = key.replace(\".length\", \"\");\r\n                                        newRow[key] = (r[newKey] || []).length;\r\n                                    }\r\n                                    else {\r\n                                        newRow[key] = r[key];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (key[1].indexOf(\".length\") !== -1) {\r\n                                        var newKey = key[1].replace(\".length\", \"\");\r\n                                        newRow[key[2]] = (r[newKey] || []).length;\r\n                                    }\r\n                                    else {\r\n                                        newRow[key[2]] = r[key[1]];\r\n                                    }\r\n                                }\r\n                            });\r\n                            return newRow;\r\n                        });\r\n                    }\r\n                    tableResult = rows_1;\r\n                }\r\n            }\r\n            if (!curMod)\r\n                return next(tableResult);\r\n            switch (modIndex) {\r\n                case 0:\r\n                    var joinConditions = void 0;\r\n                    if (curMod.args.type !== \"cross\") {\r\n                        joinConditions = {\r\n                            _left: curMod.args.where[0],\r\n                            _check: curMod.args.where[1],\r\n                            _right: curMod.args.where[2]\r\n                        };\r\n                    }\r\n                    var leftTableID = t._tableID;\r\n                    var rightTableID = index_1.NanoSQLInstance._hash(curMod.args.table);\r\n                    var where_1 = t._getMod(\"where\");\r\n                    var range_1 = t._getMod(\"range\");\r\n                    t._join(curMod.args.type, leftTableID, rightTableID, joinConditions, function (joinedRows) {\r\n                        if (where_1) {\r\n                            next(joinedRows.filter(function (row) {\r\n                                return t._where(row, where_1.args);\r\n                            }));\r\n                        }\r\n                        else if (range_1) {\r\n                            t._getRange(range_1.args[0], range_1.args[1], next);\r\n                        }\r\n                        else {\r\n                            next(joinedRows);\r\n                        }\r\n                    });\r\n                    break;\r\n                case 1:\r\n                    var columns_1 = curMod.args;\r\n                    var sortGroups_1 = {};\r\n                    if (columns_1) {\r\n                        groups = tableResult.reduce(function (prev, curr) {\r\n                            var key = Object.keys(columns_1).reduce(function (p, c) {\r\n                                if (c.indexOf(\".length\") !== -1) {\r\n                                    return p + \".\" + String((curr[c.replace(\".length\", \"\")] || []).length);\r\n                                }\r\n                                else {\r\n                                    return p + \".\" + String(curr[c]);\r\n                                }\r\n                            }, \"\").slice(1);\r\n                            (prev[key] = prev[key] || []).push(curr);\r\n                            sortGroups_1[key] = Object.keys(columns_1).reduce(function (pr, cu) {\r\n                                if (cu.indexOf(\".length\") !== -1) {\r\n                                    var newCu = cu.replace(\".length\", \"\");\r\n                                    pr[newCu] = (curr[newCu] || []).length;\r\n                                }\r\n                                else {\r\n                                    pr[cu] = curr[cu];\r\n                                }\r\n                                return pr;\r\n                            }, {});\r\n                            return prev;\r\n                        }, {});\r\n                        next(Object.keys(groups).sort(function (a, b) {\r\n                            return sortObj(sortGroups_1[a], sortGroups_1[b], columns_1);\r\n                        }).reduce(function (prev, curr) {\r\n                            return prev.concat(groups[curr]);\r\n                        }, []));\r\n                    }\r\n                    else {\r\n                        next(tableResult);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    next(tableResult.filter(function (row) {\r\n                        return t._where(row, t._getMod(\"having\").args);\r\n                    }));\r\n                    break;\r\n                case 3:\r\n                    next(tableResult.sort(function (a, b) {\r\n                        return sortObj(a, b, curMod.args);\r\n                    }));\r\n                    break;\r\n                case 4:\r\n                    next(tableResult.filter(function (row, index) {\r\n                        return curMod ? index >= curMod.args : true;\r\n                    }));\r\n                    break;\r\n                case 5:\r\n                    next(tableResult.filter(function (row, index) {\r\n                        return curMod ? index < curMod.args : true;\r\n                    }));\r\n                    break;\r\n                case 6:\r\n                    var modifiers_1 = [];\r\n                    if (curMod.args)\r\n                        modifiers_1 = curMod.args;\r\n                    var defaultModifier_1 = t._db._store._parent._parent._ormFns[t._db._store._tables[t._tableID]._name];\r\n                    if (!t._getMod(\"join\")) {\r\n                        lie_ts_1.Promise.all(tableResult.map(function (row, k) {\r\n                            tableResult[k] = index_1._assign(row);\r\n                            return lie_ts_1.Promise.all(t._db._store._tables[t._tableID]._relations.map(function (rel) {\r\n                                var useKey = rel.key;\r\n                                if (qArgs && qArgs.length) {\r\n                                    qArgs.forEach(function (q) {\r\n                                        var column = q.split(\" \");\r\n                                        if (column[0] === rel.key && column[1] === \"AS\") {\r\n                                            useKey = column[2];\r\n                                        }\r\n                                    });\r\n                                }\r\n                                if (row[useKey] === undefined) {\r\n                                    return new lie_ts_1.Promise(function (res) { return res(); });\r\n                                }\r\n                                var tablePK = t._db._store._tables[index_1.NanoSQLInstance._hash(rel.table)]._pk;\r\n                                return new lie_ts_1.Promise(function (res, rej) {\r\n                                    var modifier = undefined;\r\n                                    if (defaultModifier_1) {\r\n                                        modifier = defaultModifier_1(rel.key, tableResult[k]);\r\n                                    }\r\n                                    if (modifiers_1.length) {\r\n                                        modifiers_1.forEach(function (mod) {\r\n                                            if (typeof mod !== \"string\") {\r\n                                                if (mod.key === rel.key || !mod.key || mod.key === \"*\") {\r\n                                                    modifier = mod;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    if (!modifier && modifiers_1.indexOf(rel.key) === -1) {\r\n                                        res();\r\n                                        return;\r\n                                    }\r\n                                    var Ids = row[useKey];\r\n                                    if (Ids === undefined) {\r\n                                        tableResult[k][useKey] = rel.type === \"single\" ? undefined : [];\r\n                                        res();\r\n                                        return;\r\n                                    }\r\n                                    if (rel.type === \"single\")\r\n                                        Ids = [Ids];\r\n                                    var query = t._db._parent.table(rel.table).query(\"select\");\r\n                                    if (modifier) {\r\n                                        if (!modifier.where && !modifier.orderBy) {\r\n                                            var offset_1 = modifier.offset || 0;\r\n                                            var limit_1 = modifier.limit || 0;\r\n                                            query.where([tablePK, \"IN\", Ids.filter(function (v, i) {\r\n                                                    return i >= offset_1 && i < offset_1 + limit_1;\r\n                                                })]);\r\n                                        }\r\n                                        else {\r\n                                            if (modifier.where) {\r\n                                                if (typeof modifier.where[0] === \"string\") {\r\n                                                    query.where([[tablePK, \"IN\", Ids], \"AND\", modifier.where]);\r\n                                                }\r\n                                                else {\r\n                                                    modifier.where.push(\"AND\");\r\n                                                    modifier.where.push([tablePK, \"IN\", Ids]);\r\n                                                    query.where(modifier.where);\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                query.where([tablePK, \"IN\", Ids]);\r\n                                            }\r\n                                            if (modifier.orderBy)\r\n                                                query.orderBy(modifier.orderBy);\r\n                                            query.limit(modifier.limit || 5).offset(modifier.offset || 0);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        query.where([tablePK, \"IN\", Ids.filter(function (v, i) { return i < 5; })]);\r\n                                    }\r\n                                    query.exec().then(function (relations) {\r\n                                        tableResult[k][useKey] = rel.type === \"single\" ? relations[0] : relations;\r\n                                        res();\r\n                                    });\r\n                                });\r\n                            }));\r\n                        })).then(function () {\r\n                            next(tableResult);\r\n                        });\r\n                    }\r\n                    else {\r\n                        next(tableResult);\r\n                    }\r\n                    break;\r\n            }\r\n        };\r\n        i = -1;\r\n        var qArgs = t._act.args || [];\r\n        var stepQuery = function (rowPKs) {\r\n            if (i < mods.length) {\r\n                i++;\r\n                modifyQuery(rowPKs, i, function (resultRows) {\r\n                    stepQuery(resultRows);\r\n                });\r\n            }\r\n            else {\r\n                rowPKs = rowPKs.filter(function (r) { return r; });\r\n                if (!t._getMod(\"join\") && !t._getMod(\"orm\")) {\r\n                    t._db._queryCache[t._tableID][t._queryHash] = rowPKs;\r\n                }\r\n                callBack(rowPKs, \"none\", []);\r\n            }\r\n        };\r\n        stepQuery(queryRows);\r\n    };\r\n    _NanoSQLQuery.prototype._remove = function (queryRows, callBack) {\r\n        var scribe = \"deleted\", i;\r\n        var t = this;\r\n        var qArgs = t._act.args || [];\r\n        var pk = t._db._store._tables[t._tableID]._pk;\r\n        i = 0;\r\n        var remove = function () {\r\n            if (i < queryRows.length) {\r\n                t._updateRow(queryRows[i][pk], function () {\r\n                    i++;\r\n                    remove();\r\n                });\r\n            }\r\n            else {\r\n                if (qArgs.length)\r\n                    scribe = \"modified\";\r\n                t._tableChanged(queryRows.map(function (r) { return r[pk]; }), scribe, callBack);\r\n            }\r\n        };\r\n        remove();\r\n    };\r\n    _NanoSQLQuery.prototype._where = function (row, conditions) {\r\n        var t = this;\r\n        var commands = [\"AND\", \"OR\"];\r\n        var maybeGetLength = function (key) {\r\n            if (key.indexOf(\".length\") !== -1) {\r\n                var value = row[key.replace(\".length\", \"\")];\r\n                return Array.isArray(value) ? value.length : 0;\r\n            }\r\n            else {\r\n                return row[key];\r\n            }\r\n        };\r\n        if (typeof conditions[0] !== \"string\") {\r\n            var prevCmd_1;\r\n            return conditions.reduce(function (prev, cur, i) {\r\n                if (commands.indexOf(cur) !== -1) {\r\n                    prevCmd_1 = cur;\r\n                    return prev;\r\n                }\r\n                else {\r\n                    var compare = t._compare(cur[2], cur[1], maybeGetLength(cur[0])) === 0 ? true : false;\r\n                    if (i === 0)\r\n                        return compare;\r\n                    if (prevCmd_1 === \"AND\") {\r\n                        return prev && compare;\r\n                    }\r\n                    else {\r\n                        return prev || compare;\r\n                    }\r\n                }\r\n            }, true);\r\n        }\r\n        else {\r\n            return t._compare(conditions[2], conditions[1], maybeGetLength(conditions[0])) === 0 ? true : false;\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._join = function (type, leftTableID, rightTableID, joinConditions, complete) {\r\n        var L = \"left\";\r\n        var R = \"right\";\r\n        var O = \"outer\";\r\n        var t = this;\r\n        var leftTableData = t._db._store._tables[leftTableID];\r\n        var rightTableData = t._db._store._tables[rightTableID];\r\n        var doJoinRows = function (leftRow, rightRow) {\r\n            return [leftTableData, rightTableData].reduce(function (prev, cur, i) {\r\n                cur._keys.forEach(function (k) {\r\n                    prev[cur._name + \".\" + k] = ((i === 0 ? leftRow : rightRow) || {})[k];\r\n                });\r\n                return prev;\r\n            }, {});\r\n        };\r\n        var joinTable = [];\r\n        var rightUsedPKs = [];\r\n        t._db._store._read(leftTableData._name, \"all\", function (leftRows) {\r\n            t._db._store._read(rightTableData._name, \"all\", function (rightRows) {\r\n                leftRows.forEach(function (leftRow) {\r\n                    var joinRows = rightRows.map(function (rightRow) {\r\n                        var joinedRow = doJoinRows(leftRow, rightRow);\r\n                        if (!joinConditions)\r\n                            return joinedRow;\r\n                        var keep = t._where(joinedRow, [joinConditions._left, joinConditions._check, joinedRow[joinConditions._right]]);\r\n                        if (keep)\r\n                            rightUsedPKs.push(rightRow[rightTableData._pk]);\r\n                        return keep ? joinedRow : null;\r\n                    }).filter(function (r) { return r; });\r\n                    if (joinRows.length) {\r\n                        joinTable = joinTable.concat(joinRows);\r\n                    }\r\n                    else if ([L, O].indexOf(type) >= 0) {\r\n                        joinTable.push(doJoinRows(leftRow, null));\r\n                    }\r\n                });\r\n                rightUsedPKs = rightUsedPKs.sort().filter(function (item, pos, ary) {\r\n                    return !pos || item !== ary[pos - 1];\r\n                });\r\n                if ([R, O].indexOf(type) >= 0) {\r\n                    rightRows.filter(function (r) {\r\n                        return rightUsedPKs.indexOf(r[rightTableData._pk]) === -1;\r\n                    }).forEach(function (rightRow) {\r\n                        joinTable.push(doJoinRows(null, rightRow));\r\n                    });\r\n                }\r\n                complete(joinTable);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._compare = function (val1, compare, val2) {\r\n        var setValue = function (val) {\r\n            return (compare === \"LIKE\" && typeof val === \"string\") ? val.toLowerCase() : val;\r\n        };\r\n        var left = setValue(val2);\r\n        var right = setValue(val1);\r\n        switch (compare) {\r\n            case \"=\": return left === right ? 0 : 1;\r\n            case \">\": return left > right ? 0 : 1;\r\n            case \"<\": return left < right ? 0 : 1;\r\n            case \"<=\": return left <= right ? 0 : 1;\r\n            case \">=\": return left >= right ? 0 : 1;\r\n            case \"IN\": return right.indexOf(left) < 0 ? 1 : 0;\r\n            case \"NOT IN\": return right.indexOf(left) < 0 ? 0 : 1;\r\n            case \"REGEX\": return left.search(right) < 0 ? 1 : 0;\r\n            case \"LIKE\": return left.indexOf(right) < 0 ? 1 : 0;\r\n            case \"BETWEEN\": return right[0] <= left && right[1] >= left ? 0 : 1;\r\n            case \"HAVE\": return (left || []).indexOf(right) < 0 ? 1 : 0;\r\n            default: return 1;\r\n        }\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\n",
dependencies: ["./index","./db-index","lie-ts"],
sourceMap: {},
headerContent: undefined,
mtime: 1494723283128
};