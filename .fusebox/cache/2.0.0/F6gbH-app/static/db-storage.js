module.exports = { contents: "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar db_query_1 = require(\"./db-query\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nvar prefix_trie_ts_1 = require(\"prefix-trie-ts\");\r\nvar _NanoSQL_Storage = (function () {\r\n    function _NanoSQL_Storage(database, args) {\r\n        this._savedArgs = args;\r\n        this.init(database, args);\r\n    }\r\n    _NanoSQL_Storage.prototype.init = function (database, args) {\r\n        var t = this;\r\n        t._models = {};\r\n        t._tables = {};\r\n        t._levelDBs = {};\r\n        t._historyPoint = 0;\r\n        t._historyLength = 0;\r\n        t._historyArray = [0, 0];\r\n        t._doingTransaction = false;\r\n        t._doHistory = true;\r\n        t._storeMemory = true;\r\n        t._persistent = false;\r\n        t._utilityTable = {};\r\n        t._historyPointIndex = {};\r\n        t._mode = 0;\r\n        t._parent = database;\r\n        var size = 5;\r\n        if (args._config.length) {\r\n            t._persistent = args._config[0].persistent !== undefined ? args._config[0].persistent : false;\r\n            t._doHistory = args._config[0].history !== undefined ? args._config[0].history : true;\r\n            t._storeMemory = args._config[0].memory !== undefined ? args._config[0].memory : true;\r\n            size = args._config[0].size || 5;\r\n            t._mode = {\r\n                IDB: 1,\r\n                LS: 2,\r\n                LVL: 4\r\n            }[args._config[0].mode] || 0;\r\n            if (args._config[0].rebuildIndexes)\r\n                t._rebuildIndexes = true;\r\n            if (args._config[0].id)\r\n                t._parent._databaseID = String(args._config[0].id);\r\n        }\r\n        var upgrading = false;\r\n        var index = 0;\r\n        var isNewStore = true;\r\n        Object.keys(args._models).forEach(function (t) {\r\n            var pkRow = { key: \"x\", type: \"x\" };\r\n            var secondaryIndexes = [];\r\n            args._models[t].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    pkRow = index_1._assign(m);\r\n                }\r\n                if (m.props && (m.props.indexOf(\"idx\") !== -1 || m.props.indexOf(\"trie\") !== -1)) {\r\n                    secondaryIndexes.push(m);\r\n                }\r\n            });\r\n            if (pkRow.key !== \"x\" && pkRow.type !== \"x\") {\r\n                args._models[\"_\" + t + \"_hist__data\"] = index_1._assign(args._models[t]).map(function (m) {\r\n                    delete m.props;\r\n                    return m;\r\n                });\r\n                args._models[\"_\" + t + \"_hist__data\"].unshift({ key: db_index_1._str(4), type: \"int\" });\r\n                args._models[\"_\" + t + \"_hist__meta\"] = [\r\n                    pkRow,\r\n                    { key: \"_pointer\", type: \"int\", default: 0 },\r\n                    { key: \"_historyDataRowIDs\", type: \"array\" },\r\n                ];\r\n            }\r\n            if (secondaryIndexes.length && (pkRow.key !== \"x\" && pkRow.type !== \"x\")) {\r\n                secondaryIndexes.forEach(function (s) {\r\n                    args._models[\"_\" + t + \"_idx_\" + s.key] = [\r\n                        { key: \"id\", type: s.type, props: [\"pk\"] },\r\n                        { key: \"rowPK\", type: pkRow.type }\r\n                    ];\r\n                });\r\n            }\r\n        });\r\n        args._models[db_index_1._str(1)] = [\r\n            { key: \"id\", type: \"int\", props: [\"ai\", \"pk\"] },\r\n            { key: \"tableID\", type: \"int\" },\r\n            { key: \"historyPoint\", type: \"int\" },\r\n            { key: \"rowKeys\", type: \"array\" },\r\n            { key: \"type\", type: \"string\" }\r\n        ];\r\n        args._models[db_index_1._str(0)] = [\r\n            { key: \"key\", type: \"string\", props: [\"pk\"] },\r\n            { key: \"value\", type: \"blob\" },\r\n        ];\r\n        var tables = Object.keys(args._models);\r\n        var beforeHist;\r\n        var beforeMode;\r\n        Object.keys(args._models).forEach(function (tableName) {\r\n            t._newTable(tableName, args._models[tableName]);\r\n        });\r\n        Object.keys(args._functions || {}).forEach(function (f) {\r\n            db_query_1._functions[f] = args._functions[f];\r\n        });\r\n        var rebuildSecondaryIndexes = function () {\r\n            if (!t._rebuildIndexes) {\r\n                t._rebuildTries(args._onSuccess);\r\n            }\r\n            else {\r\n                lie_ts_1.Promise.all(Object.keys(args._models).map(function (tableName) {\r\n                    return new lie_ts_1.Promise(function (res, rej) {\r\n                        t._rebuildSecondaryIndex(tableName, function () {\r\n                            res();\r\n                        });\r\n                    });\r\n                })).then(function () {\r\n                    t._rebuildTries(args._onSuccess);\r\n                });\r\n            }\r\n        };\r\n        var completeSetup = function () {\r\n            var tables = Object.keys(args._models);\r\n            var i = 0;\r\n            t._mode = beforeMode;\r\n            if (beforeHist) {\r\n                t._read(db_index_1._str(0), \"all\", function (rows) {\r\n                    rows.forEach(function (d) {\r\n                        t._utility(\"w\", d.key, d.value);\r\n                        if (d.key === \"historyPoint\")\r\n                            t._historyPoint = d.value || 0;\r\n                        if (d.key === \"historyLength\")\r\n                            t._historyLength = d.value || 0;\r\n                    });\r\n                });\r\n                t._read(db_index_1._str(1), \"all\", function (rows) {\r\n                    rows.forEach(function (row) {\r\n                        if (!t._historyPointIndex[row.historyPoint]) {\r\n                            t._historyPointIndex[row.historyPoint] = [];\r\n                        }\r\n                        t._historyPointIndex[row.historyPoint].push(row.id);\r\n                    });\r\n                });\r\n            }\r\n            if (isNewStore) {\r\n                var step_1 = function () {\r\n                    if (i < tables.length) {\r\n                        if (tables[i].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[i], 0, null, function () {\r\n                                i++;\r\n                                step_1();\r\n                            });\r\n                        }\r\n                        else {\r\n                            i++;\r\n                            step_1();\r\n                        }\r\n                    }\r\n                    else {\r\n                        t._doHistory = beforeHist;\r\n                        rebuildSecondaryIndexes();\r\n                    }\r\n                };\r\n                step_1();\r\n            }\r\n            else {\r\n                t._doHistory = beforeHist;\r\n                rebuildSecondaryIndexes();\r\n            }\r\n        };\r\n        beforeMode = t._mode;\r\n        if (t._persistent) {\r\n            if (t._mode !== 0) {\r\n                switch (t._mode) {\r\n                    case 1:\r\n                        if (typeof indexedDB === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 2:\r\n                        if (typeof localStorage === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 4:\r\n                        if (typeof window !== \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (typeof window !== \"undefined\") {\r\n                    if (typeof localStorage !== \"undefined\")\r\n                        t._mode = 2;\r\n                    if (typeof indexedDB !== \"undefined\")\r\n                        t._mode = 1;\r\n                }\r\n                if (typeof global !== \"undefined\") {\r\n                    if (typeof global._levelup !== \"undefined\" && typeof global._fs !== \"undefined\") {\r\n                        t._mode = 4;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            t._mode = 0;\r\n        }\r\n        beforeHist = t._doHistory;\r\n        beforeMode = t._mode;\r\n        t._mode = 0;\r\n        var createTables = function (makeTable, complete) {\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    makeTable(tables[index], ta, t._tables[ta]);\r\n                    index++;\r\n                    next();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        var cacheTableData = function (args) {\r\n            isNewStore = false;\r\n            var index = 0;\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta_1 = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    if (!beforeHist && (tables[index].indexOf(\"_hist__data\") !== -1 || tables[index].indexOf(\"_hist__meta\") !== -1)) {\r\n                        index++;\r\n                        next();\r\n                        return;\r\n                    }\r\n                    if (t._storeMemory) {\r\n                        args.requestTable(tables[index], function (tableData) {\r\n                            if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                                t._tables[ta_1]._index.push(0);\r\n                                t._tables[ta_1]._trieIndex.addWord(\"0\");\r\n                                t._tables[ta_1]._rows[0] = null;\r\n                                t._tables[ta_1]._incriment++;\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                    else if (!t._storeMemory || args.forceIndex) {\r\n                        args.requestIndex(tables[index], function (indexData) {\r\n                            t._parent._store._tables[ta_1]._index = indexData;\r\n                            t._parent._store._tables[ta_1]._incriment = indexData.reduce(function (prev, cur) {\r\n                                return Math.max(prev, parseInt(cur) || 0);\r\n                            }, 0);\r\n                            t._parent._store._tables[ta_1]._incriment++;\r\n                            index++;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    if (args.cleanup) {\r\n                        args.cleanup(function () {\r\n                            completeSetup();\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeSetup();\r\n                    }\r\n                    return;\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        switch (beforeMode) {\r\n            case 0:\r\n                completeSetup();\r\n                break;\r\n            case 1:\r\n                var idb = indexedDB.open(t._parent._databaseID, 1);\r\n                idb.onupgradeneeded = function (event) {\r\n                    upgrading = true;\r\n                    var db = event.target.result;\r\n                    var transaction = event.target.transaction;\r\n                    t._indexedDB = db;\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        var config = tableObj._pk ? { keyPath: tableObj._pk } : {};\r\n                        db.createObjectStore(tableName, config);\r\n                    }, function () {\r\n                        transaction.oncomplete = function () {\r\n                            completeSetup();\r\n                        };\r\n                    });\r\n                };\r\n                idb.onsuccess = function (event) {\r\n                    t._indexedDB = event.target.result;\r\n                    if (!upgrading) {\r\n                        var getIDBData_1 = function (tName, callBack) {\r\n                            var items = [];\r\n                            var transaction = t._indexedDB.transaction(tName, \"readonly\");\r\n                            var store = transaction.objectStore(tName);\r\n                            var cursorRequest = store.openCursor();\r\n                            cursorRequest.onsuccess = function (evt) {\r\n                                var cursor = evt.target.result;\r\n                                if (cursor) {\r\n                                    items.push(t._storeMemory ? cursor.value : cursor.key);\r\n                                    cursor.continue();\r\n                                }\r\n                            };\r\n                            transaction.oncomplete = function () {\r\n                                callBack(items);\r\n                            };\r\n                        };\r\n                        cacheTableData({\r\n                            requestIndex: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            },\r\n                            requestTable: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                break;\r\n            case 2:\r\n                if (localStorage.getItem(\"dbID\") !== t._parent._databaseID) {\r\n                    localStorage.setItem(\"dbID\", t._parent._databaseID);\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        localStorage.setItem(tableName, JSON.stringify([]));\r\n                    }, function () {\r\n                        completeSetup();\r\n                    });\r\n                }\r\n                else {\r\n                    cacheTableData({\r\n                        forceIndex: true,\r\n                        requestIndex: function (tableName, complete) {\r\n                            var tableIndex = JSON.parse(localStorage.getItem(tableName) || \"[]\");\r\n                            complete(tableIndex);\r\n                        },\r\n                        requestTable: function (tableName, complete) {\r\n                            var items = [];\r\n                            JSON.parse(localStorage.getItem(tableName) || \"[]\").forEach(function (ptr) {\r\n                                items.push(JSON.parse(localStorage.getItem(tableName + \"-\" + ptr) || \"\"));\r\n                            });\r\n                            complete(items);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            case 4:\r\n                var existingStore = function () {\r\n                    var getLevelData = function (tName, callBack) {\r\n                        var items = [];\r\n                        var stream = t._storeMemory ? t._levelDBs[tName].createValueStream() : t._levelDBs[tName].createKeyStream();\r\n                        stream.on(\"data\", function (data) {\r\n                            items.push(t._storeMemory ? JSON.parse(data) : data);\r\n                        })\r\n                            .on(\"end\", function () {\r\n                            callBack(items);\r\n                        });\r\n                    };\r\n                    cacheTableData({\r\n                        requestIndex: function (tableName, complete) {\r\n                            getLevelData(tableName, complete);\r\n                        },\r\n                        requestTable: function (tableName, complete) {\r\n                            getLevelData(tableName, complete);\r\n                        }\r\n                    });\r\n                };\r\n                var dbFolder_1 = \"./db_\" + t._parent._databaseID;\r\n                var existing = true;\r\n                if (!global._fs.existsSync(dbFolder_1)) {\r\n                    global._fs.mkdirSync(dbFolder_1);\r\n                    existing = false;\r\n                }\r\n                tables.forEach(function (table) {\r\n                    t._levelDBs[table] = global._levelup(dbFolder_1 + \"/\" + table, {\r\n                        cacheSize: 24 * 1024 * 1024,\r\n                        writeBufferSize: 12 * 1024 * 1024\r\n                    });\r\n                });\r\n                if (existing) {\r\n                    existingStore();\r\n                }\r\n                else {\r\n                    completeSetup();\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._rebuildSecondaryIndex = function (tableName, complete) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        var rowPTR = 0;\r\n        var secondIdx = t._tables[ta]._secondaryIndexes;\r\n        this._read(tableName, \"all\", function (rows) {\r\n            var PK = t._tables[ta]._pk;\r\n            var step2 = function () {\r\n                if (rowPTR < rows.length) {\r\n                    var ptr3_1 = 0;\r\n                    var step3_1 = function () {\r\n                        if (ptr3_1 < secondIdx.length) {\r\n                            var key_1 = secondIdx[ptr3_1];\r\n                            var idxTbl_1 = \"_\" + tableName + \"_idx_\" + key_1;\r\n                            var rowKey_1 = String(rows[rowPTR][key_1]).toLowerCase();\r\n                            t._read(idxTbl_1, rowKey_1, function (readRows) {\r\n                                var indexedRows = [rows[rowPTR][PK]];\r\n                                if (readRows.length && readRows[0].rowPK) {\r\n                                    indexedRows = indexedRows.concat(readRows[0].rowPK).filter(function (item, pos) {\r\n                                        return indexedRows.indexOf(item) === pos;\r\n                                    });\r\n                                }\r\n                                t._upsert(idxTbl_1, rowKey_1, {\r\n                                    id: rows[rowPTR][key_1],\r\n                                    rowPK: indexedRows\r\n                                }, function () {\r\n                                    ptr3_1++;\r\n                                    lie_ts_1.setFast(step3_1);\r\n                                });\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            rowPTR++;\r\n                            lie_ts_1.setFast(step2);\r\n                        }\r\n                    };\r\n                    step3_1();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            step2();\r\n        });\r\n    };\r\n    _NanoSQL_Storage.prototype._rebuildTries = function (callBack) {\r\n        var rebuildJob = {};\r\n        var jobLength = 0;\r\n        var t = this;\r\n        Object.keys(t._tables).forEach(function (tableID) {\r\n            var tableName = t._tables[tableID]._name;\r\n            if (tableName.indexOf(\"_\") !== 0) {\r\n                if (t._tables[tableID]._trieColumns.length) {\r\n                    rebuildJob[tableName] = t._tables[tableID]._trieColumns;\r\n                    jobLength++;\r\n                }\r\n            }\r\n        });\r\n        if (jobLength === 0) {\r\n            callBack();\r\n        }\r\n        else {\r\n            var tables_1 = Object.keys(rebuildJob);\r\n            var ptr_1 = 0;\r\n            var step_2 = function () {\r\n                if (ptr_1 < tables_1.length) {\r\n                    var ta_2 = index_1.NanoSQLInstance._hash(tables_1[ptr_1]);\r\n                    t._read(tables_1[ptr_1], \"all\", function (rows) {\r\n                        rows.forEach(function (row, i) {\r\n                            rebuildJob[tables_1[ptr_1]].forEach(function (key) {\r\n                                if (row[key])\r\n                                    t._tables[ta_2]._trieObjects[key].addWord(row[key]);\r\n                            });\r\n                        });\r\n                        ptr_1++;\r\n                        step_2();\r\n                    });\r\n                }\r\n                else {\r\n                    callBack();\r\n                }\r\n            };\r\n            step_2();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._execTransaction = function () {\r\n        var t = this;\r\n        var complete = function () {\r\n            Object.keys(t._transactionData).forEach(function (tableName) {\r\n                t._rebuildSecondaryIndex(tableName, function () { });\r\n            });\r\n        };\r\n        if (t._mode !== 4) {\r\n            complete();\r\n        }\r\n        switch (t._mode) {\r\n            case 4:\r\n                Object.keys(t._transactionData).forEach(function (tableName) {\r\n                    t._levelDBs[tableName].batch(t._transactionData[tableName]);\r\n                });\r\n                complete();\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._clear = function (type, complete) {\r\n        var t = this;\r\n        var tables = Object.keys(t._tables).map(function (k) { return t._tables[k]._name; });\r\n        var index = 0;\r\n        var setupNewHist = function () {\r\n            var index = 0;\r\n            var histStep = function () {\r\n                if (index < tables.length) {\r\n                    if (tables[index].indexOf(\"_hist__meta\") !== -1) {\r\n                        var referenceTable_1 = String(tables[index]).slice(1).replace(\"_hist__meta\", \"\");\r\n                        var ta = index_1.NanoSQLInstance._hash(referenceTable_1);\r\n                        var pk_1 = t._tables[ta]._pk;\r\n                        t._read(referenceTable_1, \"all\", function (rows) {\r\n                            rows.forEach(function (row, i) {\r\n                                var hist = {};\r\n                                hist[db_index_1._str(2)] = 0;\r\n                                hist[db_index_1._str(3)] = [i + 1];\r\n                                t._upsert(tables[index], row[pk_1], hist);\r\n                                t._upsert(\"_\" + referenceTable_1 + \"_hist__data\", i + 1, row);\r\n                            });\r\n                            index++;\r\n                            histStep();\r\n                        });\r\n                    }\r\n                    else {\r\n                        index++;\r\n                        histStep();\r\n                    }\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            histStep();\r\n        };\r\n        var step = function () {\r\n            if (index < tables.length) {\r\n                var deleteTable = false;\r\n                if (type === \"hist\" && (tables[index] === db_index_1._str(1) || tables[index].indexOf(\"_hist__meta\") !== -1 || tables[index].indexOf(\"_hist__data\") !== -1)) {\r\n                    deleteTable = true;\r\n                }\r\n                if (type === \"all\" && tables[index] !== \"_utility\") {\r\n                    deleteTable = true;\r\n                }\r\n                if (deleteTable) {\r\n                    t._delete(tables[index], \"all\", function () {\r\n                        if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[index], 0, null);\r\n                        }\r\n                        index++;\r\n                        step();\r\n                    });\r\n                }\r\n                else {\r\n                    index++;\r\n                    step();\r\n                }\r\n            }\r\n            else {\r\n                if (type === \"hist\") {\r\n                    setupNewHist();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            }\r\n        };\r\n        step();\r\n    };\r\n    _NanoSQL_Storage.prototype._delete = function (tableName, rowID, callBack) {\r\n        var t = this;\r\n        var editingHistory = false;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        var deleteRowIDS = [];\r\n        if (rowID === \"all\") {\r\n            deleteRowIDS = t._tables[ta]._index.slice();\r\n            t._tables[ta]._index = [];\r\n            t._tables[ta]._trieIndex = new prefix_trie_ts_1.Trie([]);\r\n        }\r\n        else {\r\n            deleteRowIDS.push(rowID);\r\n            t._tables[ta]._trieIndex.removeWord(String(rowID));\r\n            t._tables[ta]._index.splice(t._tables[ta]._index.indexOf(rowID), 1);\r\n        }\r\n        if (t._storeMemory) {\r\n            if (rowID === \"all\") {\r\n                t._tables[ta]._rows = {};\r\n            }\r\n            else {\r\n                delete t._tables[ta]._rows[rowID];\r\n            }\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(true);\r\n        }\r\n        if (t._mode > 0) {\r\n            var i_1 = 0;\r\n            var step_3 = function () {\r\n                if (i_1 < deleteRowIDS.length) {\r\n                    switch (t._mode) {\r\n                        case 1:\r\n                            t._indexedDB.transaction(tableName, \"readwrite\").objectStore(tableName).delete(deleteRowIDS[i_1]);\r\n                            i_1++;\r\n                            step_3();\r\n                            break;\r\n                        case 2:\r\n                            localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                            localStorage.removeItem(tableName + \"-\" + String(deleteRowIDS[i_1]));\r\n                            i_1++;\r\n                            step_3();\r\n                            break;\r\n                        case 4:\r\n                            if (t._doingTransaction) {\r\n                                if (!t._transactionData[tableName]) {\r\n                                    t._transactionData[tableName] = [];\r\n                                }\r\n                                t._transactionData[tableName].push({\r\n                                    type: \"del\",\r\n                                    key: deleteRowIDS[i_1],\r\n                                    value: \"\"\r\n                                });\r\n                                i_1++;\r\n                                step_3();\r\n                            }\r\n                            else {\r\n                                t._levelDBs[tableName].del(deleteRowIDS[i_1], function () {\r\n                                    i_1++;\r\n                                    step_3();\r\n                                });\r\n                            }\r\n                            break;\r\n                        default:\r\n                            i_1++;\r\n                            step_3();\r\n                    }\r\n                }\r\n                else {\r\n                    if (callBack)\r\n                        callBack(true);\r\n                }\r\n            };\r\n            step_3();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._generateID = function (type, tableIncriment) {\r\n        switch (type) {\r\n            case \"int\": return tableIncriment++;\r\n            case \"uuid\": return index_1.NanoSQLInstance.uuid();\r\n            case \"timeId\": return index_1.NanoSQLInstance.timeid();\r\n            case \"timeIdms\": return index_1.NanoSQLInstance.timeid(true);\r\n        }\r\n        return \"\";\r\n    };\r\n    _NanoSQL_Storage.prototype._upsert = function (tableName, rowID, rowData, callBack) {\r\n        var t = this;\r\n        if (Object.isFrozen(rowData))\r\n            rowData = index_1._assign(rowData);\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (rowID === undefined || rowID === null) {\r\n            t._models[ta].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    rowID = t._generateID(m.type, t._tables[ta]._incriment);\r\n                }\r\n            });\r\n            if (!rowID)\r\n                rowID = parseInt(t._tables[ta]._index[t._tables[ta]._index.length - 1] || \"0\") + 1;\r\n        }\r\n        if (tableName.indexOf(\"_\") !== 0 && rowData) {\r\n            delete rowData[db_index_1._str(4)];\r\n        }\r\n        else if (tableName.indexOf(\"_hist__data\") !== -1 && rowData) {\r\n            rowID = rowData[db_index_1._str(4)];\r\n        }\r\n        if (t._tables[ta]._pkType === \"int\")\r\n            rowID = parseInt(rowID);\r\n        var pk = t._tables[ta]._pk;\r\n        if (pk && pk.length && rowData && rowData[pk] === undefined) {\r\n            rowData[pk] = rowID;\r\n        }\r\n        if (!t._tables[ta]._trieIndex.getPrefix(String(rowID)).length) {\r\n            t._tables[ta]._trieIndex.addWord(String(rowID));\r\n            t._tables[ta]._index.push(rowID);\r\n        }\r\n        if (t._storeMemory) {\r\n            t._tables[ta]._rows[rowID] = t._parent._deepFreeze(rowData, ta);\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(rowID);\r\n        }\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readwrite\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (pk.length && rowData) {\r\n                    store.put(rowData);\r\n                }\r\n                else {\r\n                    if (tableName.indexOf(\"_hist__data\") !== -1) {\r\n                        store.put(rowData, rowID);\r\n                    }\r\n                    else {\r\n                        if (rowData)\r\n                            store.put(rowData);\r\n                        if (!rowData)\r\n                            store.delete(rowID);\r\n                    }\r\n                }\r\n                transaction.oncomplete = function () {\r\n                    if (callBack)\r\n                        callBack(rowID);\r\n                };\r\n                break;\r\n            case 2:\r\n                localStorage.setItem(tableName + \"-\" + String(rowID), rowData ? JSON.stringify(rowData) : \"\");\r\n                localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                if (callBack)\r\n                    callBack(rowID);\r\n                break;\r\n            case 4:\r\n                if (t._doingTransaction) {\r\n                    if (!t._transactionData[tableName]) {\r\n                        t._transactionData[tableName] = [];\r\n                    }\r\n                    t._transactionData[tableName].push({\r\n                        type: tableName.indexOf(\"_hist__data\") !== -1 ? \"put\" : !rowData ? \"del\" : \"put\",\r\n                        key: rowID,\r\n                        value: rowData ? JSON.stringify(rowData) : \"\"\r\n                    });\r\n                    if (callBack)\r\n                        callBack(rowID);\r\n                }\r\n                else {\r\n                    if (tableName.indexOf(\"_hist__data\") !== -1) {\r\n                        t._levelDBs[tableName].put(rowID, rowData ? JSON.stringify(rowData) : null, function () {\r\n                            if (callBack)\r\n                                callBack(rowID);\r\n                        });\r\n                    }\r\n                    else {\r\n                        if (rowData) {\r\n                            t._levelDBs[tableName].put(rowID, JSON.stringify(rowData), function () {\r\n                                if (callBack)\r\n                                    callBack(rowID);\r\n                            });\r\n                        }\r\n                        else {\r\n                            t._levelDBs[tableName].del(rowID, function () {\r\n                                if (callBack)\r\n                                    callBack(rowID);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._indexRead = function (tableName, rows, callBack, getIndex) {\r\n        var _this = this;\r\n        var isSecondIndex = tableName.indexOf(\"_\") === 0 && tableName.indexOf(\"_idx_\") !== -1;\r\n        if (!isSecondIndex || getIndex) {\r\n            callBack(rows);\r\n        }\r\n        else {\r\n            var parentTable_1 = !isSecondIndex ? \"\" : tableName.slice(1, tableName.indexOf(\"_idx_\"));\r\n            var allRowIDs_1 = rows.reduce(function (prev, cur) {\r\n                return prev.concat(cur.rowPK);\r\n            }, []);\r\n            var resultRows_1 = [];\r\n            var ptr_2 = 0;\r\n            var step_4 = function () {\r\n                if (ptr_2 < allRowIDs_1.length) {\r\n                    _this._read(parentTable_1, allRowIDs_1[ptr_2], function (rows) {\r\n                        resultRows_1 = resultRows_1.concat(rows);\r\n                        ptr_2++;\r\n                        step_4();\r\n                    });\r\n                }\r\n                else {\r\n                    callBack(resultRows_1);\r\n                }\r\n            };\r\n            step_4();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._readArray = function (tableName, pkArray, callBack) {\r\n        var _this = this;\r\n        var rows = [];\r\n        var ptr = 0;\r\n        var readRow = function () {\r\n            if (ptr < pkArray.length) {\r\n                _this._read(tableName, pkArray[ptr], function (newRows) {\r\n                    rows = rows.concat(newRows);\r\n                    ptr++;\r\n                    readRow();\r\n                });\r\n            }\r\n            else {\r\n                callBack(rows);\r\n            }\r\n        };\r\n        readRow();\r\n    };\r\n    _NanoSQL_Storage.prototype._readRange = function (tableName, key, between, callBack) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (t._mode === 0 || t._mode === 2) {\r\n            var startPtr_1 = t._tables[ta]._index.indexOf(between[0]);\r\n            var resultRows_2 = [];\r\n            if (startPtr_1 === -1) {\r\n                callBack(resultRows_2);\r\n                return;\r\n            }\r\n            var stepRead_1 = function () {\r\n                var pk = t._tables[ta]._index[startPtr_1];\r\n                if (!pk) {\r\n                    callBack(resultRows_2);\r\n                    return;\r\n                }\r\n                if (pk <= between[1]) {\r\n                    t._read(tableName, pk, function (rows) {\r\n                        resultRows_2 = resultRows_2.concat(rows);\r\n                        startPtr_1++;\r\n                        stepRead_1();\r\n                    });\r\n                }\r\n                else {\r\n                    callBack(resultRows_2);\r\n                }\r\n            };\r\n            stepRead_1();\r\n            return;\r\n        }\r\n        var rows = [];\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                var cursorRequest = store.openCursor(IDBKeyRange.bound(between[0], between[1]));\r\n                transaction.oncomplete = function () {\r\n                    _this._indexRead(tableName, rows, callBack);\r\n                };\r\n                cursorRequest.onsuccess = function (evt) {\r\n                    var cursor = evt.target.result;\r\n                    if (cursor) {\r\n                        rows.push(cursor.value);\r\n                        cursor.continue();\r\n                    }\r\n                };\r\n                break;\r\n            case 4:\r\n                t._levelDBs[tableName].createValueStream({\r\n                    gte: between[0],\r\n                    lte: between[1]\r\n                })\r\n                    .on(\"data\", function (data) {\r\n                    if (data)\r\n                        rows.push(JSON.parse(data));\r\n                })\r\n                    .on(\"end\", function () {\r\n                    _this._indexRead(tableName, rows, callBack);\r\n                });\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._read = function (tableName, row, callBack, readIndex) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (t._storeMemory) {\r\n            var rows_1 = t._tables[ta]._rows;\r\n            if (row === \"all\" || typeof row === \"function\") {\r\n                var allRows = Object.keys(rows_1).map(function (r) { return rows_1[r]; });\r\n                if (row === \"all\") {\r\n                    t._indexRead(tableName, allRows.filter(function (r) { return r; }), callBack, readIndex);\r\n                }\r\n                else {\r\n                    t._indexRead(tableName, allRows.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                }\r\n            }\r\n            else {\r\n                t._indexRead(tableName, [rows_1[row]].filter(function (r) { return r; }), callBack, readIndex);\r\n            }\r\n            return;\r\n        }\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var cursorRequest = store.openCursor();\r\n                    var rows_2 = [];\r\n                    transaction.oncomplete = function () {\r\n                        _this._indexRead(tableName, rows_2, callBack, readIndex);\r\n                    };\r\n                    cursorRequest.onsuccess = function (evt) {\r\n                        var cursor = evt.target.result;\r\n                        if (cursor) {\r\n                            if (row !== \"all\") {\r\n                                if (row(cursor.value))\r\n                                    rows_2.push(cursor.value);\r\n                            }\r\n                            else {\r\n                                rows_2.push(cursor.value);\r\n                            }\r\n                            cursor.continue();\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    var singleReq_1 = store.get(row);\r\n                    singleReq_1.onsuccess = function (event) {\r\n                        _this._indexRead(tableName, [singleReq_1.result], callBack, readIndex);\r\n                    };\r\n                }\r\n                break;\r\n            case 2:\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var rows = t._tables[ta]._index.map(function (idx) {\r\n                        var item = localStorage.getItem(tableName + \"-\" + idx);\r\n                        return item && item.length ? JSON.parse(item) : null;\r\n                    });\r\n                    if (row !== \"all\") {\r\n                        this._indexRead(tableName, rows.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                    }\r\n                    else {\r\n                        this._indexRead(tableName, rows, callBack, readIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    var item = localStorage.getItem(tableName + \"-\" + row);\r\n                    this._indexRead(tableName, [item && item.length ? JSON.parse(item) : null], callBack, readIndex);\r\n                }\r\n                break;\r\n            case 4:\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var rows_3 = [];\r\n                    t._levelDBs[tableName].createValueStream()\r\n                        .on(\"data\", function (data) {\r\n                        if (data)\r\n                            rows_3.push(JSON.parse(data));\r\n                    })\r\n                        .on(\"end\", function () {\r\n                        if (row !== \"all\") {\r\n                            _this._indexRead(tableName, rows_3.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                        }\r\n                        else {\r\n                            _this._indexRead(tableName, rows_3, callBack, readIndex);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    t._levelDBs[tableName].get(row, function (err, data) {\r\n                        if (err) {\r\n                            _this._indexRead(tableName, [], callBack, readIndex);\r\n                        }\r\n                        else {\r\n                            _this._indexRead(tableName, [JSON.parse(data)], callBack, readIndex);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._utility = function (type, key, value) {\r\n        var t = this;\r\n        if (type === \"r\") {\r\n            if (t._utilityTable[key]) {\r\n                return t._utilityTable[key].value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            t._upsert(db_index_1._str(0), key, { key: key, value: value });\r\n            t._utility[key] = {\r\n                key: key,\r\n                value: value\r\n            };\r\n            return value;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._newTable = function (tableName, dataModels) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        t._models[ta] = dataModels;\r\n        t._parent._queryCache[ta] = {};\r\n        t._tables[ta] = {\r\n            _pk: \"\",\r\n            _pkType: \"\",\r\n            _keys: [],\r\n            _relations: [],\r\n            _defaults: [],\r\n            _secondaryIndexes: [],\r\n            _trieColumns: [],\r\n            _trieObjects: {},\r\n            _name: tableName,\r\n            _incriment: 1,\r\n            _index: [],\r\n            _trieIndex: new prefix_trie_ts_1.Trie([]),\r\n            _rows: {}\r\n        };\r\n        var i = t._models[ta].length;\r\n        var keys = [];\r\n        var defaults = [];\r\n        var _loop_1 = function () {\r\n            var p = t._models[ta][i];\r\n            t._tables[ta]._keys.unshift(p.key);\r\n            t._tables[ta]._defaults[i] = p.default;\r\n            if (p.props && p.props.indexOf(\"pk\") >= 0) {\r\n                t._tables[ta]._pk = p.key;\r\n                t._tables[ta]._pkType = p.type;\r\n            }\r\n            if (p.props && (p.props.indexOf(\"idx\") >= 0 || p.props.indexOf(\"trie\") >= 0)) {\r\n                t._tables[ta]._secondaryIndexes.push(p.key);\r\n            }\r\n            if (p.props && p.props.indexOf(\"trie\") >= 0) {\r\n                t._tables[ta]._trieColumns.push(p.key);\r\n                t._tables[ta]._trieObjects[p.key] = new prefix_trie_ts_1.Trie([]);\r\n            }\r\n            if (p.props && t._parent._parent._tableNames.indexOf(p.type.replace(\"[]\", \"\")) !== -1) {\r\n                var mapTo_1 = \"\";\r\n                p.props.forEach(function (p) {\r\n                    if (p.indexOf(\"orm::\") !== -1)\r\n                        mapTo_1 = p.replace(\"orm::\", \"\");\r\n                });\r\n                t._tables[ta]._relations.push({\r\n                    table: p.type.replace(\"[]\", \"\"),\r\n                    key: p.key,\r\n                    mapTo: mapTo_1,\r\n                    type: p.type.indexOf(\"[]\") === -1 ? \"single\" : \"array\"\r\n                });\r\n            }\r\n        };\r\n        while (i--) {\r\n            _loop_1();\r\n        }\r\n        return tableName;\r\n    };\r\n    return _NanoSQL_Storage;\r\n}());\r\nexports._NanoSQL_Storage = _NanoSQL_Storage;\r\n",
dependencies: ["./index","./db-index","./db-query","lie-ts","prefix-trie-ts"],
sourceMap: {},
headerContent: undefined,
mtime: 1494723115464
};