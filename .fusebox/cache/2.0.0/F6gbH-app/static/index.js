module.exports = { contents: "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar db_index_1 = require(\"./db-index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nexports._assign = function (obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n};\r\nvar NanoSQLInstance = (function () {\r\n    function NanoSQLInstance() {\r\n        var t = this;\r\n        t._actions = {};\r\n        t._views = {};\r\n        t._models = {};\r\n        t._preConnectExtend = [];\r\n        t._transactionTables = [];\r\n        t._events = [\"change\", \"delete\", \"upsert\", \"drop\", \"select\", \"error\"];\r\n        t._callbacks = {};\r\n        t._ormFns = {};\r\n        t._hasEvents = {};\r\n        t._callbacks[\"*\"] = {};\r\n        t._tableNames = [];\r\n        var i = t._events.length;\r\n        while (i--) {\r\n            t._callbacks[\"*\"][t._events[i]] = [];\r\n        }\r\n        t._functions = {};\r\n        t._rowFilters = {};\r\n    }\r\n    NanoSQLInstance.prototype.table = function (table) {\r\n        if (table)\r\n            this._selectedTable = table;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.connect = function (backend) {\r\n        var _this = this;\r\n        var t = this;\r\n        if (t.backend) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                rej();\r\n                throw Error();\r\n            });\r\n        }\r\n        t.backend = backend || new db_index_1._NanoSQLDB();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.backend._connect({\r\n                _models: t._models,\r\n                _actions: t._actions,\r\n                _views: t._views,\r\n                _functions: t._functions,\r\n                _config: t._preConnectExtend,\r\n                _parent: _this,\r\n                _onSuccess: function (result) {\r\n                    res(result, t);\r\n                },\r\n                _onFail: function (rejected) {\r\n                    if (rej)\r\n                        rej(rejected, t);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.on = function (actions, callBack) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = 0;\r\n        var a = actions.split(\" \");\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        i = a.length;\r\n        while (i--) {\r\n            if (t._events.indexOf(a[i]) !== -1) {\r\n                t._callbacks[l][a[i]].push(callBack);\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.off = function (callBack) {\r\n        var t = this;\r\n        for (var key in t._callbacks) {\r\n            for (var key2 in t._callbacks[key]) {\r\n                t._callbacks[key][key2] = t._callbacks[key][key2].filter(function (cBs) {\r\n                    return cBs !== callBack;\r\n                });\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype._refreshEventChecker = function () {\r\n        var _this = this;\r\n        this._hasEvents = {};\r\n        Object.keys(this._models).concat([\"*\"]).forEach(function (table) {\r\n            _this._hasEvents[table] = _this._events.reduce(function (prev, cur) {\r\n                return prev + (_this._callbacks[table] ? _this._callbacks[table][cur].length : 0);\r\n            }, 0) > 0;\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.model = function (dataModel) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = t._events.length;\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        t._models[l] = dataModel;\r\n        t._tableNames.push(l);\r\n        t._views[l] = [];\r\n        t._actions[l] = [];\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.views = function (viewArray) {\r\n        return this._views[this._selectedTable] = viewArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.getView = function (viewName, viewArgs) {\r\n        if (viewArgs === void 0) { viewArgs = {}; }\r\n        return this._doAV(\"View\", this._views[this._selectedTable], viewName, viewArgs);\r\n    };\r\n    NanoSQLInstance.prototype.cleanArgs = function (argDeclarations, args) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var a = {};\r\n        var i = argDeclarations.length ? argDeclarations.length : -1;\r\n        if (i > 0) {\r\n            while (i--) {\r\n                var k2 = argDeclarations[i].split(\":\");\r\n                if (k2.length > 1) {\r\n                    a[k2[0]] = t._cast(k2[1], args[k2[0]] || null);\r\n                }\r\n                else {\r\n                    a[k2[0]] = args[k2[0]] || null;\r\n                }\r\n            }\r\n        }\r\n        return a;\r\n    };\r\n    NanoSQLInstance.prototype._cast = function (type, val) {\r\n        var _this = this;\r\n        var p = this;\r\n        var entityMap = {\r\n            \"&\": \"&amp;\",\r\n            \"<\": \"&lt;\",\r\n            \">\": \"&gt;\",\r\n            \"\\\"\": \"&quot;\",\r\n            \"'\": \"&#39;\",\r\n            \"/\": \"&#x2F;\",\r\n            \"`\": \"&#x60;\",\r\n            \"=\": \"&#x3D;\"\r\n        };\r\n        var t = typeof val;\r\n        var types = function (type, val) {\r\n            switch (type) {\r\n                case \"safestr\": return types(\"string\", val).replace(/[&<>\"'`=\\/]/g, function (s) { return entityMap[s]; });\r\n                case \"int\": return (t !== \"number\" || val % 1 !== 0) ? parseInt(val || 0) : val;\r\n                case \"float\": return t !== \"number\" ? parseFloat(val || 0) : val;\r\n                case \"any[]\":\r\n                case \"array\": return Array.isArray(val) ? exports._assign(val || []) : [];\r\n                case \"uuid\":\r\n                case \"timeId\":\r\n                case \"timeIdms\":\r\n                case \"string\": return val === null ? \"\" : t !== \"string\" ? String(val) : val;\r\n                case \"map\": return t === \"object\" ? exports._assign(val || {}) : {};\r\n                case \"bool\": return val === true;\r\n            }\r\n            return val;\r\n        };\r\n        var newVal = types(type, val);\r\n        if (type.indexOf(\"[]\") !== -1) {\r\n            var arrayOf_1 = type.slice(0, type.lastIndexOf(\"[]\"));\r\n            return (val || []).map(function (v) {\r\n                return _this._cast(arrayOf_1, v);\r\n            });\r\n        }\r\n        else if (newVal !== undefined) {\r\n            if ([\"int\", \"float\"].indexOf(type) !== -1) {\r\n                return isNaN(newVal) ? 0 : newVal;\r\n            }\r\n            else {\r\n                return newVal;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    NanoSQLInstance.prototype.actions = function (actionArray) {\r\n        return this._actions[this._selectedTable] = actionArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.doAction = function (actionName, actionArgs) {\r\n        return this._doAV(\"Action\", this._actions[this._selectedTable], actionName, actionArgs);\r\n    };\r\n    NanoSQLInstance.prototype._doAV = function (AVType, AVList, AVName, AVargs) {\r\n        var _this = this;\r\n        var t = this;\r\n        var selAV = AVList.reduce(function (prev, cur) {\r\n            if (cur.name === AVName)\r\n                return cur;\r\n            return prev;\r\n        }, null);\r\n        if (!selAV) {\r\n            return new lie_ts_1.Promise(function (res, rej) { return rej(\"Action/View Not Found!\"); });\r\n        }\r\n        t._activeAV = AVName;\r\n        var cleanArgs = selAV.args ? t.cleanArgs(selAV.args, AVargs) : {};\r\n        if (t._AVMod) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                t._AVMod(_this._selectedTable, AVType, t._activeAV || \"\", cleanArgs, function (args) {\r\n                    selAV ? selAV.call(args, t).then(function (result) {\r\n                        res(result, t);\r\n                    }) : false;\r\n                }, function (err) {\r\n                    rej(err);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return selAV.call(cleanArgs, t);\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.newFunction = function (functionName, functionType, filterFunction) {\r\n        return this._functions[functionName] = { type: functionType, call: filterFunction }, this;\r\n    };\r\n    NanoSQLInstance.prototype.query = function (action, args, bypassClean) {\r\n        var t = this;\r\n        var query = new _NanoSQLQuery(t._selectedTable, t, t._activeAV);\r\n        t._activeAV = undefined;\r\n        var a = action.toLowerCase();\r\n        if ([\"select\", \"upsert\", \"delete\", \"drop\", \"show tables\", \"describe\"].indexOf(a) !== -1) {\r\n            var newArgs_1 = args || (a === \"select\" || a === \"delete\" ? [] : {});\r\n            if ([\"upsert\", \"delete\", \"drop\"].indexOf(a) !== -1) {\r\n                t._transactionTables.push(t._selectedTable);\r\n            }\r\n            if (action === \"upsert\") {\r\n                var inputArgs_1 = {};\r\n                if (!bypassClean) {\r\n                    t._models[t._selectedTable].forEach(function (model) {\r\n                        if (newArgs_1[model.key] !== undefined) {\r\n                            var cast = t._cast(model.type, newArgs_1[model.key]);\r\n                            if (cast !== undefined)\r\n                                inputArgs_1[model.key] = cast;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    inputArgs_1 = newArgs_1;\r\n                }\r\n                if (t._rowFilters[t._selectedTable]) {\r\n                    inputArgs_1 = t._rowFilters[t._selectedTable](inputArgs_1);\r\n                }\r\n                newArgs_1 = inputArgs_1;\r\n            }\r\n            query._action = { type: a, args: newArgs_1 };\r\n        }\r\n        else {\r\n            throw Error;\r\n        }\r\n        return query;\r\n    };\r\n    NanoSQLInstance.prototype.updateORM = function (action, column, relationIDs) {\r\n        return new _NanoSQLORMQuery(this, this._selectedTable, action, column, relationIDs);\r\n    };\r\n    NanoSQLInstance.prototype.defaultORM = function (callBack) {\r\n        this._ormFns[this._selectedTable] = callBack;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.triggerEvent = function (eventData, triggerEvents) {\r\n        var t = this;\r\n        setTimeout(function () {\r\n            var i = triggerEvents.length;\r\n            var j = 0;\r\n            var e;\r\n            var c;\r\n            while (i--) {\r\n                e = triggerEvents[i];\r\n                c = t._callbacks[eventData.table][e].concat(t._callbacks[eventData.table][\"*\"]);\r\n                j = c.length;\r\n                while (j--) {\r\n                    eventData.name = e;\r\n                    c[j](eventData, t);\r\n                }\r\n            }\r\n        }, 0);\r\n    };\r\n    NanoSQLInstance.prototype.default = function (replaceObj) {\r\n        var newObj = {};\r\n        var t = this;\r\n        t._models[t._selectedTable].forEach(function (m) {\r\n            newObj[m.key] = (replaceObj && replaceObj[m.key]) ? replaceObj[m.key] : m.default;\r\n            if (!newObj[m.key]) {\r\n                newObj[m.key] = t._cast(m.type, null);\r\n            }\r\n        });\r\n        return newObj;\r\n    };\r\n    NanoSQLInstance.prototype.beginTransaction = function () {\r\n        this.doingTransaction = true;\r\n        this._transactionTables = [];\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"start\");\r\n    };\r\n    NanoSQLInstance.prototype.endTransaction = function () {\r\n        var _this = this;\r\n        this.doingTransaction = false;\r\n        this._transactionTables.forEach(function (table) {\r\n            if (table.indexOf(\"_\") !== 0) {\r\n                _this.triggerEvent({\r\n                    table: table,\r\n                    query: [],\r\n                    time: new Date().getTime(),\r\n                    result: [],\r\n                    name: \"change\",\r\n                    actionOrView: \"\",\r\n                    changeType: \"transaction\",\r\n                    changedRows: []\r\n                }, [\"change\"]);\r\n            }\r\n        });\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"end\");\r\n    };\r\n    NanoSQLInstance.prototype.queryFilter = function (callBack) {\r\n        this._queryMod = callBack;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.avFilter = function (filterFunc) {\r\n        this._AVMod = filterFunc;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.config = function (args) {\r\n        var t = this;\r\n        if (!t.backend)\r\n            t._preConnectExtend.push(args);\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.extend = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var t = this;\r\n        if (t.backend) {\r\n            if (t.backend._extend) {\r\n                args.unshift(t);\r\n                return t.backend._extend.apply(t.backend, args);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.loadJS = function (table, rows) {\r\n        var t = this;\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            var pointer = 0;\r\n            var rowData = [];\r\n            var next = function () {\r\n                if (pointer < rows.length) {\r\n                    if (rows[pointer]) {\r\n                        t.table(table).query(\"upsert\", rows[pointer]).exec().then(function (res) {\r\n                            rowData.push(res);\r\n                            pointer++;\r\n                            next();\r\n                        });\r\n                    }\r\n                    else {\r\n                        pointer++;\r\n                        next();\r\n                    }\r\n                }\r\n                else {\r\n                    t.endTransaction();\r\n                    res(rowData, t);\r\n                }\r\n            };\r\n            next();\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.rowFilter = function (callBack) {\r\n        return this._rowFilters[this._selectedTable] = callBack, this;\r\n    };\r\n    NanoSQLInstance.prototype.loadCSV = function (table, csv) {\r\n        var t = this;\r\n        var fields = [];\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            lie_ts_1.Promise.all(csv.split(\"\\n\").map(function (v, k) {\r\n                return new lie_ts_1.Promise(function (resolve, reject) {\r\n                    if (k === 0) {\r\n                        fields = v.split(\",\");\r\n                        resolve();\r\n                    }\r\n                    else {\r\n                        var record = {};\r\n                        var row = v.match(/(\".*?\"|[^\",\\s]+)(?=\\s*,|\\s*$)/g) || [];\r\n                        var i = fields.length;\r\n                        while (i--) {\r\n                            if (row[i].indexOf(\"{\") === 1 || row[i].indexOf(\"[\") === 1) {\r\n                                row[i] = JSON.parse(row[i].slice(1, row[i].length - 1).replace(/'/gm, '\\\"'));\r\n                            }\r\n                            else if (row[i].indexOf('\"') === 0) {\r\n                                row[i] = row[i].slice(1, row[i].length - 1);\r\n                            }\r\n                            record[fields[i]] = row[i];\r\n                        }\r\n                        t.table(table).query(\"upsert\", record).exec().then(function () {\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            })).then(function () {\r\n                t.endTransaction();\r\n                res([], t);\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance._random16Bits = function () {\r\n        if (typeof crypto === \"undefined\") {\r\n            return Math.round(Math.random() * Math.pow(2, 16));\r\n        }\r\n        else {\r\n            if (crypto.getRandomValues) {\r\n                var buf = new Uint16Array(1);\r\n                crypto.getRandomValues(buf);\r\n                return buf[0];\r\n            }\r\n            else if (global !== \"undefined\" && global._crypto.randomBytes) {\r\n                return global._crypto.randomBytes(2).reduce(function (prev, cur) { return cur * prev; });\r\n            }\r\n            else {\r\n                return Math.round(Math.random() * Math.pow(2, 16));\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.timeid = function (ms) {\r\n        var t = this;\r\n        if (!t._tzOffset) {\r\n            t._tzOffset = new Date().getTimezoneOffset() * 60000;\r\n        }\r\n        var time = Math.round((new Date().getTime() + t._tzOffset) / (ms ? 1 : 1000)).toString();\r\n        while (time.length < (ms ? 13 : 10)) {\r\n            time = \"0\" + time;\r\n        }\r\n        return time + \"-\" + (t._random16Bits() + t._random16Bits()).toString(16);\r\n    };\r\n    NanoSQLInstance.uuid = function () {\r\n        var _this = this;\r\n        var r, s, b = \"\";\r\n        return [b, b, b, b, b, b, b, b, b].reduce(function (prev, cur, i) {\r\n            r = _this._random16Bits();\r\n            s = (i === 4 ? i : (i === 5 ? (r % 16 & 0x3 | 0x8).toString(16) : b));\r\n            r = r.toString(16);\r\n            while (r.length < 4)\r\n                r = \"0\" + r;\r\n            return prev + ([3, 4, 5, 6].indexOf(i) >= 0 ? \"-\" : b) + (s + r).slice(0, 4);\r\n        }, b);\r\n    };\r\n    NanoSQLInstance._hash = function (key) {\r\n        return Math.abs(key.split(\"\").reduce(function (prev, next, i) {\r\n            return ((prev << 5) + prev) + key.charCodeAt(i);\r\n        }, 0));\r\n    };\r\n    return NanoSQLInstance;\r\n}());\r\nexports.NanoSQLInstance = NanoSQLInstance;\r\nvar _NanoSQLORMQuery = (function () {\r\n    function _NanoSQLORMQuery(db, table, action, column, relationIDs) {\r\n        this._db = db;\r\n        this._tableName = table;\r\n        this._action = action;\r\n        this._column = column || \"\";\r\n        this._relationIDs = relationIDs || [];\r\n    }\r\n    _NanoSQLORMQuery.prototype.where = function (args) {\r\n        this._whereArgs = args;\r\n        return this;\r\n    };\r\n    _NanoSQLORMQuery.prototype.rebuild = function (callBack) {\r\n        var t = this;\r\n        t._db.beginTransaction();\r\n        var relations = t._db._models[t._tableName].filter(function (m) {\r\n            return t._db._tableNames.indexOf(m.type.replace(\"[]\", \"\")) !== -1;\r\n        }).map(function (m) {\r\n            var tableName = m.type.replace(\"[]\", \"\");\r\n            return {\r\n                key: m.key,\r\n                tablePK: t._db._models[tableName].reduce(function (prev, cur) {\r\n                    if (cur.props && cur.props.indexOf(\"pk\") !== -1)\r\n                        return cur.key;\r\n                    return prev;\r\n                }, \"\"),\r\n                table: tableName,\r\n                type: m.type.indexOf(\"[]\") === -1 ? \"single\" : \"array\"\r\n            };\r\n        });\r\n        var tablePK = t._db._models[t._tableName].reduce(function (prev, cur) {\r\n            if (cur.props && cur.props.indexOf(\"pk\") !== -1)\r\n                return cur.key;\r\n            return prev;\r\n        }, \"\");\r\n        var ptr = 0;\r\n        var nextRow = function () {\r\n            t._db.table(t._tableName).query(\"select\").range(1, ptr).exec().then(function (rows) {\r\n                if (rows.length) {\r\n                    lie_ts_1.Promise.all(relations.map(function (r) {\r\n                        return new lie_ts_1.Promise(function (res, rej) {\r\n                            var ids;\r\n                            if (rows[0][r.key] === undefined) {\r\n                                ids = r.type === \"single\" ? \"\" : [];\r\n                            }\r\n                            else {\r\n                                ids = exports._assign(rows[0][r.key]);\r\n                            }\r\n                            if (r.type === \"single\")\r\n                                ids = [ids];\r\n                            ids = ids.filter(function (v, i, s) {\r\n                                return s.indexOf(v) === i;\r\n                            });\r\n                            t._db.table(r.table).query(\"select\").where([r.tablePK, \"IN\", ids]).exec().then(function (childRows) {\r\n                                var activeIDs = childRows.length ? childRows.map(function (row) { return row[r.tablePK]; }) : [];\r\n                                return t._db.table(t._tableName).updateORM(\"set\", r.key, activeIDs).where([tablePK, \"=\", rows[0][tablePK]]).exec();\r\n                            }).then(function () {\r\n                                res();\r\n                            });\r\n                        });\r\n                    })).then(function () {\r\n                        ptr++;\r\n                        nextRow();\r\n                    });\r\n                }\r\n                else {\r\n                    t._db.endTransaction();\r\n                    callBack(ptr);\r\n                }\r\n            });\r\n        };\r\n        nextRow();\r\n    };\r\n    _NanoSQLORMQuery.prototype.exec = function () {\r\n        var t = this;\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            if (t._action === \"rebuild\") {\r\n                return t.rebuild(res);\r\n            }\r\n            var pk = t._db._models[t._tableName].filter(function (m) {\r\n                return m.props && m.props.indexOf(\"pk\") !== -1;\r\n            })[0].key;\r\n            var rowModel = t._db._models[t._tableName].filter(function (m) { return m.key === t._column; })[0];\r\n            var relationTable = rowModel.type.replace(\"[]\", \"\");\r\n            var relationPK = t._db._models[relationTable].filter(function (m) {\r\n                return m.props && m.props.indexOf(\"pk\") !== -1;\r\n            })[0].key;\r\n            var isArrayRelation = rowModel.type.indexOf(\"[]\") !== -1;\r\n            var mapTo = rowModel.props && rowModel.props.filter(function (p) { return p.indexOf(\"orm::\") !== -1; })[0];\r\n            var mapToIsArray = \"single\";\r\n            if (mapTo) {\r\n                mapTo = mapTo.replace(\"orm::\", \"\");\r\n                mapToIsArray = t._db._models[relationTable].filter(function (m) { return m.key === mapTo; })[0].type.indexOf(\"[]\") === -1 ? \"single\" : \"array\";\r\n            }\r\n            if (!pk || !pk.length || !relationPK || !relationPK.length) {\r\n                rej(\"Relation models require a primary key!\");\r\n            }\r\n            var query = t._db.table(t._tableName).query(\"select\");\r\n            if (t._whereArgs)\r\n                query.where(t._whereArgs);\r\n            query.exec().then(function (rows) {\r\n                var ptr = 0;\r\n                var nextRow = function () {\r\n                    if (ptr < rows.length) {\r\n                        var newRow = exports._assign(rows[ptr]);\r\n                        var oldRelations_1 = [];\r\n                        if (newRow[t._column] !== undefined)\r\n                            oldRelations_1 = newRow[t._column];\r\n                        if (!Array.isArray(oldRelations_1))\r\n                            oldRelations_1 = [oldRelations_1];\r\n                        switch (t._action) {\r\n                            case \"set\":\r\n                            case \"add\":\r\n                                if (isArrayRelation) {\r\n                                    if (newRow[t._column] === undefined)\r\n                                        newRow[t._column] = [];\r\n                                    if (!Array.isArray(newRow[t._column]))\r\n                                        newRow[t._column] = [];\r\n                                    if (t._action === \"set\") {\r\n                                        newRow[t._column] = t._relationIDs;\r\n                                    }\r\n                                    else {\r\n                                        newRow[t._column] = newRow[t._column].concat(t._relationIDs);\r\n                                        newRow[t._column] = newRow[t._column].filter(function (v, i, s) {\r\n                                            return s.indexOf(v) === i;\r\n                                        });\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    newRow[t._column] = t._relationIDs[0];\r\n                                }\r\n                                break;\r\n                            case \"delete\":\r\n                                if (isArrayRelation) {\r\n                                    var loc = newRow[t._column].indexOf(rows[ptr][pk]);\r\n                                    if (loc !== -1)\r\n                                        newRow[t._column] = newRow[t._column].splice(loc, 1);\r\n                                }\r\n                                else {\r\n                                    newRow[t._column] = \"\";\r\n                                }\r\n                                break;\r\n                            case \"drop\":\r\n                                newRow[t._column] = isArrayRelation ? [] : undefined;\r\n                                break;\r\n                        }\r\n                        var updateRow_1 = function (newRow, callBack) {\r\n                            t._db.table(relationTable).query(\"upsert\", newRow, true).exec().then(callBack);\r\n                        };\r\n                        var removeOldRelations_1 = function () {\r\n                            return lie_ts_1.Promise.all(oldRelations_1.map(function (id) {\r\n                                return new lie_ts_1.Promise(function (resolve, reject) {\r\n                                    t._db.table(relationTable).query(\"select\").where([relationPK, \"=\", id]).exec().then(function (relateRows) {\r\n                                        if (!relateRows.length) {\r\n                                            resolve();\r\n                                            return;\r\n                                        }\r\n                                        var modifyRow = exports._assign(relateRows[0]);\r\n                                        if (Array.isArray(modifyRow[mapTo])) {\r\n                                            var idx = modifyRow[mapTo].indexOf(rows[ptr][pk]);\r\n                                            if (idx !== -1) {\r\n                                                modifyRow[mapTo] = modifyRow[mapTo].splice(idx, 1);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            modifyRow[mapTo] = \"\";\r\n                                        }\r\n                                        updateRow_1(modifyRow, resolve);\r\n                                    });\r\n                                });\r\n                            }));\r\n                        };\r\n                        t._db.table(t._tableName).query(\"upsert\", newRow, true).exec().then(function () {\r\n                            if (mapTo) {\r\n                                switch (t._action) {\r\n                                    case \"set\":\r\n                                    case \"add\":\r\n                                        var ptr2_1 = 0;\r\n                                        var appendRelations_1 = function () {\r\n                                            if (ptr2_1 < t._relationIDs.length) {\r\n                                                t._db.table(relationTable).query(\"select\").where([relationPK, \"=\", t._relationIDs[ptr2_1]]).exec().then(function (relateRows) {\r\n                                                    if (!relateRows.length) {\r\n                                                        ptr2_1++;\r\n                                                        appendRelations_1();\r\n                                                        return;\r\n                                                    }\r\n                                                    var modifyRow = exports._assign(relateRows[0]);\r\n                                                    if (modifyRow[mapTo] === undefined)\r\n                                                        modifyRow[mapTo] = mapToIsArray === \"array\" ? [] : \"\";\r\n                                                    if (mapToIsArray === \"array\") {\r\n                                                        if (!Array.isArray(modifyRow[mapTo]))\r\n                                                            modifyRow[mapTo] = [];\r\n                                                        modifyRow[mapTo].push(rows[ptr][pk]);\r\n                                                        modifyRow[mapTo] = modifyRow[mapTo].filter(function (v, i, s) {\r\n                                                            return s.indexOf(v) === i;\r\n                                                        });\r\n                                                        updateRow_1(modifyRow, function () {\r\n                                                            ptr2_1++;\r\n                                                            appendRelations_1();\r\n                                                        });\r\n                                                    }\r\n                                                    else {\r\n                                                        if (modifyRow[mapTo] && modifyRow[mapTo].length) {\r\n                                                            t._db.table(t._tableName).query(\"select\").where([pk, \"=\", modifyRow[mapTo]]).exec().then(function (relateRows2) {\r\n                                                                var modifyRow2 = exports._assign(relateRows2[0]);\r\n                                                                if (Array.isArray(modifyRow2[t._column])) {\r\n                                                                    var idx = modifyRow2[t._column].indexOf(modifyRow[mapTo]);\r\n                                                                    if (idx === -1) {\r\n                                                                        modifyRow2[t._column] = modifyRow2[t._column].splice(modifyRow2[t._column].indexOf(modifyRow[mapTo]), 1);\r\n                                                                    }\r\n                                                                }\r\n                                                                else {\r\n                                                                    modifyRow2[t._column] = \"\";\r\n                                                                }\r\n                                                                t._db.table(t._tableName).query(\"upsert\", modifyRow2, true).where([pk, \"=\", modifyRow[mapTo]]).exec().then(function () {\r\n                                                                    modifyRow[mapTo] = rows[ptr][pk];\r\n                                                                    updateRow_1(modifyRow, function () {\r\n                                                                        ptr2_1++;\r\n                                                                        appendRelations_1();\r\n                                                                    });\r\n                                                                });\r\n                                                            });\r\n                                                        }\r\n                                                        else {\r\n                                                            modifyRow[mapTo] = rows[ptr][pk];\r\n                                                            updateRow_1(modifyRow, function () {\r\n                                                                ptr2_1++;\r\n                                                                appendRelations_1();\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                            else {\r\n                                                ptr++;\r\n                                                nextRow();\r\n                                            }\r\n                                        };\r\n                                        appendRelations_1();\r\n                                        break;\r\n                                    case \"delete\":\r\n                                    case \"drop\":\r\n                                        removeOldRelations_1().then(function () {\r\n                                            ptr++;\r\n                                            nextRow();\r\n                                        });\r\n                                        break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                ptr++;\r\n                                nextRow();\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        res(ptr);\r\n                    }\r\n                };\r\n                nextRow();\r\n            });\r\n        });\r\n    };\r\n    return _NanoSQLORMQuery;\r\n}());\r\nexports._NanoSQLORMQuery = _NanoSQLORMQuery;\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(table, db, actionOrView) {\r\n        this._db = db;\r\n        this._modifiers = [];\r\n        this._table = table;\r\n        this._AV = actionOrView || \"\";\r\n    }\r\n    _NanoSQLQuery.prototype.where = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Where condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"where\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.range = function (limit, offset) {\r\n        return this._addCmd(\"range\", [limit, offset]);\r\n    };\r\n    _NanoSQLQuery.prototype.orm = function (ormArgs) {\r\n        return this._addCmd(\"orm\", ormArgs);\r\n    };\r\n    _NanoSQLQuery.prototype.orderBy = function (args) {\r\n        return this._addCmd(\"orderby\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.groupBy = function (columns) {\r\n        return this._addCmd(\"groupby\", columns);\r\n    };\r\n    _NanoSQLQuery.prototype.having = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Having condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"having\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.join = function (args) {\r\n        if (!args.table || !args.type) {\r\n            this._error = \"Join command requires table and type arguments!\";\r\n        }\r\n        return this._addCmd(\"join\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.limit = function (args) {\r\n        return this._addCmd(\"limit\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.trieSearch = function (column, stringToSearch) {\r\n        return this._addCmd(\"trie\", [column, stringToSearch]);\r\n    };\r\n    _NanoSQLQuery.prototype.offset = function (args) {\r\n        return this._addCmd(\"offset\", args);\r\n    };\r\n    _NanoSQLQuery.prototype._addCmd = function (type, args) {\r\n        return this._modifiers.push({ type: type, args: args }), this;\r\n    };\r\n    _NanoSQLQuery.prototype.toCSV = function (headers) {\r\n        var t = this;\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.exec().then(function (json) {\r\n                json = exports._assign(json);\r\n                var header = t._action.args.length ? t._action.args.map(function (m) {\r\n                    return t._db._models[t._table].filter(function (f) { return f[\"key\"] === m; })[0];\r\n                }) : t._db._models[t._table];\r\n                if (headers) {\r\n                    json.unshift(header.map(function (h) {\r\n                        return h[\"key\"];\r\n                    }));\r\n                }\r\n                res(json.map(function (row, i) {\r\n                    if (headers && i === 0)\r\n                        return row;\r\n                    return header.filter(function (column) {\r\n                        return row[column[\"key\"]] ? true : false;\r\n                    }).map(function (column) {\r\n                        var columnType = column[\"type\"];\r\n                        if (columnType.indexOf(\"[]\") !== -1)\r\n                            columnType = \"any[]\";\r\n                        switch (columnType) {\r\n                            case \"map\":\r\n                            case \"any[]\":\r\n                            case \"array\": return '\"' + JSON.stringify(row[column[\"key\"]]).replace(/\"/g, \"'\") + '\"';\r\n                            case \"string\":\r\n                            case \"safestr\": return '\"' + row[column[\"key\"]].replace(/\"/g, '\\\"') + '\"';\r\n                            default: return row[column[\"key\"]];\r\n                        }\r\n                    }).join(\",\");\r\n                }).join(\"\\n\"), t);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype.exec = function () {\r\n        var t = this;\r\n        var _t = t._table;\r\n        if (t._db._hasEvents[_t]) {\r\n            t._db._triggerEvents = (function () {\r\n                switch (t._action.type) {\r\n                    case \"select\": return [t._action.type];\r\n                    case \"delete\":\r\n                    case \"upsert\":\r\n                    case \"drop\": return [t._action.type, \"change\"];\r\n                    default: return [];\r\n                }\r\n            })();\r\n        }\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            if (t._error) {\r\n                rej(t._error);\r\n                throw Error;\r\n            }\r\n            if (!t._db.backend) {\r\n                rej();\r\n                throw Error;\r\n            }\r\n            var _tEvent = function (data, callBack, type, changedRows, isError) {\r\n                if (t._db._hasEvents[_t]) {\r\n                    t._db.triggerEvent({\r\n                        name: \"error\",\r\n                        actionOrView: t._AV,\r\n                        table: _t,\r\n                        query: [t._action].concat(t._modifiers),\r\n                        time: new Date().getTime(),\r\n                        result: data,\r\n                        changeType: type,\r\n                        changedRows: changedRows\r\n                    }, t._db._triggerEvents);\r\n                }\r\n                callBack(data, t._db);\r\n            };\r\n            var execArgs = {\r\n                table: _t,\r\n                query: [t._action].concat(t._modifiers),\r\n                viewOrAction: t._AV,\r\n                onSuccess: function (rows, type, affectedRows) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(rows, t._db);\r\n                    }\r\n                    else {\r\n                        _tEvent(rows, res, type, affectedRows, false);\r\n                    }\r\n                },\r\n                onFail: function (err) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(err, t._db);\r\n                    }\r\n                    else {\r\n                        t._db._triggerEvents = [\"error\"];\r\n                        if (rej)\r\n                            _tEvent(err, rej, \"error\", [], true);\r\n                    }\r\n                }\r\n            };\r\n            if (t._db._queryMod) {\r\n                t._db._queryMod(execArgs, function (newArgs) {\r\n                    t._db.backend._exec(newArgs);\r\n                });\r\n            }\r\n            else {\r\n                t._db.backend._exec(execArgs);\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\nvar _NanoSQLStatic = new NanoSQLInstance();\r\nexports.nSQL = function (setTablePointer) {\r\n    return _NanoSQLStatic.table(setTablePointer);\r\n};\r\n",
dependencies: ["./db-index","lie-ts"],
sourceMap: {},
headerContent: undefined,
mtime: 1494723309821
};