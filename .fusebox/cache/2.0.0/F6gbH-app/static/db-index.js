module.exports = { contents: "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nvar db_storage_1 = require(\"./db-storage\");\r\nvar db_query_1 = require(\"./db-query\");\r\nexports._str = function (index) {\r\n    return [\"_utility\", \"_historyPoints\", \"_pointer\", \"_historyDataRowIDs\", \"_id\"][index];\r\n};\r\nvar _NanoSQLDB = (function () {\r\n    function _NanoSQLDB() {\r\n        var t = this;\r\n        t._pendingQuerys = [];\r\n        t._queryCache = {};\r\n    }\r\n    _NanoSQLDB.prototype._connect = function (connectArgs) {\r\n        var t = this;\r\n        t._databaseID = index_1.NanoSQLInstance._hash(JSON.stringify(connectArgs._models)).toString();\r\n        t._parent = connectArgs._parent;\r\n        t._store = new db_storage_1._NanoSQL_Storage(t, connectArgs);\r\n    };\r\n    _NanoSQLDB.prototype._exec = function (execArgs) {\r\n        var t = this;\r\n        new db_query_1._NanoSQLQuery(t)._doQuery(execArgs);\r\n    };\r\n    _NanoSQLDB.prototype._invalidateCache = function (changedTableID, changedRows, type, action) {\r\n        var t = this;\r\n        t._queryCache[changedTableID] = {};\r\n        if (changedRows.length && action) {\r\n            t._parent.triggerEvent({\r\n                name: \"change\",\r\n                actionOrView: \"\",\r\n                table: t._store._tables[changedTableID]._name,\r\n                query: [],\r\n                time: new Date().getTime(),\r\n                result: [{ msg: action + \" was performed.\", type: action }],\r\n                changedRows: changedRows,\r\n                changeType: type\r\n            }, [\"change\"]);\r\n        }\r\n    };\r\n    _NanoSQLDB.prototype._deepFreeze = function (obj, tableID) {\r\n        if (!obj)\r\n            return obj;\r\n        var t = this;\r\n        if (tableID) {\r\n            t._store._models[tableID].forEach(function (model) {\r\n                var prop = obj[model.key];\r\n                if ([\"map\", \"array\"].indexOf(model.type) >= 0 || model.type.indexOf(\"[]\") >= 0) {\r\n                    obj[model.key] = t._deepFreeze(prop);\r\n                }\r\n            });\r\n        }\r\n        return Object.freeze(obj);\r\n    };\r\n    _NanoSQLDB.prototype._transaction = function (type) {\r\n        var t = this;\r\n        if (type === \"start\") {\r\n            t._store._transactionData = {};\r\n            t._store._doingTransaction = true;\r\n        }\r\n        if (type === \"end\") {\r\n            t._store._doingTransaction = false;\r\n            t._store._execTransaction();\r\n            setTimeout(function () {\r\n                t._parent._tableNames.forEach(function (tableName) {\r\n                    t._invalidateCache(index_1.NanoSQLInstance._hash(tableName), [], \"transaction\");\r\n                });\r\n            }, 0);\r\n        }\r\n        return !!t._store._doingTransaction;\r\n    };\r\n    _NanoSQLDB.prototype._extend = function (db, command) {\r\n        var t = this;\r\n        var i;\r\n        var h;\r\n        var j;\r\n        var rowID;\r\n        var rowData;\r\n        var rowKey;\r\n        var store;\r\n        var shiftRowIDs = function (direction, callBack) {\r\n            var results = {};\r\n            var check = (t._store._historyLength - t._store._historyPoint);\r\n            t._store._readArray(exports._str(1), t._store._historyPointIndex[check], function (hps) {\r\n                new _fnForEach().loop(hps, function (hp, nextPoint) {\r\n                    var tableID = hp.tableID;\r\n                    var table = t._store._tables[tableID];\r\n                    var rows = [];\r\n                    new _fnForEach().loop(hp.rowKeys, function (rowID, nextRow) {\r\n                        if (table._pkType === \"int\")\r\n                            rowID = parseInt(rowID);\r\n                        t._store._read(table._name, rowID, function (rowData) {\r\n                            if (direction > 0)\r\n                                rows.push(rowData[0]);\r\n                            t._store._read(\"_\" + table._name + \"_hist__meta\", rowID, function (row) {\r\n                                row = index_1._assign(row);\r\n                                row[0][exports._str(2)] = (row[0][exports._str(2)] || 0) + direction;\r\n                                var historyRowID = row[0][exports._str(3)][row[0][exports._str(2)]];\r\n                                t._store._upsert(\"_\" + table._name + \"_hist__meta\", rowID, row[0], function () {\r\n                                    t._store._read(\"_\" + table._name + \"_hist__data\", historyRowID, function (setRow) {\r\n                                        var newRow = setRow[0] ? index_1._assign(setRow[0]) : null;\r\n                                        t._store._upsert(table._name, rowID, newRow, function () {\r\n                                            if (direction < 0)\r\n                                                rows.push(newRow);\r\n                                            if (!results[tableID])\r\n                                                results[tableID] = { type: hp.type, rows: [] };\r\n                                            results[tableID].rows = results[tableID].rows.concat(rows);\r\n                                            i++;\r\n                                            nextRow();\r\n                                        });\r\n                                    });\r\n                                });\r\n                            });\r\n                        });\r\n                    }).then(nextPoint);\r\n                }).then(function () {\r\n                    callBack(results);\r\n                });\r\n            });\r\n        };\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            switch (command) {\r\n                case \"<\":\r\n                    if (!t._store._historyLength || t._store._historyPoint === t._store._historyLength) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        shiftRowIDs(1, function (affectedTables) {\r\n                            t._store._historyPoint++;\r\n                            t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                var description = affectedTables[tableID].type;\r\n                                switch (description) {\r\n                                    case \"inserted\":\r\n                                        description = \"deleted\";\r\n                                        break;\r\n                                    case \"deleted\":\r\n                                        description = \"inserted\";\r\n                                        break;\r\n                                }\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, description, \"undo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \">\":\r\n                    if (!t._store._historyLength || t._store._historyPoint < 1) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        t._store._historyPoint--;\r\n                        t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                        shiftRowIDs(-1, function (affectedTables) {\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, affectedTables[tableID].type, \"redo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \"?\":\r\n                    h = [t._store._historyLength, t._store._historyLength - t._store._historyPoint];\r\n                    if (t._store._historyArray.join(\"+\") !== h.join(\"+\")) {\r\n                        t._store._historyArray = h;\r\n                    }\r\n                    res(t._store._historyArray);\r\n                    break;\r\n                case \"flush_history\":\r\n                case \"flush_db\":\r\n                    t._store._utility(\"w\", \"historyPoint\", 0);\r\n                    t._store._utility(\"w\", \"historyLength\", 0);\r\n                    t._store._historyPoint = 0;\r\n                    t._store._historyLength = 0;\r\n                    Object.keys(t._store._tables).forEach(function (tableID) {\r\n                        var rows;\r\n                        if (t._store._tables[parseInt(tableID)]._name.indexOf(\"_\") === 0) {\r\n                            rows = [];\r\n                        }\r\n                        else {\r\n                            rows = t._store._tables[parseInt(tableID)]._rows;\r\n                            rows = Object.keys(rows).map(function (r) { return rows[r]; });\r\n                        }\r\n                        t._invalidateCache(parseInt(tableID), rows, \"remove\", \"clear\");\r\n                    });\r\n                    if (command === \"flush_db\") {\r\n                        t._store._clear(\"all\", res);\r\n                    }\r\n                    else {\r\n                        t._store._clear(\"hist\", res);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLDB;\r\n}());\r\nexports._NanoSQLDB = _NanoSQLDB;\r\nvar _fnForEach = (function () {\r\n    function _fnForEach() {\r\n    }\r\n    _fnForEach.prototype.loop = function (items, callBack) {\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            var ptr = 0;\r\n            var results = [];\r\n            var next = function () {\r\n                if (ptr < items.length) {\r\n                    callBack(items[ptr], function (result) {\r\n                        results.push(result);\r\n                        ptr++;\r\n                        next();\r\n                    });\r\n                }\r\n                else {\r\n                    res(results);\r\n                }\r\n            };\r\n            next();\r\n        });\r\n    };\r\n    return _fnForEach;\r\n}());\r\nexports._fnForEach = _fnForEach;\r\n",
dependencies: ["./index","lie-ts","./db-storage","./db-query"],
sourceMap: {},
headerContent: undefined,
mtime: 1494657098725
};