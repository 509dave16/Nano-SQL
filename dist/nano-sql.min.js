(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var db_index_1 = __webpack_require__(2);
var lie_ts_1 = __webpack_require__(1);
var index_query_1 = __webpack_require__(7);
var index_transaction_1 = __webpack_require__(8);
exports._assign = function (obj) {
    return JSON.parse(JSON.stringify(obj));
};
var NanoSQLInstance = (function () {
    function NanoSQLInstance() {
        var t = this;
        t._actions = {};
        t._views = {};
        t._models = {};
        t._preConnectExtend = [];
        t._transactionTables = [];
        t._events = ["*", "change", "delete", "upsert", "drop", "select", "error"];
        t._callbacks = {};
        t._ormFns = {};
        t._hasEvents = {};
        t._callbacks["*"] = {};
        t._tableNames = [];
        var i = t._events.length;
        while (i--) {
            t._callbacks["*"][t._events[i]] = [];
        }
        t._functions = {};
        t._rowFilters = {};
    }
    NanoSQLInstance.prototype.table = function (table) {
        if (table)
            this.sTable = table;
        return this;
    };
    NanoSQLInstance.prototype.connect = function (backend) {
        var _this = this;
        var t = this;
        if (t.backend) {
            return new lie_ts_1.Promise(function (res, rej) {
                rej();
                throw Error();
            });
        }
        t.backend = backend || new db_index_1._NanoSQLDB();
        return new lie_ts_1.Promise(function (res, rej) {
            t.backend._connect({
                _models: t._models,
                _actions: t._actions,
                _views: t._views,
                _functions: t._functions,
                _config: t._preConnectExtend,
                _parent: _this,
                _onSuccess: function (result) {
                    res(result, t);
                },
                _onFail: function (rejected) {
                    if (rej)
                        rej(rejected, t);
                }
            });
        });
    };
    NanoSQLInstance.prototype.on = function (actions, callBack) {
        var t = this;
        var l = t.sTable;
        var i = t._events.length;
        var a = actions.split(" ");
        if (!t._callbacks[l]) {
            t._callbacks[l] = {};
            t._callbacks[l]["*"] = [];
            while (i--) {
                t._callbacks[l][t._events[i]] = [];
            }
        }
        i = a.length;
        while (i--) {
            if (t._events.indexOf(a[i]) !== -1) {
                t._callbacks[l][a[i]].push(callBack);
            }
        }
        t._refreshEventChecker();
        return t;
    };
    NanoSQLInstance.prototype.off = function (callBack) {
        var t = this;
        for (var key in t._callbacks) {
            for (var key2 in t._callbacks[key]) {
                t._callbacks[key][key2] = t._callbacks[key][key2].filter(function (cBs) {
                    return cBs !== callBack;
                });
            }
        }
        t._refreshEventChecker();
        return t;
    };
    NanoSQLInstance.prototype._refreshEventChecker = function () {
        var _this = this;
        this._hasEvents = {};
        Object.keys(this._models).concat(["*"]).forEach(function (table) {
            _this._hasEvents[table] = _this._events.reduce(function (prev, cur) {
                return prev + (_this._callbacks[table] ? _this._callbacks[table][cur].length : 0);
            }, 0) > 0;
        });
    };
    NanoSQLInstance.prototype.model = function (dataModel) {
        var t = this;
        var l = t.sTable;
        var i = t._events.length;
        if (!t._callbacks[l]) {
            t._callbacks[l] = {};
            t._callbacks[l]["*"] = [];
            while (i--) {
                t._callbacks[l][t._events[i]] = [];
            }
        }
        t._models[l] = dataModel;
        t._tableNames.push(l);
        t._views[l] = [];
        t._actions[l] = [];
        return t;
    };
    NanoSQLInstance.prototype.views = function (viewArray) {
        return this._views[this.sTable] = viewArray, this;
    };
    NanoSQLInstance.prototype.getView = function (viewName, viewArgs) {
        if (viewArgs === void 0) { viewArgs = {}; }
        return this._doAV("View", this._views[this.sTable], viewName, viewArgs);
    };
    NanoSQLInstance.prototype.cleanArgs = function (argDeclarations, args) {
        var t = this;
        var l = t.sTable;
        var a = {};
        var i = argDeclarations.length ? argDeclarations.length : -1;
        if (i > 0) {
            while (i--) {
                var k2 = argDeclarations[i].split(":");
                if (k2.length > 1) {
                    a[k2[0]] = t._cast(k2[1], args[k2[0]] || null);
                }
                else {
                    a[k2[0]] = args[k2[0]] || null;
                }
            }
        }
        return a;
    };
    NanoSQLInstance.prototype._cast = function (type, val) {
        var _this = this;
        var p = this;
        var entityMap = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "\"": "&quot;",
            "'": "&#39;",
            "/": "&#x2F;",
            "`": "&#x60;",
            "=": "&#x3D;"
        };
        var t = typeof val;
        if (t === "undefined" || val === null) {
            return val;
        }
        var types = function (type, val) {
            switch (type) {
                case "safestr": return types("string", val).replace(/[&<>"'`=\/]/g, function (s) { return entityMap[s]; });
                case "int": return (t !== "number" || val % 1 !== 0) ? parseInt(val || 0) : val;
                case "float": return t !== "number" ? parseFloat(val || 0) : val;
                case "any[]":
                case "array": return Array.isArray(val) ? exports._assign(val || []) : [];
                case "uuid":
                case "timeId":
                case "timeIdms":
                case "string": return val === null ? "" : t !== "string" ? String(val) : val;
                case "map": return t === "object" ? exports._assign(val || {}) : {};
                case "bool": return val === true;
            }
            return val;
        };
        var newVal = types(type, val);
        if (type.indexOf("[]") !== -1) {
            var arrayOf_1 = type.slice(0, type.lastIndexOf("[]"));
            return (val || []).map(function (v) {
                return _this._cast(arrayOf_1, v);
            });
        }
        else if (newVal !== undefined) {
            if (["int", "float"].indexOf(type) !== -1) {
                return isNaN(newVal) ? 0 : newVal;
            }
            else {
                return newVal;
            }
        }
        return undefined;
    };
    NanoSQLInstance.prototype.actions = function (actionArray) {
        return this._actions[this.sTable] = actionArray, this;
    };
    NanoSQLInstance.prototype.doAction = function (actionName, actionArgs) {
        return this._doAV("Action", this._actions[this.sTable], actionName, actionArgs);
    };
    NanoSQLInstance.prototype._doAV = function (AVType, AVList, AVName, AVargs) {
        var _this = this;
        var t = this;
        var selAV = AVList.reduce(function (prev, cur) {
            if (cur.name === AVName)
                return cur;
            return prev;
        }, null);
        if (!selAV) {
            return new lie_ts_1.Promise(function (res, rej) { return rej("Action/View Not Found!"); });
        }
        t._activeAV = AVName;
        var cleanArgs = selAV.args ? t.cleanArgs(selAV.args, AVargs) : {};
        if (t._AVMod) {
            return new lie_ts_1.Promise(function (res, rej) {
                t._AVMod(_this.sTable, AVType, t._activeAV || "", cleanArgs, function (args) {
                    selAV ? selAV.call(args, t).then(function (result) {
                        res(result, t);
                    }) : false;
                }, function (err) {
                    rej(err);
                });
            });
        }
        else {
            return selAV.call(cleanArgs, t);
        }
    };
    NanoSQLInstance.prototype.newFunction = function (functionName, functionType, filterFunction) {
        return this._functions[functionName] = { type: functionType, call: filterFunction }, this;
    };
    NanoSQLInstance.prototype.query = function (action, args, bypassORMPurge) {
        var t = this;
        var query = new index_query_1._NanoSQLQuery(t.sTable, t, t._activeAV);
        t._activeAV = undefined;
        var a = action.toLowerCase();
        if (["select", "upsert", "delete", "drop", "show tables", "describe"].indexOf(a) !== -1) {
            var newArgs_1 = args || (a === "select" || a === "delete" ? [] : {});
            if (["upsert", "delete", "drop"].indexOf(a) !== -1) {
                t._transactionTables.push(t.sTable);
            }
            if (action === "delete" && !bypassORMPurge) {
                var inputArgs = {};
                t._models[t.sTable].forEach(function (model) {
                    if (t._tableNames.indexOf(model.type.replace("[]", "")) !== -1) {
                        newArgs_1[model.key] = undefined;
                    }
                });
                newArgs_1 = inputArgs;
            }
            if (action === "upsert") {
                var inputArgs_1 = {};
                t._models[t.sTable].forEach(function (model) {
                    if (!bypassORMPurge) {
                        if (t._tableNames.indexOf(model.type.replace("[]", "")) !== -1) {
                            newArgs_1[model.key] = undefined;
                        }
                    }
                    if (newArgs_1[model.key] !== undefined) {
                        var cast = t._cast(model.type, newArgs_1[model.key]);
                        if (cast !== undefined)
                            inputArgs_1[model.key] = cast;
                    }
                });
                if (t._rowFilters[t.sTable]) {
                    inputArgs_1 = t._rowFilters[t.sTable](inputArgs_1);
                }
                newArgs_1 = inputArgs_1;
            }
            query._action = { type: a, args: newArgs_1 };
        }
        else {
            throw Error;
        }
        return query;
    };
    NanoSQLInstance.prototype.updateORM = function (action, column, relationIDs) {
        return new index_query_1._NanoSQLORMQuery(this, this.sTable, action, column, relationIDs);
    };
    NanoSQLInstance.prototype.defaultORM = function (callBack) {
        this._ormFns[this.sTable] = callBack;
        return this;
    };
    NanoSQLInstance.prototype.triggerEvent = function (eventData, triggerEvents) {
        var t = this;
        setTimeout(function () {
            var i = triggerEvents.length;
            var j = 0;
            var e;
            var c;
            while (i--) {
                e = triggerEvents[i];
                c = t._callbacks[eventData.table][e].concat(t._callbacks[eventData.table]["*"]);
                j = c.length;
                while (j--) {
                    eventData.name = e;
                    if (c[j])
                        c[j](eventData, t);
                }
            }
        }, 0);
    };
    NanoSQLInstance.prototype.default = function (replaceObj) {
        var newObj = {};
        var t = this;
        t._models[t.sTable].forEach(function (m) {
            newObj[m.key] = (replaceObj && replaceObj[m.key]) ? replaceObj[m.key] : m.default;
            if (!newObj[m.key]) {
                newObj[m.key] = t._cast(m.type, null);
            }
        });
        return newObj;
    };
    NanoSQLInstance.prototype.doTransaction = function (initTransaction) {
        var t = this;
        var queries = [];
        var transactionID = NanoSQLInstance.random16Bits();
        return new lie_ts_1.Promise(function (resolve, reject) {
            t.backend._transaction("start", transactionID).then(function () {
                initTransaction(function (table) {
                    var ta = table || t.sTable;
                    return {
                        query: function (action, args) {
                            return new index_transaction_1._NanoSQLTransactionQuery(action, args, ta, queries);
                        },
                        updateORM: function (action, column, relationIDs) {
                            if (action === "rebuild") {
                                return undefined;
                            }
                            else {
                                return new index_transaction_1._NanoSQLTransactionORMQuery(queries, ta, action, column, relationIDs);
                            }
                        }
                    };
                }, function () {
                    NanoSQLInstance.chain(queries.map(function (quer) {
                        return function (nextQuery) {
                            if (quer.type === "std") {
                                t.table(quer.table).query(quer.action, quer.actionArgs, true).tID(transactionID).manualExec(quer.table, quer.query || []).then(nextQuery);
                            }
                            else {
                                var ormQuery = t.table(quer.table).updateORM(quer.action, quer.column, quer.relationIDs).tID(transactionID);
                                var where = quer.where;
                                if (where)
                                    ormQuery.where(where);
                                ormQuery.exec().then(nextQuery);
                            }
                        };
                    }))(function () {
                        t.backend._transaction("end", transactionID).then(function (result) {
                            t._transactionTables.forEach(function (table) {
                                if (table.indexOf("_") !== 0) {
                                    t.triggerEvent({
                                        table: table,
                                        query: [],
                                        time: new Date().getTime(),
                                        result: [],
                                        name: "change",
                                        actionOrView: "",
                                        changeType: "transaction",
                                        changedRows: [],
                                        changedRowPKS: []
                                    }, ["change"]);
                                }
                            });
                            resolve(result);
                        });
                    });
                });
            });
        });
    };
    NanoSQLInstance.prototype.queryFilter = function (callBack) {
        this._queryMod = callBack;
        return this;
    };
    NanoSQLInstance.prototype.avFilter = function (filterFunc) {
        this._AVMod = filterFunc;
        return this;
    };
    NanoSQLInstance.prototype.config = function (args) {
        var t = this;
        if (!t.backend)
            t._preConnectExtend.push(args);
        return t;
    };
    NanoSQLInstance.prototype.extend = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var t = this;
        if (t.backend) {
            if (t.backend._extend) {
                args.unshift(t);
                return t.backend._extend.apply(t.backend, args);
            }
            else {
                return undefined;
            }
        }
    };
    NanoSQLInstance.prototype.loadJS = function (table, rows, useTransaction) {
        if (useTransaction === void 0) { useTransaction = true; }
        var t = this;
        if (useTransaction) {
            return t.doTransaction(function (db, complete) {
                rows.forEach(function (row) {
                    db(table).query("upsert", row).exec();
                });
                complete();
            });
        }
        else {
            return new lie_ts_1.Promise(function (res, rej) {
                NanoSQLInstance.chain(rows.map(function (row) {
                    return function (nextRow) {
                        exports.nSQL(table).query("upsert", row).exec().then(nextRow);
                    };
                }))(function (rows) {
                    res(rows.map(function (r) { return r.shift(); }));
                });
            });
        }
    };
    NanoSQLInstance.prototype.rowFilter = function (callBack) {
        return this._rowFilters[this.sTable] = callBack, this;
    };
    NanoSQLInstance.prototype.loadCSV = function (table, csv, useTransaction) {
        if (useTransaction === void 0) { useTransaction = true; }
        var t = this;
        var fields = [];
        var rowData = csv.split("\n").map(function (v, k) {
            if (k === 0) {
                fields = v.split(",");
                return undefined;
            }
            else {
                var record = {};
                var row = v.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
                var i = fields.length;
                while (i--) {
                    if (row[i].indexOf("{") === 1 || row[i].indexOf("[") === 1) {
                        row[i] = JSON.parse(row[i].slice(1, row[i].length - 1).replace(/'/gm, '\"'));
                    }
                    else if (row[i].indexOf('"') === 0) {
                        row[i] = row[i].slice(1, row[i].length - 1);
                    }
                    record[fields[i]] = row[i];
                }
                return record;
            }
        }).filter(function (r) { return r; });
        if (useTransaction) {
            return t.doTransaction(function (db, complete) {
                rowData.forEach(function (row) {
                    db(table).query("upsert", row).exec();
                });
                complete();
            });
        }
        else {
            return new lie_ts_1.Promise(function (res, rej) {
                NanoSQLInstance.chain(rowData.map(function (row) {
                    return function (nextRow) {
                        exports.nSQL(table).query("upsert", row).exec().then(nextRow);
                    };
                }))(function (rows) {
                    res(rows.map(function (r) { return r.shift(); }));
                });
            });
        }
    };
    NanoSQLInstance.random16Bits = function () {
        if (typeof crypto === "undefined") {
            return Math.round(Math.random() * Math.pow(2, 16));
        }
        else {
            if (crypto.getRandomValues) {
                var buf = new Uint16Array(1);
                crypto.getRandomValues(buf);
                return buf[0];
            }
            else if (global !== "undefined" && global._crypto.randomBytes) {
                return global._crypto.randomBytes(2).reduce(function (prev, cur) { return cur * prev; });
            }
            else {
                return Math.round(Math.random() * Math.pow(2, 16));
            }
        }
    };
    NanoSQLInstance.chain = function (callbacks) {
        return function (complete) {
            var results = [];
            var ptr = 0;
            if (!callbacks.length) {
                complete([]);
            }
            var next = function () {
                if (ptr < callbacks.length) {
                    callbacks[ptr](function (result) {
                        results.push(result);
                        ptr++;
                        lie_ts_1.setFast(next);
                    });
                }
                else {
                    complete(results);
                }
            };
            next();
        };
    };
    NanoSQLInstance.timeid = function (ms) {
        var t = this;
        if (!t._tzOffset) {
            t._tzOffset = new Date().getTimezoneOffset() * 60000;
        }
        var time = Math.round((new Date().getTime() + t._tzOffset) / (ms ? 1 : 1000)).toString();
        while (time.length < (ms ? 13 : 10)) {
            time = "0" + time;
        }
        return time + "-" + (t.random16Bits() + t.random16Bits()).toString(16);
    };
    NanoSQLInstance.uuid = function () {
        var _this = this;
        var r, s, b = "";
        return [b, b, b, b, b, b, b, b, b].reduce(function (prev, cur, i) {
            r = _this.random16Bits();
            s = (i === 4 ? i : (i === 5 ? (r % 16 & 0x3 | 0x8).toString(16) : b));
            r = r.toString(16);
            while (r.length < 4)
                r = "0" + r;
            return prev + ([3, 4, 5, 6].indexOf(i) >= 0 ? "-" : b) + (s + r).slice(0, 4);
        }, b);
    };
    NanoSQLInstance._hash = function (key) {
        return Math.abs(key.split("").reduce(function (prev, next, i) {
            return ((prev << 5) + prev) + key.charCodeAt(i);
        }, 0));
    };
    return NanoSQLInstance;
}());
exports.NanoSQLInstance = NanoSQLInstance;
var _NanoSQLStatic = new NanoSQLInstance();
exports.nSQL = function (setTablePointer) {
    return _NanoSQLStatic.table(setTablePointer);
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// stolen from https://github.com/Octane/setImmediate
// convertd to NodeJS friendly syntax
var uid = 0;
var storage = {};
var firstCall = true;
var slice = Array.prototype.slice;
var message = 'setIlMessage';
var fastApply = function (args) {
    var func = args[0];
    switch (args.length) {
        case 1:
            return func();
        case 2:
            return func(args[1]);
        case 3:
            return func(args[1], args[2]);
    }
    return func.apply(window, slice.call(args, 1));
};
var callback = function (event) {
    var key = event.data;
    var data;
    if (typeof key == 'string' && key.indexOf(message) == 0) {
        data = storage[key];
        if (data) {
            delete storage[key];
            fastApply(data);
        }
    }
};
var setImmediatePolyfill = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var id = uid++;
    var key = message + id;
    storage[key] = args;
    if (firstCall) {
        firstCall = false;
        window.addEventListener('message', callback);
    }
    window.postMessage(key, '*');
    return id;
};
exports.setFast = (typeof process === "undefined" || typeof process.platform === "undefined") ? setImmediatePolyfill : setImmediate;
var _INTERNAL = function () { };
var _REJECTED = ['R'];
var _FULFILLED = ['F'];
var _PENDING = ['P'];
var Promise = (function () {
    function Promise(resolver) {
        this._state = _PENDING;
        this._queue = [];
        this._outcome = void 0;
        if (resolver !== _INTERNAL) {
            _safelyResolveThenable(this, resolver);
        }
    }
    Promise.prototype.catch = function (onRejected) {
        return this.then(function () { }, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this._state === _FULFILLED ||
            typeof onRejected !== 'function' && this._state === _REJECTED) {
            return this;
        }
        var promise = new Promise(_INTERNAL);
        if (this._state !== _PENDING) {
            var resolver = this._state === _FULFILLED ? onFulfilled : onRejected;
            _unwrap(promise, resolver, this._outcome);
        }
        else {
            this._queue.push(new _QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
    };
    /**
     *
     * @static
     * @param {any} value
     * @returns
     *
     * @memberOf Promise
     */
    Promise.resolve = function (value) {
        if (value instanceof this)
            return value;
        return _handlers._resolve(new Promise(_INTERNAL), value);
    };
    /**
     *
     * @static
     * @param {any} reason
     * @returns
     *
     * @memberOf Promise
     */
    Promise.reject = function (reason) {
        return _handlers._reject(new Promise(_INTERNAL), reason);
    };
    Promise.all = function (iterable) {
        var t = this;
        return new Promise(function (resolve, reject) {
            var results = [];
            if (!iterable.length) {
                resolve([]);
                return;
            }
            var maybeReturn = function (index, success, failure) {
                if (failure !== undefined) {
                    results.push(failure);
                }
                else {
                    results.push(success);
                }
                if (results.length == iterable.length) {
                    resolve(results);
                }
            };
            var _loop_1 = function (i) {
                iterable[i].then(function () {
                    var res = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        res[_i] = arguments[_i];
                    }
                    maybeReturn(i, res, undefined);
                }).catch(function (e) {
                    maybeReturn(i, undefined, e);
                });
            };
            for (var i = 0; i < iterable.length; i++) {
                _loop_1(i);
            }
        });
    };
    Promise.race = function (iterable) {
        var self = this;
        var len = iterable.length;
        var called = false;
        var i = -1;
        var promise = new Promise(_INTERNAL);
        if (Array.isArray(iterable) !== false) {
            return this.reject(new TypeError());
        }
        function resolver(value) {
            self.resolve(value).then(function (response) {
                if (!called) {
                    called = true;
                    _handlers._resolve(promise, response);
                }
            }, function (error) {
                if (!called) {
                    called = true;
                    _handlers._reject(promise, error);
                }
            });
        }
        if (!len) {
            return this.resolve([]);
        }
        while (++i < len) {
            resolver(iterable[i]);
        }
        return promise;
    };
    return Promise;
}());
exports.Promise = Promise;
/**
 * @internal
 *
 * @export
 * @class _QueueItem
 */
var _QueueItem = (function () {
    function _QueueItem(promise, onFulfilled, onRejected) {
        this._promise = promise;
        if (typeof onFulfilled === 'function') {
            this._onFulfilled = onFulfilled;
            this._callFulfilled = this._otherCallFulfilled;
        }
        if (typeof onRejected === 'function') {
            this._onRejected = onRejected;
            this._callRejected = this._otherCallRejected;
        }
    }
    _QueueItem.prototype._callFulfilled = function (value) {
        _handlers._resolve(this._promise, value);
    };
    ;
    _QueueItem.prototype._otherCallFulfilled = function (value) {
        _unwrap(this._promise, this._onFulfilled, value);
    };
    ;
    _QueueItem.prototype._callRejected = function (value) {
        _handlers._reject(this._promise, value);
    };
    ;
    _QueueItem.prototype._otherCallRejected = function (value) {
        _unwrap(this._promise, this._onRejected, value);
    };
    ;
    return _QueueItem;
}());
exports._QueueItem = _QueueItem;
/**
 *
 * @internal
 * @param {any} promise
 * @param {any} func
 * @param {any} value
 */
function _unwrap(promise, func, value) {
    exports.setFast(function () {
        var returnValue;
        try {
            returnValue = func.apply(null, value);
        }
        catch (e) {
            return _handlers._reject(promise, e);
        }
        if (returnValue === promise) {
            _handlers._reject(promise, new TypeError());
        }
        else {
            _handlers._resolve(promise, returnValue);
        }
        return null;
    });
}
/**
 *
 * @internal
 * @class _handlers
 */
var _handlers = (function () {
    function _handlers() {
    }
    _handlers._resolve = function (self, value) {
        var result = _tryCatch(_getThen, value);
        var thenable = result._value;
        var i = -1;
        var len = self._queue.length;
        if (result._status === 'error') {
            return _handlers._reject(self, result._value);
        }
        if (thenable) {
            _safelyResolveThenable(self, thenable);
        }
        else {
            self._state = _FULFILLED;
            self._outcome = value;
            while (++i < len) {
                self._queue[i]._callFulfilled(value);
            }
        }
        return self;
    };
    ;
    _handlers._reject = function (self, error) {
        self._state = _REJECTED;
        self._outcome = error;
        var i = -1;
        var len = self._queue.length;
        while (++i < len) {
            self._queue[i]._callRejected(error);
        }
        return self;
    };
    ;
    return _handlers;
}());
/**
 *
 * @internal
 * @param {any} obj
 * @returns
 */
function _getThen(obj) {
    // Make sure we only access the accessor once as required by the spec
    var then = obj && obj.then;
    if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
        return function appyThen() {
            then.apply(obj, arguments);
        };
    }
    else {
        return null;
    }
}
/**
 *
 * @internal
 * @param {Promise<any>} self
 * @param {(onSuccess:(...T) => void, onFail:(...T) => void) => void} thenable
 */
function _safelyResolveThenable(self, thenable) {
    // Either fulfill, reject or reject with error
    var called = false;
    function onError() {
        var value = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            value[_i] = arguments[_i];
        }
        if (called) {
            return;
        }
        called = true;
        _handlers._reject(self, value);
    }
    function onSuccess() {
        var value = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            value[_i] = arguments[_i];
        }
        if (called) {
            return;
        }
        called = true;
        _handlers._resolve(self, value);
    }
    function tryToUnwrap() {
        thenable(onSuccess, onError);
    }
    var result = _tryCatch(tryToUnwrap);
    if (result._status === 'error') {
        onError(result._value);
    }
}
/**
 *
 * @internal
 * @param {any} func
 * @param {*} [values]
 * @returns
 */
function _tryCatch(func, values) {
    var out = { _status: null, _value: null };
    try {
        out._value = func(values);
        out._status = 'success';
    }
    catch (e) {
        out._status = 'error';
        out._value = e;
    }
    return out;
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(0);
var lie_ts_1 = __webpack_require__(1);
var db_storage_1 = __webpack_require__(5);
var db_query_1 = __webpack_require__(3);
exports._str = function (index) {
    return ["_utility", "_historyPoints", "_pointer", "_historyDataRowIDs", "_id"][index];
};
var _NanoSQLDB = (function () {
    function _NanoSQLDB() {
        var t = this;
        t._pendingQuerys = [];
        t._queryCache = {};
    }
    _NanoSQLDB.prototype._connect = function (connectArgs) {
        var t = this;
        t._databaseID = index_1.NanoSQLInstance._hash(JSON.stringify(connectArgs._models)).toString();
        t._parent = connectArgs._parent;
        t._store = new db_storage_1._NanoSQL_Storage(t, connectArgs);
    };
    _NanoSQLDB.prototype._exec = function (execArgs) {
        var t = this;
        new db_query_1._NanoSQLQuery(t)._doQuery(execArgs);
    };
    _NanoSQLDB.prototype._invalidateCache = function (changedTableID, changedRows, changedRowPKS, type, action) {
        var t = this;
        t._queryCache[changedTableID] = {};
        if (changedRows.length && action) {
            t._parent.triggerEvent({
                name: "change",
                actionOrView: "",
                table: t._store._tables[changedTableID]._name,
                query: [],
                time: new Date().getTime(),
                result: [{ msg: action + " was performed.", type: action }],
                changedRows: changedRows,
                changedRowPKS: changedRowPKS,
                changeType: type
            }, ["change"]);
        }
    };
    _NanoSQLDB.prototype._deepFreeze = function (obj, tableID) {
        if (!obj)
            return obj;
        var t = this;
        if (tableID) {
            t._store._models[tableID].forEach(function (model) {
                var prop = obj[model.key];
                if (["map", "array"].indexOf(model.type) >= 0 || model.type.indexOf("[]") >= 0) {
                    obj[model.key] = t._deepFreeze(prop);
                }
            });
        }
        return Object.freeze(obj);
    };
    _NanoSQLDB.prototype._transaction = function (type, transactionID) {
        var t = this;
        return new lie_ts_1.Promise(function (res, rej) {
            if (type === "start") {
                t._store._activeTransactions.push(transactionID);
                res();
            }
            if (type === "end") {
                t._store._execTransaction(transactionID).then(function (result) {
                    var tLoc = t._store._activeTransactions.indexOf(transactionID);
                    if (tLoc !== -1)
                        t._store._activeTransactions.splice(tLoc, 1);
                    t._parent._tableNames.forEach(function (tableName) {
                        t._invalidateCache(index_1.NanoSQLInstance._hash(tableName), [], [], "transaction");
                    });
                    res(result);
                });
            }
        });
    };
    _NanoSQLDB.prototype._extend = function (db, command) {
        var t = this;
        var i;
        var h;
        var j;
        var rowID;
        var rowData;
        var rowKey;
        var store;
        var shiftRowIDs = function (direction, callBack) {
            var results = {};
            var check = (t._store._historyLength - t._store._historyPoint);
            t._store._readArray(exports._str(1), t._store._historyPointIndex[check], function (hps) {
                index_1.NanoSQLInstance.chain(hps.map(function (hp) {
                    return function (nextHP) {
                        var tableID = hp.tableID;
                        var table = t._store._tables[tableID];
                        var rows = [];
                        index_1.NanoSQLInstance.chain(hp.rowKeys.map(function (rowID) {
                            return function (nextRowKey) {
                                if (!results[tableID])
                                    results[tableID] = { type: hp.type, rows: [], affectedPKS: hp.rowKeys };
                                t._store._read("_" + table._name + "_hist__meta", rowID, function (row) {
                                    row = index_1._assign(row);
                                    row[0][exports._str(2)] = (row[0][exports._str(2)] || 0) + direction;
                                    var historyRowID = row[0][exports._str(3)][row[0][exports._str(2)]];
                                    t._store._upsert("_" + table._name + "_hist__meta", rowID, row[0], function () {
                                        t._store._read("_" + table._name + "_hist__data", historyRowID, function (setRow) {
                                            var newRow = {};
                                            if (setRow.length) {
                                                table._keys.forEach(function (k) {
                                                    newRow[k] = setRow[0][k];
                                                });
                                            }
                                            t._store._upsert(table._name, rowID, setRow.length ? newRow : null, function () {
                                                rows.push(newRow);
                                                results[tableID].rows = results[tableID].rows.concat(rows);
                                                i++;
                                                nextRowKey();
                                            });
                                        });
                                    });
                                });
                            };
                        }))(nextHP);
                    };
                }))(function () {
                    callBack(results);
                });
            });
        };
        return new lie_ts_1.Promise(function (res, rej) {
            switch (command) {
                case "<":
                    if (!t._store._historyLength || t._store._historyPoint === t._store._historyLength) {
                        res(false);
                    }
                    else {
                        shiftRowIDs(1, function (affectedTables) {
                            t._store._historyPoint++;
                            t._store._utility("w", "historyPoint", t._store._historyPoint);
                            Object.keys(affectedTables).forEach(function (tableID) {
                                var description = affectedTables[tableID].type;
                                switch (description) {
                                    case "inserted":
                                        description = "deleted";
                                        break;
                                    case "deleted":
                                        description = "inserted";
                                        break;
                                }
                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, affectedTables[tableID].affectedPKS, description, "undo");
                            });
                            res(true);
                        });
                    }
                    break;
                case ">":
                    if (!t._store._historyLength || t._store._historyPoint < 1) {
                        res(false);
                    }
                    else {
                        t._store._historyPoint--;
                        t._store._utility("w", "historyPoint", t._store._historyPoint);
                        shiftRowIDs(-1, function (affectedTables) {
                            Object.keys(affectedTables).forEach(function (tableID) {
                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, affectedTables[tableID].affectedPKS, affectedTables[tableID].type, "redo");
                            });
                            res(true);
                        });
                    }
                    break;
                case "?":
                    h = [t._store._historyLength, t._store._historyLength - t._store._historyPoint];
                    if (t._store._historyArray.join("+") !== h.join("+")) {
                        t._store._historyArray = h;
                    }
                    res(t._store._historyArray);
                    break;
                case "flush_history":
                case "flush_db":
                    t._store._utility("w", "historyPoint", 0);
                    t._store._utility("w", "historyLength", 0);
                    t._store._historyPoint = 0;
                    t._store._historyLength = 0;
                    Object.keys(t._store._tables).forEach(function (tableID) {
                        var pks;
                        if (t._store._tables[parseInt(tableID)]._name.indexOf("_") === 0) {
                            pks = [];
                        }
                        else {
                            pks = t._store._tables[parseInt(tableID)]._index;
                        }
                        t._invalidateCache(parseInt(tableID), pks.map(function (r) { return null; }), pks, "remove", "clear");
                    });
                    if (command === "flush_db") {
                        t._store._clear("all", res);
                    }
                    else {
                        t._store._clear("hist", res);
                    }
                    break;
            }
        });
    };
    return _NanoSQLDB;
}());
exports._NanoSQLDB = _NanoSQLDB;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(0);
var db_index_1 = __webpack_require__(2);
var lie_ts_1 = __webpack_require__(1);
var minMax = function (type, row, args, ptr, prev) {
    var key = args[0];
    if (ptr[0] === 0)
        prev[key] = type === -1 ? Number.MAX_VALUE : Number.MIN_VALUE;
    var nextRow = {};
    if (type === -1 ? parseFloat(row[key]) < parseFloat(prev[key]) : parseFloat(row[key]) > parseFloat(prev[key])) {
        nextRow = row;
    }
    else {
        nextRow = prev;
    }
    if (ptr[0] === ptr[1]) {
        var r = index_1._assign(nextRow);
        r[type === -1 ? "MIN" : "MAX"] = nextRow[key];
        return r;
    }
    else {
        return nextRow;
    }
};
exports._functions = {
    SUM: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] === 0)
                prev = 0;
            prev += parseInt(row[args[0]]);
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.SUM = prev;
                return r;
            }
            else {
                return prev;
            }
        }
    },
    MIN: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            return minMax(-1, row, args, ptr, prev);
        }
    },
    MAX: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            return minMax(1, row, args, ptr, prev);
        }
    },
    AVG: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] === 0)
                prev = 0;
            prev += parseInt(row[args[0]]);
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.AVG = (prev / (ptr[1] + 1)) || prev;
                return r;
            }
            else {
                return prev;
            }
        }
    },
    COUNT: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] === 0)
                prev = 0;
            if (args[0] === "*") {
                prev++;
            }
            else {
                prev += row[args[0]] ? 1 : 0;
            }
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.COUNT = prev;
                return r;
            }
            else {
                return prev;
            }
        }
    }
};
var _NanoSQLQuery = (function () {
    function _NanoSQLQuery(database) {
        this._db = database;
    }
    _NanoSQLQuery.prototype._doQuery = function (query) {
        var t = this;
        t._tableID = index_1.NanoSQLInstance._hash(query.table);
        t._mod = [];
        t._act = undefined;
        t._query = query;
        var simpleQuery = [];
        query.query.forEach(function (q) {
            if (["upsert", "select", "delete", "drop"].indexOf(q.type) >= 0) {
                t._act = q;
                if (q.type === "select")
                    t._queryHash = index_1.NanoSQLInstance._hash(JSON.stringify(query.query));
            }
            else if (["show tables", "describe", "count"].indexOf(q.type) >= 0) {
                simpleQuery.push(q);
            }
            else {
                t._mod.push(q);
            }
        });
        if (simpleQuery.length) {
            switch (simpleQuery[0].type) {
                case "show tables":
                    query.onSuccess([{ tables: Object.keys(t._db._store._tables).map(function (ta) { return t._db._store._tables[ta]._name; }) }], "info", [], []);
                    break;
                case "describe":
                    query.onSuccess([
                        {
                            name: t._db._store._tables[t._tableID]._name,
                            models: index_1._assign(t._db._store._models[t._tableID]),
                            primaryKey: t._db._store._tables[t._tableID]._pk,
                            count: t._db._store._tables[t._tableID]._index.length
                        }
                    ], "info", [], []);
                    break;
            }
        }
        else {
            t._execQuery(function (result, changeType, affectedRows, affectedPKs) {
                query.onSuccess(result, changeType, affectedRows, affectedPKs);
            });
        }
    };
    _NanoSQLQuery.prototype._getMod = function (name) {
        return this._mod.filter(function (v) { return v.type === name; }).pop();
    };
    _NanoSQLQuery.prototype._execQuery = function (callBack) {
        var t = this;
        if (!t._act)
            return;
        var doQuery = function (rows) {
            if (!t._act)
                return;
            switch (t._act.type) {
                case "upsert":
                    t._upsert(rows, callBack);
                    break;
                case "select":
                    t._select(rows, callBack);
                    break;
                case "drop":
                    var ptr_1 = 0;
                    var idx_1 = tableData._index.slice();
                    var nextRow_1 = function () {
                        if (ptr_1 < idx_1.length) {
                            t._db._store._read(tableData._name, idx_1[ptr_1], function (row) {
                                t._remove(row, function () {
                                    ptr_1++;
                                    nextRow_1();
                                });
                            });
                        }
                        else {
                            callBack([], "drop", idx_1.map(function (i) { return {}; }), idx_1);
                        }
                    };
                    nextRow_1();
                    break;
                case "delete":
                    t._remove(rows, callBack);
                    break;
            }
        };
        var tableData = t._db._store._tables[t._tableID];
        if (!t._getMod("join") && t._act.type !== "drop") {
            if (t._getMod("where")) {
                var whereArgs_1 = t._getMod("where").args;
                var isOptimizedWhere_1 = function (wArgs) {
                    if (["=", "IN", "BETWEEN"].indexOf(wArgs[1]) !== -1) {
                        if (wArgs[0] === tableData._pk || tableData._secondaryIndexes.indexOf(wArgs[0]) !== -1) {
                            return 0;
                        }
                    }
                    return 1;
                };
                var doFastWhere_1 = function (wArgs, callBack) {
                    var tableName = wArgs[0] === tableData._pk ? tableData._name : "_" + tableData._name + "_idx_" + wArgs[0];
                    var isSecondaryIdx = wArgs[0] !== tableData._pk;
                    switch (wArgs[1]) {
                        case "=":
                            t._db._store._read(tableName, isSecondaryIdx ? String(wArgs[2]).toLowerCase() : wArgs[2], function (rows) {
                                callBack(rows);
                            });
                            break;
                        case "IN":
                            var ptr = 0;
                            var resultRows = [];
                            t._db._store._readArray(tableName, isSecondaryIdx ? String(wArgs[2]).toLowerCase() : wArgs[2], function (rows) {
                                callBack(rows);
                            });
                            break;
                        case "BETWEEN":
                            if (isSecondaryIdx)
                                wArgs[2].map(function (a) { return String(a).toLowerCase(); });
                            t._db._store._readRange(tableName, wArgs[0], wArgs[2], callBack);
                            break;
                    }
                };
                var doFastRead = false;
                if (typeof whereArgs_1[0] === "string") {
                    doFastRead = isOptimizedWhere_1(whereArgs_1) === 0;
                }
                else {
                    doFastRead = whereArgs_1.reduce(function (prev, cur, i) {
                        if (i % 2 === 1)
                            return prev;
                        return prev + isOptimizedWhere_1(cur);
                    }, 0) === 0;
                }
                if (doFastRead) {
                    if (typeof whereArgs_1[0] === "string") {
                        doFastWhere_1(whereArgs_1, doQuery);
                    }
                    else {
                        var resultRows_1 = [];
                        var lastCommand_1 = "";
                        index_1.NanoSQLInstance.chain(whereArgs_1.map(function (wArg) {
                            return function (nextWArg) {
                                if (wArg === "OR" || wArg === "AND") {
                                    lastCommand_1 = wArg;
                                    nextWArg();
                                    return;
                                }
                                doFastWhere_1(wArg, function (rows) {
                                    if (lastCommand_1 === "AND") {
                                        var idx_2 = rows.map(function (r) { return r[tableData._pk]; });
                                        resultRows_1 = resultRows_1.filter(function (row) {
                                            return idx_2.indexOf(row[tableData._pk]) !== -1;
                                        });
                                    }
                                    else {
                                        resultRows_1 = resultRows_1.concat(rows);
                                    }
                                    nextWArg();
                                });
                            };
                        }))(function () {
                            doQuery(resultRows_1);
                        });
                    }
                }
                else {
                    t._db._store._read(tableData._name, function (row) {
                        return row && t._where(row, whereArgs_1);
                    }, doQuery);
                }
            }
            else if (t._getMod("range")) {
                var rangeArgs = t._getMod("range").args;
                t._getRange(rangeArgs[0], rangeArgs[1], doQuery);
            }
            else if (t._getMod("trie")) {
                var trieArgs = t._getMod("trie").args;
                var words = tableData._trieObjects[trieArgs[0]].getPrefix(trieArgs[1]);
                var indexTable = "_" + tableData._name + "_idx_" + trieArgs[0];
                t._db._store._readArray(indexTable, words, function (rows) {
                    doQuery(rows);
                });
            }
            else {
                if (t._act.type !== "upsert") {
                    t._db._store._read(tableData._name, "all", function (rows) {
                        doQuery(rows);
                    });
                }
                else {
                    doQuery([]);
                }
            }
        }
        else {
            doQuery([]);
        }
    };
    _NanoSQLQuery.prototype._getRange = function (limit, offset, callBack) {
        var t = this;
        var table = t._db._store._tables[t._tableID];
        var startIndex = table._index[offset];
        var endIndex = table._index[offset + (limit - 1)];
        if (!startIndex) {
            callBack([]);
        }
        else {
            t._db._store._readRange(table._name, table._pk, [startIndex, endIndex], function (rows) {
                callBack(rows);
            });
        }
    };
    _NanoSQLQuery.prototype._updateRow = function (rowPK, callBack) {
        var t = this;
        var table = t._db._store._tables[t._tableID];
        var qArgs = t._act.args;
        var oldRow = {};
        var updateType = (function () {
            return t._act ? t._act.type : "";
        })();
        var writeChanges = function (newRow) {
            if (updateType === "upsert") {
                t._db._store._upsert(table._name, rowPK, newRow, function () {
                    callBack();
                }, t._query.transactionID);
            }
            else {
                t._db._store._delete(table._name, rowPK, function () {
                    callBack();
                }, t._query.transactionID);
            }
        };
        if (t._query.transactionID) {
            if (updateType === "upsert") {
                t._db._store._tables[t._tableID]._keys.forEach(function (k, i) {
                    var def = table._defaults[i];
                    if (qArgs[k] === undefined && def !== undefined)
                        qArgs[k] = def;
                });
                writeChanges(qArgs);
            }
            else {
                writeChanges({});
            }
            return;
        }
        t._db._store._read(table._name, rowPK, function (rows) {
            oldRow = rows[0] || {};
            var newRow = index_1._assign(rows[0] || {});
            var doRemove = false;
            var finishUpdate = function (histDataID) {
                if (table._name.indexOf("_") !== 0 && t._db._store._doHistory && table._pk.length) {
                    t._db._store._read("_" + table._name + "_hist__meta", rowPK, function (rows) {
                        rows = index_1._assign(rows);
                        rows[0][db_index_1._str(3)].unshift(histDataID);
                        t._db._store._upsert("_" + table._name + "_hist__meta", rowPK, rows[0], function () { });
                    });
                }
                t._db._store._updateSecondaryIndex(updateType === "upsert" ? newRow : {}, t._tableID, function () {
                    writeChanges(newRow);
                });
            };
            var doHistory = function () {
                if (!doRemove && table._name.indexOf("_") !== 0 && t._db._store._doHistory) {
                    t._db._store._addHistoryRow(t._tableID, newRow, t._query.transactionID, finishUpdate);
                }
                else {
                    finishUpdate(0);
                }
            };
            switch (updateType) {
                case "upsert":
                    Object.getOwnPropertyNames(qArgs).forEach(function (k) {
                        newRow[k] = qArgs[k];
                    });
                    var table_1 = t._db._store._tables[t._tableID];
                    table_1._keys.forEach(function (k, i) {
                        var def = table_1._defaults[i];
                        if (newRow[k] === undefined && def !== undefined)
                            newRow[k] = def;
                    });
                    doHistory();
                    break;
                case "delete":
                case "drop":
                    if (qArgs && qArgs.length && updateType !== "drop") {
                        qArgs.forEach(function (column) {
                            newRow[column] = null;
                        });
                        doHistory();
                    }
                    else {
                        doRemove = true;
                        newRow = {};
                        if (t._db._store._tables[t._tableID]._relations.length) {
                            index_1.NanoSQLInstance.chain(t._db._store._tables[t._tableID]._relations.map(function (rel) {
                                return function (nextRelation) {
                                    if (rel._mapTo.length) {
                                        var relatedPK = t._db._store._tables[index_1.NanoSQLInstance._hash(rel._table)]._pk;
                                        var related = oldRow[rel._key] || [];
                                        if (!Array.isArray(related))
                                            related = [related];
                                        t._db._parent.table(rel._table).query("select").where([relatedPK, "IN", related]).exec().then(function (rows) {
                                            index_1.NanoSQLInstance.chain(rows.map(function (row) {
                                                return function (nextRow) {
                                                    var setRow = index_1._assign(row);
                                                    if (setRow[rel._mapTo]) {
                                                        if (Array.isArray(setRow[rel._mapTo])) {
                                                            var idx = setRow[rel._mapTo].indexOf(rowPK);
                                                            if (idx === -1) {
                                                                nextRow();
                                                                return;
                                                            }
                                                            else {
                                                                setRow[rel._mapTo].splice(idx, 1);
                                                            }
                                                        }
                                                        else {
                                                            setRow[rel._mapTo] = "";
                                                        }
                                                    }
                                                    t._db._parent.table(rel._table).query("upsert", setRow, true).exec().then(nextRow);
                                                };
                                            }))(nextRelation);
                                        });
                                    }
                                    else {
                                        nextRelation();
                                    }
                                };
                            }))(doHistory);
                        }
                        else {
                            doHistory();
                        }
                    }
                    break;
            }
        });
    };
    _NanoSQLQuery.prototype._tableChanged = function (updatedRowPKs, describe, callBack) {
        var t = this, k = 0, j = 0;
        if (t._query.transactionID) {
            callBack([], "trans", [], []);
            return;
        }
        if (updatedRowPKs.length > 0) {
            t._db._store._addHistoryPoint(t._tableID, updatedRowPKs, describe, function () {
                var table = t._db._store._tables[t._tableID];
                t._db._invalidateCache(t._tableID, [], [], "");
                t._db._store._readArray(table._name, updatedRowPKs, function (rows) {
                    callBack([{ msg: updatedRowPKs.length + " row(s) " + describe, rows: rows, updatedRowPKs: updatedRowPKs }], describe, rows, updatedRowPKs);
                });
            });
        }
        else {
            callBack([{ msg: "0 rows " + describe }], describe, [], []);
        }
    };
    _NanoSQLQuery.prototype._upsert = function (queryRows, callBack) {
        var t = this;
        var scribe = "", i, changedPKs = [];
        var qArgs = t._act.args || {}, table = t._db._store._tables[t._tableID], pk = table._pk, whereMod = t._getMod("where");
        if (whereMod) {
            scribe = "modified";
            changedPKs = queryRows.map(function (r) { return r[table._pk]; });
            i = 0;
            var update_1 = function () {
                if (i < queryRows.length) {
                    t._updateRow(queryRows[i][pk], function () {
                        i++;
                        update_1();
                    });
                }
                else {
                    t._tableChanged(changedPKs, scribe, callBack);
                }
            };
            update_1();
        }
        else {
            scribe = "inserted";
            if (!qArgs[pk]) {
                qArgs[pk] = t._db._store._generateID(table._pkType, t._tableID);
            }
            else {
                if (table._pkType === "int") {
                    table._incriment = Math.max(qArgs[pk] + 1, table._incriment);
                }
            }
            var objPK = qArgs[pk] ? qArgs[pk] : table._index.length;
            changedPKs = [objPK];
            if (!table._trieIndex.getPrefix(String(objPK)).length) {
                var tableName = t._db._store._tables[t._tableID]._name;
                if (tableName.indexOf("_") !== 0 && t._db._store._doHistory) {
                    var histTable = "_" + tableName + "_hist__meta";
                    var histRow = {};
                    histRow[db_index_1._str(2)] = 0;
                    histRow[db_index_1._str(3)] = [0];
                    t._db._store._upsert(histTable, objPK, histRow, function () { }, t._query.transactionID);
                }
            }
            t._updateRow(objPK, function () {
                t._tableChanged(changedPKs, scribe, callBack);
            });
        }
    };
    _NanoSQLQuery.prototype._getTableID = function () {
        return this._joinTable ? this._joinTable : this._tableID;
    };
    _NanoSQLQuery.prototype._select = function (queryRows, callBack) {
        var _this = this;
        var t = this;
        if (t._db._queryCache[t._tableID][t._queryHash]) {
            callBack(t._db._queryCache[t._tableID][t._queryHash], "none", [], []);
            return;
        }
        var mods = ["join", "groupby", "having", "orderby", "offset", "limit", "orm"];
        var curMod, column, i, k, rows, obj, rowData, groups = {};
        var sortObj = function (objA, objB, columns) {
            return Object.keys(columns).reduce(function (prev, cur) {
                var A = _this._resolveObjectPath(cur, objA);
                var B = _this._resolveObjectPath(cur, objB);
                if (!prev) {
                    if (A === B)
                        return 0;
                    return (A > B ? 1 : -1) * (columns[cur] === "desc" ? -1 : 1);
                }
                else {
                    return prev;
                }
            }, 0);
        };
        var modifyQuery = function (tableResult, modIndex, next) {
            curMod = t._getMod(mods[modIndex]);
            if (modIndex === 2) {
                var functions_1 = [];
                if (qArgs.length) {
                    var funcs_1 = Object.keys(exports._functions).map(function (f) { return f + "("; });
                    var keepColumns_1 = [];
                    functions_1 = qArgs.filter(function (q) {
                        var hasFunc = funcs_1.reduce(function (prev, cur) {
                            return (q.indexOf(cur) < 0 ? 0 : 1) + prev;
                        }, 0) || 0;
                        if (hasFunc > 0) {
                            return true;
                        }
                        else {
                            keepColumns_1.push(q);
                            return false;
                        }
                    }).map(function (selectString) {
                        var regex = selectString.match(/(.*)\((.*)\)/);
                        var funcName = regex[1].trim();
                        var columnName = (selectString.match(/\sAS\s(.*)/) || []).pop() || funcName;
                        var args = regex[2].split(",").map(function (s) { return s.trim(); });
                        if (exports._functions[funcName].type === "simple" && columnName === funcName) {
                            columnName = args[0];
                        }
                        keepColumns_1.push(columnName);
                        return {
                            name: funcName,
                            args: args,
                            as: columnName.trim(),
                            type: exports._functions[funcName].type
                        };
                    });
                    var rows_1 = [];
                    if (functions_1.length) {
                        var prevFunc_1;
                        var doFunctions_1 = function (rows) {
                            return functions_1.sort(function (a, b) {
                                return a.type > b.type ? 1 : -1;
                            }).reduce(function (prev, curr) {
                                var len = prev.length - 1;
                                if (curr.type === "aggregate") {
                                    var newRows = rows.slice();
                                    len = newRows.length - 1;
                                    newRows = [newRows.reduce(function (p, v, i) {
                                            return exports._functions[curr.name].call(v, curr.args, [i, len], p);
                                        }, {})];
                                    if (prevFunc_1) {
                                        newRows[0][prevFunc_1] = prev[0][prevFunc_1];
                                    }
                                    prev = newRows;
                                    prevFunc_1 = curr.name;
                                }
                                else {
                                    prev = prev.map(function (v, i) {
                                        return exports._functions[curr.name].call(v, curr.args, [i, len]);
                                    });
                                }
                                if (curr.name !== curr.as) {
                                    keepColumns_1.push(curr.name + " AS " + curr.as);
                                }
                                else {
                                    keepColumns_1.push(curr.name);
                                }
                                return prev;
                            }, rows.slice());
                        };
                        var groupKeys = Object.keys(groups);
                        if (groupKeys.length) {
                            rows_1 = groupKeys
                                .map(function (k) { return prevFunc_1 = null, doFunctions_1(groups[k]); })
                                .reduce(function (prev, curr) {
                                return prev = prev.concat(curr), prev;
                            }, []);
                        }
                        else {
                            rows_1 = doFunctions_1(tableResult);
                        }
                    }
                    else {
                        rows_1 = tableResult;
                    }
                    var convertKeys_1 = keepColumns_1.map(function (n) {
                        return n.match(/(.*)\sAS\s(.*)/) || n;
                    }).filter(function (n) { return n; }) || [];
                    if (convertKeys_1.length) {
                        rows_1 = rows_1.map(function (r) {
                            r = index_1._assign(r);
                            var newRow = {};
                            convertKeys_1.forEach(function (key) {
                                if (typeof key === "string") {
                                    if (key.indexOf(".length") !== -1) {
                                        var newKey = key.replace(".length", "");
                                        newRow[key] = (r[newKey] || []).length;
                                    }
                                    else {
                                        newRow[key] = r[key];
                                    }
                                }
                                else {
                                    if (key[1].indexOf(".length") !== -1) {
                                        var newKey = key[1].replace(".length", "");
                                        newRow[key[2]] = (r[newKey] || []).length;
                                    }
                                    else {
                                        newRow[key[2]] = r[key[1]];
                                    }
                                }
                            });
                            return newRow;
                        });
                    }
                    tableResult = rows_1;
                }
            }
            if (!curMod)
                return next(tableResult);
            switch (modIndex) {
                case 0:
                    var joinConditions = void 0;
                    if (curMod.args.type !== "cross") {
                        joinConditions = {
                            _left: curMod.args.where[0],
                            _check: curMod.args.where[1],
                            _right: curMod.args.where[2]
                        };
                    }
                    var leftTableID = t._tableID;
                    var rightTableID = index_1.NanoSQLInstance._hash(curMod.args.table);
                    var where_1 = t._getMod("where");
                    var range_1 = t._getMod("range");
                    t._join(curMod.args.type, leftTableID, rightTableID, joinConditions, function (joinedRows) {
                        if (where_1) {
                            next(joinedRows.filter(function (row) {
                                return t._where(row, where_1.args);
                            }));
                        }
                        else if (range_1) {
                            t._getRange(range_1.args[0], range_1.args[1], next);
                        }
                        else {
                            next(joinedRows);
                        }
                    });
                    break;
                case 1:
                    var columns_1 = curMod.args;
                    var sortGroups_1 = {};
                    if (columns_1) {
                        groups = tableResult.reduce(function (prev, curr) {
                            var key = Object.keys(columns_1).reduce(function (p, c) {
                                if (c.indexOf(".length") !== -1) {
                                    return p + "." + String((curr[c.replace(".length", "")] || []).length);
                                }
                                else {
                                    return p + "." + String(curr[c]);
                                }
                            }, "").slice(1);
                            (prev[key] = prev[key] || []).push(curr);
                            sortGroups_1[key] = Object.keys(columns_1).reduce(function (pr, cu) {
                                if (cu.indexOf(".length") !== -1) {
                                    var newCu = cu.replace(".length", "");
                                    pr[newCu] = (curr[newCu] || []).length;
                                }
                                else {
                                    pr[cu] = curr[cu];
                                }
                                return pr;
                            }, {});
                            return prev;
                        }, {});
                        next(Object.keys(groups).sort(function (a, b) {
                            return sortObj(sortGroups_1[a], sortGroups_1[b], columns_1);
                        }).reduce(function (prev, curr) {
                            return prev.concat(groups[curr]);
                        }, []));
                    }
                    else {
                        next(tableResult);
                    }
                    break;
                case 2:
                    next(tableResult.filter(function (row) {
                        return t._where(row, t._getMod("having").args);
                    }));
                    break;
                case 3:
                    next(tableResult.sort(function (a, b) {
                        return sortObj(a, b, curMod.args);
                    }));
                    break;
                case 4:
                    next(tableResult.filter(function (row, index) {
                        return curMod ? index >= curMod.args : true;
                    }));
                    break;
                case 5:
                    next(tableResult.filter(function (row, index) {
                        return curMod ? index < curMod.args : true;
                    }));
                    break;
                case 6:
                    var modifiers_1 = [];
                    if (curMod.args)
                        modifiers_1 = curMod.args;
                    var defaultModifier_1 = t._db._store._parent._parent._ormFns[t._db._store._tables[t._tableID]._name];
                    if (!t._getMod("join")) {
                        lie_ts_1.Promise.all(tableResult.map(function (row, k) {
                            tableResult[k] = index_1._assign(row);
                            return lie_ts_1.Promise.all(t._db._store._tables[t._tableID]._relations.map(function (rel) {
                                var useKey = rel._key;
                                if (qArgs && qArgs.length) {
                                    qArgs.forEach(function (q) {
                                        var column = q.split(" ");
                                        if (column[0] === rel._key && column[1] === "AS") {
                                            useKey = column[2];
                                        }
                                    });
                                }
                                if (row[useKey] === undefined) {
                                    return new lie_ts_1.Promise(function (res) { return res(); });
                                }
                                var tablePK = t._db._store._tables[index_1.NanoSQLInstance._hash(rel._table)]._pk;
                                return new lie_ts_1.Promise(function (res, rej) {
                                    var modifier = undefined;
                                    if (defaultModifier_1) {
                                        modifier = defaultModifier_1(rel._key, tableResult[k]);
                                    }
                                    if (modifiers_1.length) {
                                        modifiers_1.forEach(function (mod) {
                                            if (typeof mod !== "string") {
                                                if (mod.key === rel._key || !mod.key || mod.key === "*") {
                                                    modifier = mod;
                                                }
                                            }
                                        });
                                    }
                                    if (!modifier && modifiers_1.indexOf(rel._key) === -1) {
                                        res();
                                        return;
                                    }
                                    var Ids = row[useKey];
                                    if (Ids === undefined) {
                                        tableResult[k][useKey] = rel._type === "single" ? undefined : [];
                                        res();
                                        return;
                                    }
                                    if (rel._type === "single")
                                        Ids = [Ids];
                                    var query = t._db._parent.table(rel._table).query("select");
                                    if (modifier) {
                                        if (!modifier.where && !modifier.orderBy) {
                                            var offset_1 = modifier.offset || 0;
                                            var limit_1 = modifier.limit || 0;
                                            query.where([tablePK, "IN", Ids.filter(function (v, i) {
                                                    return i >= offset_1 && i < offset_1 + limit_1;
                                                })]);
                                        }
                                        else {
                                            if (modifier.where) {
                                                if (typeof modifier.where[0] === "string") {
                                                    query.where([[tablePK, "IN", Ids], "AND", modifier.where]);
                                                }
                                                else {
                                                    modifier.where.push("AND");
                                                    modifier.where.push([tablePK, "IN", Ids]);
                                                    query.where(modifier.where);
                                                }
                                            }
                                            else {
                                                query.where([tablePK, "IN", Ids]);
                                            }
                                            if (modifier.orderBy)
                                                query.orderBy(modifier.orderBy);
                                            query.limit(modifier.limit || 5).offset(modifier.offset || 0);
                                        }
                                    }
                                    else {
                                        query.where([tablePK, "IN", Ids.filter(function (v, i) { return i < 5; })]);
                                    }
                                    query.exec().then(function (relations) {
                                        tableResult[k][useKey] = rel._type === "single" ? relations[0] : relations;
                                        res();
                                    });
                                });
                            }));
                        })).then(function () {
                            next(tableResult);
                        });
                    }
                    else {
                        next(tableResult);
                    }
                    break;
            }
        };
        i = -1;
        var qArgs = t._act.args || [];
        var stepQuery = function (rowPKs) {
            if (i < mods.length) {
                i++;
                modifyQuery(rowPKs, i, function (resultRows) {
                    stepQuery(resultRows);
                });
            }
            else {
                rowPKs = rowPKs.filter(function (r) { return r; });
                if (!t._getMod("join") && !t._getMod("orm")) {
                    t._db._queryCache[t._tableID][t._queryHash] = rowPKs;
                }
                callBack(rowPKs, "none", [], []);
            }
        };
        stepQuery(queryRows);
    };
    _NanoSQLQuery.prototype._remove = function (queryRows, callBack) {
        var scribe = "deleted", i;
        var t = this;
        var qArgs = t._act.args || [];
        var pk = t._db._store._tables[t._tableID]._pk;
        i = 0;
        var remove = function () {
            if (i < queryRows.length) {
                t._updateRow(queryRows[i][pk], function () {
                    i++;
                    remove();
                });
            }
            else {
                if (qArgs.length)
                    scribe = "modified";
                t._tableChanged(queryRows.map(function (r) { return r[pk]; }), scribe, callBack);
            }
        };
        remove();
    };
    _NanoSQLQuery.prototype._resolveObjectPath = function (pathQuery, object) {
        var val;
        if (pathQuery.indexOf("[") !== -1 && pathQuery.indexOf("]") !== -1) {
            var path = (pathQuery.match(/\[([^\]]+)\]/gm) || []).map(function (v) { return v.slice(1, -1); });
            path.unshift(pathQuery.slice(0, pathQuery.indexOf("[")));
            var safeGet_1 = function (getPath, object) {
                if (!getPath.length || !object)
                    return object;
                var topProp = getPath.shift();
                return safeGet_1(getPath, object[topProp]);
            };
            val = safeGet_1(path, object);
        }
        else {
            val = object ? object[pathQuery.split(".").shift()] : object;
        }
        if (pathQuery.indexOf(".length") !== -1)
            return val && val.length ? val.length : 0;
        return val;
    };
    _NanoSQLQuery.prototype._where = function (row, conditions) {
        var t = this;
        var commands = ["AND", "OR"];
        if (typeof conditions[0] !== "string") {
            var hasAnd_1 = false;
            var checkWhere_1 = conditions.map(function (cur, idx) {
                if (commands.indexOf(cur) !== -1) {
                    if (cur === "AND")
                        hasAnd_1 = true;
                    return cur;
                }
                else {
                    return t._compare(cur[2], cur[1], t._resolveObjectPath(cur[0], row)) === 0 ? true : false;
                }
            });
            checkWhere_1.forEach(function (cur, idx) {
                if (cur === "OR") {
                    checkWhere_1[idx] = checkWhere_1[idx - 1] || checkWhere_1[idx + 1];
                    checkWhere_1[idx - 1] = undefined;
                    checkWhere_1[idx + 1] = undefined;
                }
            });
            checkWhere_1 = checkWhere_1.filter(function (val) { return val !== undefined; });
            if (!hasAnd_1) {
                return checkWhere_1.indexOf(true) !== -1;
            }
            else {
                var reducing_1;
                var prevAnd_1 = false;
                return checkWhere_1.reduce(function (prev, cur, idx) {
                    if (idx === 0) {
                        prev.push(cur);
                        reducing_1 = prev.length - 1;
                        return prev;
                    }
                    if (cur === "AND") {
                        prevAnd_1 = true;
                        prev.push(cur);
                        return prev;
                    }
                    if (prevAnd_1) {
                        prev.push(cur);
                        reducing_1 = prev.length - 1;
                        prevAnd_1 = false;
                        return prev;
                    }
                    if (reducing_1 !== undefined) {
                        prev[reducing_1] = cur || prev[reducing_1];
                    }
                    return prev;
                }, []).filter(function (val) { return val !== undefined; }).indexOf(false) === -1;
            }
        }
        else {
            return t._compare(conditions[2], conditions[1], t._resolveObjectPath(conditions[0], row)) === 0 ? true : false;
        }
    };
    _NanoSQLQuery.prototype._join = function (type, leftTableID, rightTableID, joinConditions, complete) {
        var L = "left";
        var R = "right";
        var O = "outer";
        var t = this;
        var leftTableData = t._db._store._tables[leftTableID];
        var rightTableData = t._db._store._tables[rightTableID];
        var doJoinRows = function (leftRow, rightRow) {
            return [leftTableData, rightTableData].reduce(function (prev, cur, i) {
                cur._keys.forEach(function (k) {
                    prev[cur._name + "." + k] = ((i === 0 ? leftRow : rightRow) || {})[k];
                });
                return prev;
            }, {});
        };
        var joinTable = [];
        var rightUsedPKs = [];
        t._db._store._read(leftTableData._name, "all", function (leftRows) {
            t._db._store._read(rightTableData._name, "all", function (rightRows) {
                leftRows.forEach(function (leftRow) {
                    var joinRows = rightRows.map(function (rightRow) {
                        var joinedRow = doJoinRows(leftRow, rightRow);
                        if (!joinConditions)
                            return joinedRow;
                        var keep = t._where(joinedRow, [joinConditions._left, joinConditions._check, joinedRow[joinConditions._right]]);
                        if (keep)
                            rightUsedPKs.push(rightRow[rightTableData._pk]);
                        return keep ? joinedRow : null;
                    }).filter(function (r) { return r; });
                    if (joinRows.length) {
                        joinTable = joinTable.concat(joinRows);
                    }
                    else if ([L, O].indexOf(type) >= 0) {
                        joinTable.push(doJoinRows(leftRow, null));
                    }
                });
                rightUsedPKs = rightUsedPKs.sort().filter(function (item, pos, ary) {
                    return !pos || item !== ary[pos - 1];
                });
                if ([R, O].indexOf(type) >= 0) {
                    rightRows.filter(function (r) {
                        return rightUsedPKs.indexOf(r[rightTableData._pk]) === -1;
                    }).forEach(function (rightRow) {
                        joinTable.push(doJoinRows(null, rightRow));
                    });
                }
                complete(joinTable);
            });
        });
    };
    _NanoSQLQuery.prototype._compare = function (val1, compare, val2) {
        var setValue = function (val) {
            return (compare === "LIKE" || compare === "NOT LIKE") ? String(val || "").toLowerCase() : val;
        };
        var left = setValue(val2);
        var right = setValue(val1);
        if (right === "NULL" || right === "NOT NULL") {
            if (compare === "=" || compare === "LIKE") {
                if (right === "NULL") {
                    return val2 === null || val2 === undefined ? 0 : 1;
                }
                else {
                    return val2 !== null && val2 !== undefined ? 0 : 1;
                }
            }
            else {
                return 1;
            }
        }
        switch (compare) {
            case "=": return left === right ? 0 : 1;
            case "!=": return left !== right ? 0 : 1;
            case ">": return left > right ? 0 : 1;
            case "<": return left < right ? 0 : 1;
            case "<=": return left <= right ? 0 : 1;
            case ">=": return left >= right ? 0 : 1;
            case "IN": return right.indexOf(left) < 0 ? 1 : 0;
            case "NOT IN": return right.indexOf(left) < 0 ? 0 : 1;
            case "REGEX": return left.search(right) < 0 ? 1 : 0;
            case "LIKE": return left.indexOf(right) < 0 ? 1 : 0;
            case "NOT LIKE": return left.indexOf(right) > 0 ? 1 : 0;
            case "BETWEEN": return right[0] <= left && right[1] >= left ? 0 : 1;
            case "HAVE": return (left || []).indexOf(right) < 0 ? 1 : 0;
            case "NOT HAVE": return (left || []).indexOf(right) < 0 ? 0 : 1;
            default: return 1;
        }
    };
    return _NanoSQLQuery;
}());
exports._NanoSQLQuery = _NanoSQLQuery;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(0);
var db_index_1 = __webpack_require__(2);
var db_query_1 = __webpack_require__(3);
var lie_ts_1 = __webpack_require__(1);
var prefix_trie_ts_1 = __webpack_require__(6);
var _NanoSQL_Storage = (function () {
    function _NanoSQL_Storage(database, args) {
        this._savedArgs = args;
        this.init(database, args);
    }
    _NanoSQL_Storage.prototype.init = function (database, args) {
        var t = this;
        t._models = {};
        t._tables = {};
        t._levelDBs = {};
        t._historyPoint = 0;
        t._historyLength = 0;
        t._historyArray = [0, 0];
        t._activeTransactions = [];
        t._transactionData = {};
        t._doHistory = true;
        t._historyMode = 1;
        t._storeMemory = true;
        t._persistent = false;
        t._utilityTable = {};
        t._historyPointIndex = {};
        t._dbPath = ".";
        t._dbWriteCacheMB = 12;
        t._dbReadCacheMB = 24;
        t._mode = 0;
        t._parent = database;
        if (args._config.length) {
            t._persistent = args._config[0].persistent !== undefined
                ? args._config[0].persistent
                : false;
            t._doHistory = args._config[0].history !== undefined
                ? args._config[0].history
                : true;
            t._storeMemory = args._config[0].memory !== undefined
                ? args._config[0].memory
                : true;
            t._mode =
                {
                    IDB: 1,
                    LS: 2,
                    LVL: 4
                }[args._config[0].mode] || 0;
            if (args._config[0].historyMode &&
                args._config[0].history === "revisions") {
                t._historyMode = 2;
            }
            if (args._config[0].rebuildIndexes)
                t._rebuildIndexes = true;
            if (args._config[0].id)
                t._parent._databaseID = String(args._config[0].id);
            if (args._config[0].dbPath)
                t._dbPath = String(args._config[0].dbPath);
            if (args._config[0].writeCache)
                t._dbWriteCacheMB = parseFloat(args._config[0].writeCache);
            if (args._config[0].readCache)
                t._dbReadCacheMB = parseFloat(args._config[0].readCache);
        }
        var upgrading = false;
        var index = 0;
        var isNewStore = true;
        Object.keys(args._models).forEach(function (t) {
            var pkRow = { key: "x", type: "x" };
            var secondaryIndexes = [];
            args._models[t].forEach(function (m) {
                if (m.props && m.props.indexOf("pk") !== -1) {
                    pkRow = index_1._assign(m);
                }
                if (m.props &&
                    (m.props.indexOf("idx") !== -1 || m.props.indexOf("trie") !== -1)) {
                    secondaryIndexes.push(m);
                }
            });
            if (pkRow.key !== "x" && pkRow.type !== "x") {
                args._models["_" + t + "_hist__data"] = index_1._assign(args._models[t]).map(function (m) {
                    return {
                        key: m.key,
                        type: m.type
                    };
                });
                args._models["_" + t + "_hist__data"].unshift({
                    key: db_index_1._str(4),
                    type: "int"
                });
                args._models["_" + t + "_hist__meta"] = [
                    pkRow,
                    { key: "_pointer", type: "int", default: 0 },
                    { key: "_historyDataRowIDs", type: "array" }
                ];
            }
            if (secondaryIndexes.length &&
                (pkRow.key !== "x" && pkRow.type !== "x")) {
                secondaryIndexes.forEach(function (s) {
                    args._models["_" + t + "_idx_" + s.key] = [
                        { key: "id", type: s.type, props: ["pk"] },
                        { key: "rowPK", type: pkRow.type }
                    ];
                });
            }
        });
        args._models[db_index_1._str(1)] = [
            { key: "id", type: "int", props: ["ai", "pk"] },
            { key: "tableID", type: "int" },
            { key: "historyPoint", type: "int" },
            { key: "rowKeys", type: "array" },
            { key: "type", type: "string" }
        ];
        args._models[db_index_1._str(0)] = [
            { key: "key", type: "string", props: ["pk"] },
            { key: "value", type: "blob" }
        ];
        var tables = Object.keys(args._models);
        var beforeHist;
        var beforeMode;
        Object.keys(args._models).forEach(function (tableName) {
            t._newTable(tableName, args._models[tableName]);
        });
        Object.keys(args._functions || {}).forEach(function (f) {
            db_query_1._functions[f] = args._functions[f];
        });
        var rebuildSecondaryIndexes = function () {
            if (!t._rebuildIndexes) {
                t._rebuildTries(args._onSuccess);
            }
            else {
                lie_ts_1.Promise.all(Object.keys(args._models).map(function (tableName) {
                    return new lie_ts_1.Promise(function (res, rej) {
                        t._rebuildSecondaryIndex(tableName, function () {
                            res();
                        });
                    });
                })).then(function () {
                    t._rebuildTries(args._onSuccess);
                });
            }
        };
        var completeSetup = function () {
            var tables = Object.keys(args._models);
            var i = 0;
            t._mode = beforeMode;
            if (beforeHist && t._historyMode === 1) {
                t._read(db_index_1._str(0), "all", function (rows) {
                    rows.forEach(function (d) {
                        t._utility("w", d.key, d.value);
                        if (d.key === "historyPoint")
                            t._historyPoint = d.value || 0;
                        if (d.key === "historyLength")
                            t._historyLength = d.value || 0;
                    });
                });
                t._read(db_index_1._str(1), "all", function (rows) {
                    rows.forEach(function (row) {
                        if (!t._historyPointIndex[row.historyPoint]) {
                            t._historyPointIndex[row.historyPoint] = [];
                        }
                        t._historyPointIndex[row.historyPoint].push(row.id);
                    });
                });
            }
            var restoreHistoryData = function () {
                if (i < tables.length) {
                    if (tables[i].indexOf("_hist__data") !== -1) {
                        var ta = index_1.NanoSQLInstance._hash(tables[i]);
                        if (isNewStore) {
                            t._upsert(tables[i], 0, null, function () {
                                i++;
                                restoreHistoryData();
                            });
                        }
                        else {
                            i++;
                            restoreHistoryData();
                        }
                    }
                    else {
                        i++;
                        restoreHistoryData();
                    }
                }
                else {
                    t._doHistory = beforeHist;
                    rebuildSecondaryIndexes();
                }
            };
            restoreHistoryData();
        };
        beforeMode = t._mode;
        if (t._persistent) {
            if (t._mode !== 0) {
                switch (t._mode) {
                    case 1:
                        if (typeof indexedDB === "undefined")
                            t._mode = 0;
                        break;
                    case 2:
                        if (typeof localStorage === "undefined")
                            t._mode = 0;
                        break;
                    case 4:
                        if (typeof window !== "undefined")
                            t._mode = 0;
                        break;
                }
            }
            else {
                if (typeof window !== "undefined") {
                    if (typeof localStorage !== "undefined")
                        t._mode = 2;
                    if (typeof indexedDB !== "undefined")
                        t._mode = 1;
                }
                if (typeof global !== "undefined") {
                    if (typeof global._levelup !== "undefined" &&
                        typeof global._fs !== "undefined") {
                        t._mode = 4;
                    }
                }
            }
        }
        else {
            t._mode = 0;
        }
        beforeHist = t._doHistory;
        beforeMode = t._mode;
        t._mode = 0;
        var createTables = function (makeTable, complete) {
            var next = function () {
                if (index < tables.length) {
                    var ta = index_1.NanoSQLInstance._hash(tables[index]);
                    makeTable(tables[index], ta, t._tables[ta]);
                    index++;
                    next();
                }
                else {
                    complete();
                }
            };
            next();
        };
        var cacheTableData = function (args) {
            isNewStore = false;
            var index = 0;
            var next = function () {
                if (index < tables.length) {
                    var ta_1 = index_1.NanoSQLInstance._hash(tables[index]);
                    if (!beforeHist &&
                        (tables[index].indexOf("_hist__data") !== -1 ||
                            tables[index].indexOf("_hist__meta") !== -1)) {
                        index++;
                        next();
                        return;
                    }
                    if (t._storeMemory) {
                        args.requestTable(tables[index], function (tableData) {
                            t._parent._parent.loadJS(tables[index], tableData).then(function () {
                                if (tables[index].indexOf("_hist__data") !== -1) {
                                    t._tables[ta_1]._rows[0] = null;
                                }
                                index++;
                                next();
                            });
                        });
                    }
                    else if (!t._storeMemory || args.forceIndex) {
                        args.requestIndex(tables[index], function (indexData) {
                            t._parent._store._tables[ta_1]._index = indexData;
                            t._parent._store._tables[ta_1]._incriment = indexData.reduce(function (prev, cur) {
                                return Math.max(prev, parseInt(cur) || 0);
                            }, 0);
                            t._parent._store._tables[ta_1]._incriment++;
                            index++;
                            next();
                        });
                    }
                }
                else {
                    if (args.cleanup) {
                        args.cleanup(function () {
                            completeSetup();
                        });
                    }
                    else {
                        completeSetup();
                    }
                    return;
                }
            };
            next();
        };
        switch (beforeMode) {
            case 0:
                completeSetup();
                break;
            case 1:
                var idb = indexedDB.open(t._parent._databaseID, 1);
                idb.onupgradeneeded = function (event) {
                    upgrading = true;
                    var db = event.target.result;
                    var transaction = event.target.transaction;
                    t._indexedDB = db;
                    createTables(function (tableName, tableHash, tableObj) {
                        var config = tableObj._pk ? { keyPath: tableObj._pk } : {};
                        db.createObjectStore(tableName, config);
                    }, function () {
                        transaction.oncomplete = function () {
                            completeSetup();
                        };
                    });
                };
                idb.onsuccess = function (event) {
                    t._indexedDB = event.target.result;
                    if (!upgrading) {
                        var getIDBData_1 = function (tName, callBack) {
                            var items = [];
                            var transaction = t._indexedDB.transaction(tName, "readonly");
                            var store = transaction.objectStore(tName);
                            var cursorRequest = store.openCursor();
                            cursorRequest.onsuccess = function (evt) {
                                var cursor = evt.target.result;
                                if (cursor) {
                                    items.push(t._storeMemory ? cursor.value : cursor.key);
                                    cursor.continue();
                                }
                            };
                            transaction.oncomplete = function () {
                                callBack(items);
                            };
                        };
                        cacheTableData({
                            requestIndex: function (tableName, complete) {
                                getIDBData_1(tableName, complete);
                            },
                            requestTable: function (tableName, complete) {
                                getIDBData_1(tableName, complete);
                            }
                        });
                    }
                };
                break;
            case 2:
                if (localStorage.getItem("dbID") !== t._parent._databaseID) {
                    localStorage.setItem("dbID", t._parent._databaseID);
                    createTables(function (tableName, tableHash, tableObj) {
                        localStorage.setItem(tableName, JSON.stringify([]));
                    }, function () {
                        completeSetup();
                    });
                }
                else {
                    cacheTableData({
                        forceIndex: true,
                        requestIndex: function (tableName, complete) {
                            var tableIndex = JSON.parse(localStorage.getItem(tableName) || "[]");
                            complete(tableIndex);
                        },
                        requestTable: function (tableName, complete) {
                            var items = [];
                            JSON.parse(localStorage.getItem(tableName) || "[]").forEach(function (ptr) {
                                items.push(JSON.parse(localStorage.getItem(tableName + "-" + ptr) || ""));
                            });
                            complete(items);
                        }
                    });
                }
                break;
        }
    };
    _NanoSQL_Storage.prototype._rebuildSecondaryIndex = function (tableName, complete) {
        var t = this;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        var rowPTR = 0;
        var secondIdx = t._tables[ta]._secondaryIndexes;
        this._read(tableName, "all", function (rows) {
            var PK = t._tables[ta]._pk;
            var step2 = function () {
                if (rowPTR < rows.length) {
                    var ptr3_1 = 0;
                    var step3_1 = function () {
                        if (ptr3_1 < secondIdx.length) {
                            var key_1 = secondIdx[ptr3_1];
                            var idxTbl_1 = "_" + tableName + "_idx_" + key_1;
                            t._delete(idxTbl_1, "all", function () {
                                var rowKey = String(rows[rowPTR][key_1]).toLowerCase();
                                t._read(idxTbl_1, rowKey, function (readRows) {
                                    var indexedRows = [rows[rowPTR][PK]];
                                    if (readRows.length && readRows[0].rowPK) {
                                        indexedRows = indexedRows
                                            .concat(readRows[0].rowPK)
                                            .filter(function (item, pos) {
                                            return indexedRows.indexOf(item) === pos;
                                        });
                                    }
                                    t._upsert(idxTbl_1, rowKey, {
                                        id: rows[rowPTR][key_1],
                                        rowPK: indexedRows
                                    }, function () {
                                        ptr3_1++;
                                        lie_ts_1.setFast(step3_1);
                                    });
                                }, true);
                            });
                        }
                        else {
                            rowPTR++;
                            lie_ts_1.setFast(step2);
                        }
                    };
                    step3_1();
                }
                else {
                    complete();
                }
            };
            step2();
        });
    };
    _NanoSQL_Storage.prototype._rebuildTries = function (callBack) {
        var rebuildJob = {};
        var jobLength = 0;
        var t = this;
        Object.keys(t._tables).forEach(function (tableID) {
            var tableName = t._tables[tableID]._name;
            if (tableName.indexOf("_") !== 0) {
                if (t._tables[tableID]._trieColumns.length) {
                    rebuildJob[tableName] = t._tables[tableID]._trieColumns;
                    jobLength++;
                }
            }
        });
        if (jobLength === 0) {
            callBack();
        }
        else {
            var tables_1 = Object.keys(rebuildJob);
            var ptr_1 = 0;
            var step_1 = function () {
                if (ptr_1 < tables_1.length) {
                    var ta_2 = index_1.NanoSQLInstance._hash(tables_1[ptr_1]);
                    t._read(tables_1[ptr_1], "all", function (rows) {
                        rows.forEach(function (row, i) {
                            rebuildJob[tables_1[ptr_1]].forEach(function (key) {
                                if (row[key])
                                    t._tables[ta_2]._trieObjects[key].addWord(row[key]);
                            });
                        });
                        ptr_1++;
                        step_1();
                    });
                }
                else {
                    callBack();
                }
            };
            step_1();
        }
    };
    _NanoSQL_Storage.prototype._execTransaction = function (transactionID) {
        var t = this;
        return new lie_ts_1.Promise(function (res, rej) {
            var complete = function () {
                if (t._transactionData[transactionID]) {
                    lie_ts_1.Promise.all(Object.keys(t._transactionData[transactionID]).map(function (table) {
                        return new lie_ts_1.Promise(function (resolve) {
                            t._rebuildSecondaryIndex(table, resolve);
                        });
                    })).then(function () {
                        res([
                            {
                                msg: Object.keys(t._transactionData[transactionID]).length +
                                    " transactions performed."
                            }
                        ], t._parent._parent);
                        delete t._transactionData[transactionID];
                    });
                }
                else {
                    res([{ msg: "0 transactions performed." }], t._parent._parent);
                }
            };
            switch (t._mode) {
                default:
                    complete();
            }
        });
    };
    _NanoSQL_Storage.prototype._clear = function (type, complete) {
        var t = this;
        var tables = Object.keys(t._tables).map(function (k) { return t._tables[k]._name; });
        var setupNewHist = function () {
            lie_ts_1.Promise.all(tables.map(function (table) {
                return new lie_ts_1.Promise(function (res, rej) {
                    if (table.indexOf("_hist__meta") !== -1) {
                        var referenceTable_1 = String(table)
                            .slice(1)
                            .replace("_hist__meta", "");
                        var ta = index_1.NanoSQLInstance._hash(referenceTable_1);
                        var pk_1 = t._tables[ta]._pk;
                        t._upsert("_" + referenceTable_1 + "_hist__data", 0, null);
                        t._tables["_" + referenceTable_1 + "_hist__data"]._index.push(0);
                        t._read(referenceTable_1, "all", function (rows) {
                            rows.forEach(function (row, i) {
                                var hist = {};
                                hist[db_index_1._str(2)] = 0;
                                hist[db_index_1._str(3)] = [i + 1];
                                t._upsert(table, row[pk_1], hist);
                                t._upsert("_" + referenceTable_1 + "_hist__data", i + 1, row);
                            });
                            res();
                        });
                    }
                    else {
                        res();
                    }
                });
            })).then(function () {
                complete();
            });
        };
        lie_ts_1.Promise.all(tables.map(function (table) {
            return new lie_ts_1.Promise(function (res, rej) {
                var deleteTable = false;
                if (type === "hist" &&
                    (table === db_index_1._str(1) ||
                        table.indexOf("_hist__meta") !== -1 ||
                        table.indexOf("_hist__data") !== -1)) {
                    deleteTable = true;
                }
                if (type === "all" && table !== "_utility") {
                    deleteTable = true;
                }
                if (deleteTable) {
                    t._delete(table, "all", function () {
                        if (table.indexOf("_hist__data") !== -1) {
                            t._upsert(table, 0, null);
                        }
                        res();
                    });
                }
                else {
                    res();
                }
            });
        })).then(function () {
            setupNewHist();
        });
    };
    _NanoSQL_Storage.prototype._delete = function (tableName, rowID, callBack, transactionID) {
        var t = this;
        var editingHistory = false;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        var deleteRowIDS = [];
        if (rowID === "all") {
            deleteRowIDS = t._tables[ta]._index.slice().filter(function (i) { return i; });
            t._tables[ta]._index = [];
            t._tables[ta]._trieIndex = new prefix_trie_ts_1.Trie([]);
        }
        else {
            deleteRowIDS.push(rowID);
            t._tables[ta]._trieIndex.removeWord(String(rowID));
            t._tables[ta]._index.splice(t._tables[ta]._index.indexOf(rowID), 1);
        }
        if (t._storeMemory) {
            if (rowID === "all") {
                t._tables[ta]._rows = {};
            }
            else {
                delete t._tables[ta]._rows[rowID];
            }
        }
        index_1.NanoSQLInstance.chain(deleteRowIDS.map(function (rowID) {
            return function (nextRow) {
                if (transactionID) {
                    if (!t._transactionData[transactionID])
                        t._transactionData[transactionID] = {};
                    if (!t._transactionData[transactionID][tableName]) {
                        t._transactionData[transactionID][tableName] = [];
                    }
                    t._transactionData[transactionID][tableName].push({
                        type: "del",
                        key: rowID,
                        value: ""
                    });
                }
                switch (t._mode) {
                    case 0:
                        nextRow();
                        break;
                    case 1:
                        t._indexedDB
                            .transaction(tableName, "readwrite")
                            .objectStore(tableName)
                            .delete(rowID);
                        nextRow();
                        break;
                    case 2:
                        localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));
                        localStorage.removeItem(tableName + "-" + String(rowID));
                        nextRow();
                        break;
                    default:
                        nextRow();
                }
            };
        }))(function () {
            if (callBack)
                callBack(true);
        });
    };
    _NanoSQL_Storage.prototype._updateSecondaryIndex = function (newRow, tableID, callBack) {
        var t = this;
        var table = t._tables[tableID];
        var oldRow = {};
        if (table._name.indexOf("_") !== 0) {
            var emptyColumns_1 = [];
            var updateIndex_1 = function (tableName, rowID, key, complete) {
                t._read(tableName, rowID, function (rows) {
                    var indexedRows = [];
                    if (rows.length && rows[0].rowPK)
                        indexedRows = indexedRows.concat(rows[0].rowPK);
                    indexedRows.push(newRow[table._pk]);
                    indexedRows = indexedRows.filter(function (item, pos, arr) {
                        return arr.indexOf(item) === pos;
                    });
                    if (indexedRows.length) {
                        t._upsert(tableName, rowID, {
                            id: rowID,
                            rowPK: indexedRows
                        }, complete);
                    }
                    else {
                        emptyColumns_1.push(key);
                        t._delete(tableName, rowID, complete);
                    }
                }, true);
            };
            table._trieColumns.forEach(function (key) {
                var word = String(newRow[key]).toLocaleLowerCase();
                if (emptyColumns_1.indexOf(key) !== -1) {
                    t._tables[tableID]._trieObjects[key].removeWord(word);
                }
                else {
                    t._tables[tableID]._trieObjects[key].addWord(word);
                }
            });
            if (table._secondaryIndexes.length) {
                lie_ts_1.Promise.all(table._secondaryIndexes.map(function (key) {
                    return new lie_ts_1.Promise(function (res, rej) {
                        var idxTable = "_" + table._name + "_idx_" + key;
                        var rowID = String(newRow[key]).toLowerCase();
                        var oldRowID = String(oldRow[key]).toLowerCase();
                        if (rowID !== oldRowID && oldRow[key]) {
                            t._read(idxTable, oldRowID, function (oldRowIndex) {
                                var indexes = oldRowIndex[0]
                                    ? index_1._assign(oldRowIndex[0].rowPK || [])
                                    : [];
                                var oldRowLoc = indexes.indexOf(oldRowID[table._pk]);
                                if (oldRowLoc !== -1) {
                                    indexes.splice(oldRowLoc, 1);
                                    t._upsert(idxTable, oldRowID, {
                                        id: oldRowID,
                                        rowPK: indexes
                                    }, function () {
                                        updateIndex_1(idxTable, rowID, key, res);
                                    });
                                }
                                else {
                                    updateIndex_1(idxTable, rowID, key, res);
                                }
                            });
                        }
                        else {
                            if (newRow[key] !== undefined) {
                                updateIndex_1(idxTable, rowID, key, res);
                            }
                            else {
                                if (callBack)
                                    callBack();
                            }
                        }
                    });
                })).then(callBack);
            }
            else {
                if (callBack)
                    callBack();
            }
        }
        else {
            if (callBack)
                callBack();
        }
    };
    _NanoSQL_Storage.prototype._addHistoryRow = function (tableID, rowData, transactionID, complete) {
        var t = this;
        var table = t._tables[tableID];
        var histTableName = "_" + table._name + "_hist__data";
        var histTable = t._tables[index_1.NanoSQLInstance._hash(histTableName)];
        rowData = index_1._assign(rowData);
        var pk = histTable._index[histTable._index.length - 1] + 1;
        histTable._index.push(pk);
        rowData[db_index_1._str(4)] = pk;
        t._upsert(histTableName, pk, rowData, function () {
            complete(pk);
        }, transactionID);
    };
    _NanoSQL_Storage.prototype._addHistoryPoint = function (tableID, updatedPKs, describe, complete) {
        var t = this;
        if (!t._doHistory) {
            complete();
            return;
        }
        var makeRecord = function () {
            t._utility("w", "historyLength", t._historyLength);
            t._utility("w", "historyPoint", t._historyPoint);
            var histPoint = t._historyLength - t._historyPoint;
            t._upsert(db_index_1._str(1), null, {
                historyPoint: histPoint,
                tableID: tableID,
                rowKeys: updatedPKs,
                type: describe
            }, function (rowID) {
                if (!t._historyPointIndex[histPoint]) {
                    t._historyPointIndex[histPoint] = [];
                }
                t._historyPointIndex[histPoint].push(rowID);
                complete();
            });
        };
        if (t._historyPoint === 0) {
            t._historyLength++;
            makeRecord();
        }
        else if (t._historyPoint > 0) {
            var histPoints = [];
            var k_1 = 0, j = 0;
            var startIndex = t._historyLength - t._historyPoint + 1;
            while (t._historyPointIndex[startIndex]) {
                histPoints = histPoints.concat(t._historyPointIndex[startIndex].slice());
                delete t._historyPointIndex[startIndex];
                startIndex++;
            }
            t._readArray(db_index_1._str(1), histPoints, function (historyPoints) {
                index_1.NanoSQLInstance.chain(historyPoints.map(function (histPoint) {
                    return function (nextHistPoint) {
                        var tableName = t._tables[histPoint.tableID]._name;
                        index_1.NanoSQLInstance.chain(histPoint.rowKeys.map(function (rowKey) {
                            return function (nextRowKey) {
                                t._read("_" + tableName + "_hist__meta", rowKey, function (rows) {
                                    rows[0] = index_1._assign(rows[0]);
                                    rows[0][db_index_1._str(2)] = 0;
                                    var del = rows[0][db_index_1._str(3)].shift();
                                    t._upsert("_" + tableName + "_hist__meta", rowKey, rows[0], function () {
                                        if (del) {
                                            t._delete("_" + tableName + "_hist__data", del, function () {
                                                k_1++;
                                                nextRowKey();
                                            });
                                        }
                                        else {
                                            k_1++;
                                            nextRowKey();
                                        }
                                    });
                                });
                            };
                        }))(function () {
                            t._delete(db_index_1._str(1), histPoint.id, nextHistPoint);
                        });
                    };
                }))(function () {
                    t._historyLength -= t._historyPoint;
                    t._historyLength++;
                    t._historyPoint = 0;
                    makeRecord();
                });
            });
        }
    };
    _NanoSQL_Storage.prototype._generateID = function (type, tableHash) {
        switch (type) {
            case "int":
                return this._tables[tableHash]._incriment++;
            case "uuid":
                return index_1.NanoSQLInstance.uuid();
            case "timeId":
                return index_1.NanoSQLInstance.timeid();
            case "timeIdms":
                return index_1.NanoSQLInstance.timeid(true);
        }
        return "";
    };
    _NanoSQL_Storage.prototype._upsert = function (tableName, rowID, rowData, callBack, transactionID) {
        var t = this;
        rowData = index_1._assign(rowData);
        var ta = index_1.NanoSQLInstance._hash(tableName);
        var pk = t._tables[ta]._pk;
        if (tableName.indexOf("_hist__data") !== -1 && rowData) {
            rowID = rowData[db_index_1._str(4)];
        }
        else {
            if (rowID === undefined || rowID === null) {
                t._models[ta].forEach(function (m) {
                    if (m.props && m.props.indexOf("pk") !== -1) {
                        rowID = t._generateID(m.type, ta);
                    }
                });
                if (!rowID)
                    rowID =
                        parseInt(t._tables[ta]._index[t._tables[ta]._index.length - 1] || "0") + 1;
            }
            if (pk && pk.length && rowData && rowData[pk] === undefined) {
                rowData[pk] = rowID;
            }
        }
        rowID = rowID !== undefined && rowID !== null ? rowID : -1;
        if (!t._tables[ta]._trieIndex.getPrefix(String(rowID)).length) {
            t._tables[ta]._trieIndex.addWord(String(rowID));
            t._tables[ta]._index.push(rowID);
        }
        if (transactionID) {
            if (!t._transactionData[transactionID])
                t._transactionData[transactionID] = {};
            if (!t._transactionData[transactionID][tableName]) {
                t._transactionData[transactionID][tableName] = [];
            }
            t._transactionData[transactionID][tableName].push({
                type: tableName.indexOf("_hist__data") !== -1
                    ? "put"
                    : !rowData ? "del" : "put",
                key: rowID,
                value: rowData ? JSON.stringify(rowData) : ""
            });
        }
        if (t._storeMemory) {
            t._tables[ta]._rows[rowID] = t._parent._deepFreeze(rowData, ta);
            if (t._mode === 0 && callBack)
                return callBack(rowID);
        }
        switch (t._mode) {
            case 1:
                var transaction = t._indexedDB.transaction(tableName, "readwrite");
                var store = transaction.objectStore(tableName);
                if (pk.length && rowData) {
                    store.put(rowData);
                }
                else {
                    if (tableName.indexOf("_hist__data") !== -1) {
                        store.put(rowData, rowID);
                    }
                    else {
                        if (rowData)
                            store.put(rowData);
                        if (!rowData)
                            store.delete(rowID);
                    }
                }
                transaction.oncomplete = function () {
                    if (callBack)
                        callBack(rowID);
                };
                break;
            case 2:
                localStorage.setItem(tableName + "-" + String(rowID), rowData ? JSON.stringify(rowData) : "");
                localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));
                if (callBack)
                    callBack(rowID);
                break;
        }
    };
    _NanoSQL_Storage.prototype._indexRead = function (tableName, rows, callBack, getIndex) {
        var _this = this;
        var isSecondIndex = tableName.indexOf("_") === 0 && tableName.indexOf("_idx_") !== -1;
        if (!isSecondIndex || getIndex) {
            callBack(rows);
        }
        else {
            var parentTable_1 = !isSecondIndex
                ? ""
                : tableName.slice(1, tableName.indexOf("_idx_"));
            var allRowIDs_1 = rows.reduce(function (prev, cur) {
                return prev.concat(cur.rowPK);
            }, []);
            var resultRows_1 = [];
            var ptr_2 = 0;
            var step_2 = function () {
                if (ptr_2 < allRowIDs_1.length) {
                    _this._read(parentTable_1, allRowIDs_1[ptr_2], function (rows) {
                        resultRows_1 = resultRows_1.concat(rows);
                        ptr_2++;
                        step_2();
                    });
                }
                else {
                    callBack(resultRows_1);
                }
            };
            step_2();
        }
    };
    _NanoSQL_Storage.prototype._readArray = function (tableName, pkArray, callBack) {
        var _this = this;
        var rows = [];
        var ptr = 0;
        var readRow = function () {
            if (ptr < pkArray.length) {
                _this._read(tableName, pkArray[ptr], function (newRows) {
                    rows = rows.concat(newRows);
                    ptr++;
                    readRow();
                });
            }
            else {
                callBack(rows);
            }
        };
        readRow();
    };
    _NanoSQL_Storage.prototype._readRange = function (tableName, key, between, callBack) {
        var _this = this;
        var t = this;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        if (t._mode === 0 || t._mode === 2) {
            var startPtr_1 = t._tables[ta]._index.indexOf(between[0]);
            var resultRows_2 = [];
            if (startPtr_1 === -1) {
                callBack(resultRows_2);
                return;
            }
            var stepRead_1 = function () {
                var pk = t._tables[ta]._index[startPtr_1];
                if (!pk) {
                    callBack(resultRows_2);
                    return;
                }
                if (pk <= between[1]) {
                    t._read(tableName, pk, function (rows) {
                        resultRows_2 = resultRows_2.concat(rows);
                        startPtr_1++;
                        stepRead_1();
                    });
                }
                else {
                    callBack(resultRows_2);
                }
            };
            stepRead_1();
            return;
        }
        var rows = [];
        switch (t._mode) {
            case 1:
                var transaction = t._indexedDB.transaction(tableName, "readonly");
                var store = transaction.objectStore(tableName);
                var cursorRequest = store.openCursor(IDBKeyRange.bound(between[0], between[1]));
                transaction.oncomplete = function () {
                    _this._indexRead(tableName, rows, callBack);
                };
                cursorRequest.onsuccess = function (evt) {
                    var cursor = evt.target.result;
                    if (cursor) {
                        rows.push(cursor.value);
                        cursor.continue();
                    }
                };
                break;
        }
    };
    _NanoSQL_Storage.prototype._read = function (tableName, row, callBack, readIndex) {
        var _this = this;
        var t = this;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        if (t._storeMemory) {
            var rows_1 = t._tables[ta]._rows;
            if (row === "all" || typeof row === "function") {
                var allRows = Object.keys(rows_1).map(function (r) { return rows_1[r]; });
                if (row === "all") {
                    t._indexRead(tableName, allRows.filter(function (r) { return r; }), callBack, readIndex);
                }
                else {
                    t._indexRead(tableName, allRows.filter(function (r) { return row(r); }), callBack, readIndex);
                }
            }
            else {
                t._indexRead(tableName, [rows_1[row]].filter(function (r) { return r; }), callBack, readIndex);
            }
            return;
        }
        switch (t._mode) {
            case 1:
                var transaction = t._indexedDB.transaction(tableName, "readonly");
                var store = transaction.objectStore(tableName);
                if (row === "all" || typeof row === "function") {
                    var cursorRequest = store.openCursor();
                    var rows_2 = [];
                    transaction.oncomplete = function () {
                        _this._indexRead(tableName, rows_2, callBack, readIndex);
                    };
                    cursorRequest.onsuccess = function (evt) {
                        var cursor = evt.target.result;
                        if (cursor) {
                            if (row !== "all") {
                                if (row(cursor.value))
                                    rows_2.push(cursor.value);
                            }
                            else {
                                rows_2.push(cursor.value);
                            }
                            cursor.continue();
                        }
                    };
                }
                else {
                    var singleReq_1 = store.get(row);
                    singleReq_1.onsuccess = function (event) {
                        _this._indexRead(tableName, [singleReq_1.result], callBack, readIndex);
                    };
                }
                break;
            case 2:
                if (row === "all" || typeof row === "function") {
                    var rows = t._tables[ta]._index.map(function (idx) {
                        var item = localStorage.getItem(tableName + "-" + idx);
                        return item && item.length ? JSON.parse(item) : null;
                    });
                    if (row !== "all") {
                        this._indexRead(tableName, rows.filter(function (r) { return row(r); }), callBack, readIndex);
                    }
                    else {
                        this._indexRead(tableName, rows, callBack, readIndex);
                    }
                }
                else {
                    var item = localStorage.getItem(tableName + "-" + row);
                    this._indexRead(tableName, [item && item.length ? JSON.parse(item) : null], callBack, readIndex);
                }
                break;
        }
    };
    _NanoSQL_Storage.prototype._utility = function (type, key, value) {
        var t = this;
        if (type === "r") {
            if (t._utilityTable[key]) {
                return t._utilityTable[key].value;
            }
            else {
                return null;
            }
        }
        else {
            t._upsert(db_index_1._str(0), key, { key: key, value: value });
            t._utility[key] = {
                key: key,
                value: value
            };
            return value;
        }
    };
    _NanoSQL_Storage.prototype._newTable = function (tableName, dataModels) {
        var t = this;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        t._models[ta] = dataModels;
        t._parent._queryCache[ta] = {};
        t._tables[ta] = {
            _pk: "",
            _pkType: "",
            _keys: [],
            _relations: [],
            _defaults: [],
            _secondaryIndexes: [],
            _trieColumns: [],
            _trieObjects: {},
            _name: tableName,
            _incriment: 1,
            _index: [],
            _trieIndex: new prefix_trie_ts_1.Trie([]),
            _rows: {}
        };
        var i = t._models[ta].length;
        var keys = [];
        var defaults = [];
        var _loop_1 = function () {
            var p = t._models[ta][i];
            t._tables[ta]._keys.unshift(p.key);
            t._tables[ta]._defaults[i] = p.default;
            if (p.props && p.props.indexOf("pk") >= 0) {
                t._tables[ta]._pk = p.key;
                t._tables[ta]._pkType = p.type;
            }
            if (p.props &&
                (p.props.indexOf("idx") >= 0 || p.props.indexOf("trie") >= 0)) {
                t._tables[ta]._secondaryIndexes.push(p.key);
            }
            if (p.props && p.props.indexOf("trie") >= 0) {
                t._tables[ta]._trieColumns.push(p.key);
                t._tables[ta]._trieObjects[p.key] = new prefix_trie_ts_1.Trie([]);
            }
            if (p.props &&
                t._parent._parent._tableNames.indexOf(p.type.replace("[]", "")) !== -1) {
                var mapTo_1 = "";
                p.props.forEach(function (p) {
                    if (p.indexOf("ref=>") !== -1)
                        mapTo_1 = p.replace("ref=>", "");
                });
                t._tables[ta]._relations.push({
                    _table: p.type.replace("[]", ""),
                    _key: p.key,
                    _mapTo: mapTo_1,
                    _type: p.type.indexOf("[]") === -1 ? "single" : "array"
                });
            }
        };
        while (i--) {
            _loop_1();
        }
        return tableName;
    };
    return _NanoSQL_Storage;
}());
exports._NanoSQL_Storage = _NanoSQL_Storage;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var config = {
    END_WORD: "$",
    PERMS_MIN_LEN: 2,
};
var Trie = (function () {
    function Trie(input) {
        this._trie = Trie._create(input);
    }
    Trie.prototype.addWord = function (word) {
        var reducer = function (previousValue, currentValue, currentIndex, array) {
            return Trie._append(previousValue, currentValue, currentIndex, array);
        };
        var input = word.toLowerCase().split("");
        input.reduce(reducer, this._trie);
        return this;
    };
    Trie.prototype.removeWord = function (word) {
        var _a = Trie._checkPrefix(this._trie, word), prefixFound = _a.prefixFound, prefixNode = _a.prefixNode;
        if (prefixFound) {
            delete prefixNode[config.END_WORD];
        }
        return this;
    };
    Trie.prototype.getWords = function () {
        return Trie._recursePrefix(this._trie, '');
    };
    Trie.prototype.getPrefix = function (strPrefix) {
        strPrefix = strPrefix.toLowerCase();
        if (!this._isPrefix(strPrefix)) {
            return [];
        }
        var prefixNode = Trie._checkPrefix(this._trie, strPrefix).prefixNode;
        return Trie._recursePrefix(prefixNode, strPrefix);
    };
    Trie.prototype._isPrefix = function (prefix) {
        var prefixFound = Trie._checkPrefix(this._trie, prefix).prefixFound;
        return prefixFound;
    };
    Trie._append = function (trie, letter, index, array) {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
        if (index === array.length - 1) {
            trie[config.END_WORD] = 1;
        }
        return trie;
    };
    Trie._checkPrefix = function (prefixNode, prefix) {
        var input = prefix.toLowerCase().split("");
        var prefixFound = input.every(function (letter, index) {
            if (!prefixNode[letter]) {
                return false;
            }
            return prefixNode = prefixNode[letter];
        });
        return {
            prefixFound: prefixFound,
            prefixNode: prefixNode,
        };
    };
    Trie._create = function (input) {
        var trie = input.reduce(function (accumulator, item) {
            item
                .toLowerCase()
                .split("")
                .reduce(Trie._append, accumulator);
            return accumulator;
        }, {});
        return trie;
    };
    Trie._recursePrefix = function (node, prefix, prefixes) {
        if (prefixes === void 0) { prefixes = []; }
        var word = prefix;
        for (var branch in node) {
            if (branch === config.END_WORD) {
                prefixes.push(word);
                word = "";
            }
            Trie._recursePrefix(node[branch], prefix + branch, prefixes);
        }
        return prefixes.sort();
    };
    return Trie;
}());
exports.Trie = Trie;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(0);
var lie_ts_1 = __webpack_require__(1);
var _NanoSQLQuery = (function () {
    function _NanoSQLQuery(table, db, actionOrView) {
        this._db = db;
        this._modifiers = [];
        this._table = table;
        this._AV = actionOrView || "";
    }
    _NanoSQLQuery.prototype.tID = function (transactionID) {
        return this._transactionID = transactionID || 0, this;
    };
    _NanoSQLQuery.prototype.where = function (args) {
        if (!args.length || !Array.isArray(args)) {
            this._error = "Where condition requires an array!";
        }
        return this._addCmd("where", args);
    };
    _NanoSQLQuery.prototype.range = function (limit, offset) {
        return this._addCmd("range", [limit, offset]);
    };
    _NanoSQLQuery.prototype.orm = function (ormArgs) {
        return this._addCmd("orm", ormArgs);
    };
    _NanoSQLQuery.prototype.orderBy = function (args) {
        return this._addCmd("orderby", args);
    };
    _NanoSQLQuery.prototype.groupBy = function (columns) {
        return this._addCmd("groupby", columns);
    };
    _NanoSQLQuery.prototype.having = function (args) {
        if (!args.length || !Array.isArray(args)) {
            this._error = "Having condition requires an array!";
        }
        return this._addCmd("having", args);
    };
    _NanoSQLQuery.prototype.join = function (args) {
        if (!args.table || !args.type) {
            this._error = "Join command requires table and type arguments!";
        }
        return this._addCmd("join", args);
    };
    _NanoSQLQuery.prototype.limit = function (args) {
        return this._addCmd("limit", args);
    };
    _NanoSQLQuery.prototype.trieSearch = function (column, stringToSearch) {
        return this._addCmd("trie", [column, stringToSearch]);
    };
    _NanoSQLQuery.prototype.offset = function (args) {
        return this._addCmd("offset", args);
    };
    _NanoSQLQuery.prototype._addCmd = function (type, args) {
        return this._modifiers.push({ type: type, args: args }), this;
    };
    _NanoSQLQuery.prototype.toCSV = function (headers) {
        var t = this;
        return new lie_ts_1.Promise(function (res, rej) {
            t.exec().then(function (json) {
                json = index_1._assign(json);
                var header = t._action.args.length ? t._action.args.map(function (m) {
                    return t._db._models[t._table].filter(function (f) { return f["key"] === m; })[0];
                }) : t._db._models[t._table];
                if (headers) {
                    json.unshift(header.map(function (h) {
                        return h["key"];
                    }));
                }
                res(json.map(function (row, i) {
                    if (headers && i === 0)
                        return row;
                    return header.map(function (column) {
                        if (row[column["key"]] === undefined) {
                            return "";
                        }
                        else {
                            var columnType = column["type"];
                            if (columnType.indexOf("[]") !== -1)
                                columnType = "any[]";
                            switch (columnType) {
                                case "map":
                                case "any[]":
                                case "array": return '"' + JSON.stringify(row[column["key"]]).replace(/"/g, "'") + '"';
                                case "string":
                                case "safestr": return '"' + row[column["key"]].replace(/"/g, '\"') + '"';
                                default: return row[column["key"]];
                            }
                        }
                    }).join(",");
                }).join("\n"), t);
            });
        });
    };
    _NanoSQLQuery.prototype.manualExec = function (table, modifiers) {
        var t = this;
        t._modifiers = modifiers;
        t._table = table;
        return t.exec();
    };
    _NanoSQLQuery.prototype._triggerEvents = function (table, data, callBack, type, changedRows, changedRowPKS, isError) {
        var t = this;
        if (t._db._hasEvents[table]) {
            t._db.triggerEvent({
                name: t._action.type,
                actionOrView: t._AV,
                table: table,
                query: [t._action].concat(t._modifiers),
                time: new Date().getTime(),
                result: data,
                changeType: type,
                changedRows: changedRows,
                changedRowPKS: changedRowPKS
            }, t._db._triggerEvents);
        }
        callBack(data, t._db);
    };
    _NanoSQLQuery.prototype.exec = function () {
        var t = this;
        var _t = t._table;
        if (t._db._hasEvents[_t]) {
            t._db._triggerEvents = (function () {
                switch (t._action.type) {
                    case "select": return ["*", t._action.type];
                    case "delete":
                    case "upsert":
                    case "drop": return ["*", t._action.type, "change"];
                    default: return ["*"];
                }
            })();
        }
        return new lie_ts_1.Promise(function (res, rej) {
            if (t._error) {
                rej(t._error);
                throw Error;
            }
            if (!t._db.backend) {
                rej();
                throw Error;
            }
            var execArgs = {
                table: _t,
                transactionID: t._transactionID,
                query: [t._action].concat(t._modifiers),
                viewOrAction: t._AV,
                onSuccess: function (rows, type, affectedRows, affectedPKS) {
                    if (t._transactionID) {
                        res(rows, t._db);
                    }
                    else {
                        t._triggerEvents(_t, rows, res, type, affectedRows, affectedPKS, false);
                    }
                },
                onFail: function (err) {
                    if (t._transactionID) {
                        res(err, t._db);
                    }
                    else {
                        t._db._triggerEvents = ["error"];
                        if (rej)
                            t._triggerEvents(_t, err, rej, "error", [], [], true);
                    }
                }
            };
            if (t._db._queryMod) {
                t._db._queryMod(execArgs, function (newArgs) {
                    t._db.backend._exec(newArgs);
                });
            }
            else {
                t._db.backend._exec(execArgs);
            }
        });
    };
    return _NanoSQLQuery;
}());
exports._NanoSQLQuery = _NanoSQLQuery;
var _NanoSQLORMQuery = (function () {
    function _NanoSQLORMQuery(db, table, action, column, relationIDs) {
        this._db = db;
        this._tableName = table;
        this._action = action;
        this._column = column || "";
        this._relationIDs = relationIDs || [];
    }
    _NanoSQLORMQuery.prototype.where = function (args) {
        this._whereArgs = args;
        return this;
    };
    _NanoSQLORMQuery.prototype.rebuild = function (callBack) {
        var t = this;
        var relations = t._db._models[t._tableName].filter(function (m) {
            return t._db._tableNames.indexOf(m.type.replace("[]", "")) !== -1;
        }).map(function (m) {
            var tableName = m.type.replace("[]", "");
            return {
                _key: m.key,
                _tablePK: t._db._models[tableName].reduce(function (prev, cur) {
                    if (cur.props && cur.props.indexOf("pk") !== -1)
                        return cur.key;
                    return prev;
                }, ""),
                _table: tableName,
                _type: m.type.indexOf("[]") === -1 ? "single" : "array"
            };
        });
        var tablePK = t._db._models[t._tableName].reduce(function (prev, cur) {
            if (cur.props && cur.props.indexOf("pk") !== -1)
                return cur.key;
            return prev;
        }, "");
        var ptr = 0;
        var nextRow = function () {
            t._db.table(t._tableName).query("select").range(1, ptr).exec().then(function (rows) {
                if (rows.length) {
                    index_1.NanoSQLInstance.chain(relations.map(function (r) {
                        return function (nextRelation) {
                            var ids;
                            if (rows[0][r._key] === undefined) {
                                ids = r._type === "single" ? "" : [];
                            }
                            else {
                                ids = index_1._assign(rows[0][r._key]);
                            }
                            if (r._type === "single")
                                ids = [ids];
                            ids = ids.filter(function (v, i, s) {
                                return s.indexOf(v) === i;
                            });
                            t._db.table(r._table).query("select").where([r._tablePK, "IN", ids]).exec().then(function (childRows) {
                                var activeIDs = childRows.length ? childRows.map(function (row) { return row[r._tablePK]; }) : [];
                                return t._db.table(t._tableName).updateORM("set", r._key, activeIDs).where([tablePK, "=", rows[0][tablePK]]).exec();
                            }).then(function () {
                                nextRelation();
                            });
                        };
                    }))(function () {
                        ptr++;
                        nextRow();
                    });
                }
                else {
                    callBack(ptr);
                }
            });
        };
        nextRow();
    };
    _NanoSQLORMQuery.prototype.tID = function (transactionID) {
        return this._transactionID = transactionID || 0, this;
    };
    _NanoSQLORMQuery.prototype.exec = function () {
        var t = this;
        return new lie_ts_1.Promise(function (res, rej) {
            if (t._action === "rebuild") {
                return t.rebuild(res);
            }
            var pk = t._db._models[t._tableName].filter(function (m) {
                return m.props && m.props.indexOf("pk") !== -1;
            })[0].key;
            var rowModel = t._db._models[t._tableName].filter(function (m) { return m.key === t._column; })[0];
            var relationTable = rowModel.type.replace("[]", "");
            var relationPK = t._db._models[relationTable].filter(function (m) {
                return m.props && m.props.indexOf("pk") !== -1;
            })[0].key;
            var isArrayRelation = rowModel.type.indexOf("[]") !== -1;
            var mapTo = rowModel.props && rowModel.props.filter(function (p) { return p.indexOf("ref=>") !== -1; })[0];
            var mapToIsArray = "single";
            if (mapTo) {
                mapTo = mapTo.replace("ref=>", "");
                mapToIsArray = t._db._models[relationTable].filter(function (m) { return m.key === mapTo; })[0].type.indexOf("[]") === -1 ? "single" : "array";
            }
            if (!pk || !pk.length || !relationPK || !relationPK.length) {
                rej("Relation models require a primary key!");
                return;
            }
            var query = t._db.table(t._tableName).query("select");
            if (t._whereArgs)
                query.where(t._whereArgs);
            query.exec().then(function (rows) {
                index_1.NanoSQLInstance.chain(rows.map(function (rowData) {
                    return function (nextRow) {
                        var newRow = index_1._assign(rowData);
                        var oldRelations = [];
                        if (newRow[t._column] !== undefined)
                            oldRelations = index_1._assign(newRow[t._column]);
                        if (!Array.isArray(oldRelations))
                            oldRelations = [oldRelations];
                        switch (t._action) {
                            case "set":
                            case "add":
                                if (isArrayRelation) {
                                    if (newRow[t._column] === undefined)
                                        newRow[t._column] = [];
                                    if (!Array.isArray(newRow[t._column]))
                                        newRow[t._column] = [];
                                    if (t._action === "set") {
                                        newRow[t._column] = t._relationIDs;
                                    }
                                    else {
                                        newRow[t._column] = newRow[t._column].concat(t._relationIDs);
                                    }
                                    newRow[t._column] = newRow[t._column].filter(function (v, i, s) {
                                        return s.indexOf(v) === i;
                                    });
                                }
                                else {
                                    newRow[t._column] = t._relationIDs[0];
                                }
                                if (t._action === "set") {
                                    oldRelations = oldRelations.filter(function (item) {
                                        return t._relationIDs.indexOf(item) === -1;
                                    });
                                }
                                else {
                                    oldRelations = [];
                                }
                                break;
                            case "delete":
                                if (isArrayRelation) {
                                    t._relationIDs.forEach(function (relId) {
                                        var loc = newRow[t._column].indexOf(relId);
                                        if (loc !== -1)
                                            newRow[t._column].splice(loc, 1);
                                    });
                                }
                                else {
                                    newRow[t._column] = "";
                                }
                                break;
                            case "drop":
                                newRow[t._column] = isArrayRelation ? [] : undefined;
                                break;
                        }
                        var updateRow = function (newRow, callBack) {
                            t._db.table(relationTable).query("upsert", newRow, true).exec().then(callBack);
                        };
                        var removeOldRelations = function (callBack) {
                            index_1.NanoSQLInstance.chain(oldRelations.map(function (oldRelID) {
                                return function (nextRelation) {
                                    t._db.table(relationTable).query("select").where([relationPK, "=", oldRelID]).exec().then(function (relateRows) {
                                        if (!relateRows.length) {
                                            nextRelation();
                                            return;
                                        }
                                        var modifyRow = index_1._assign(relateRows[0]);
                                        if (Array.isArray(modifyRow[mapTo])) {
                                            var idx = modifyRow[mapTo].indexOf(rowData[pk]);
                                            if (idx !== -1) {
                                                modifyRow[mapTo].splice(idx, 1);
                                            }
                                        }
                                        else {
                                            modifyRow[mapTo] = "";
                                        }
                                        updateRow(modifyRow, function () {
                                            nextRelation();
                                        });
                                    });
                                };
                            }))(function () {
                                callBack();
                            });
                        };
                        t._db.table(t._tableName).query("upsert", newRow, true).exec().then(function () {
                            if (mapTo) {
                                switch (t._action) {
                                    case "set":
                                    case "add":
                                        removeOldRelations(function () {
                                            index_1.NanoSQLInstance.chain(t._relationIDs.map(function (relID) {
                                                return function (nextRelation) {
                                                    t._db.table(relationTable).query("select").where([relationPK, "=", relID]).exec().then(function (relateRows) {
                                                        if (!relateRows.length) {
                                                            nextRelation();
                                                            return;
                                                        }
                                                        var modifyRow = index_1._assign(relateRows[0]);
                                                        if (modifyRow[mapTo] === undefined)
                                                            modifyRow[mapTo] = mapToIsArray === "array" ? [] : "";
                                                        if (mapToIsArray === "array") {
                                                            if (!Array.isArray(modifyRow[mapTo]))
                                                                modifyRow[mapTo] = [];
                                                            modifyRow[mapTo].push(rowData[pk]);
                                                            modifyRow[mapTo] = modifyRow[mapTo].filter(function (v, i, s) {
                                                                return s.indexOf(v) === i;
                                                            });
                                                            updateRow(modifyRow, function () {
                                                                nextRelation();
                                                            });
                                                        }
                                                        else {
                                                            modifyRow[mapTo] = rowData[pk];
                                                            updateRow(modifyRow, function () {
                                                                nextRelation();
                                                            });
                                                        }
                                                    });
                                                };
                                            }))(nextRow);
                                        });
                                        break;
                                    case "delete":
                                    case "drop":
                                        removeOldRelations(nextRow);
                                        break;
                                }
                            }
                            else {
                                nextRow();
                            }
                        });
                    };
                }))(res);
            });
        });
    };
    return _NanoSQLORMQuery;
}());
exports._NanoSQLORMQuery = _NanoSQLORMQuery;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var _NanoSQLTransactionORMQuery = (function () {
    function _NanoSQLTransactionORMQuery(queries, table, action, column, relationIDs) {
        this._queries = queries;
        this._query = {
            type: "orm",
            table: table,
            action: action,
            column: column,
            relationIDs: relationIDs
        };
    }
    _NanoSQLTransactionORMQuery.prototype.where = function (args) {
        this._query.where = args;
        return this;
    };
    _NanoSQLTransactionORMQuery.prototype.exec = function () {
        this._queries.push(this._query);
    };
    return _NanoSQLTransactionORMQuery;
}());
exports._NanoSQLTransactionORMQuery = _NanoSQLTransactionORMQuery;
var _NanoSQLTransactionQuery = (function () {
    function _NanoSQLTransactionQuery(action, args, table, queries) {
        this._action = action;
        this._actionArgs = args;
        this._modifiers = [];
        this._table = table;
        this._queries = queries;
    }
    _NanoSQLTransactionQuery.prototype.where = function (args) {
        return this._addCmd("where", args);
    };
    _NanoSQLTransactionQuery.prototype.orm = function (ormArgs) {
        return this._addCmd("orm", ormArgs);
    };
    _NanoSQLTransactionQuery.prototype._addCmd = function (type, args) {
        return this._modifiers.push({ type: type, args: args }), this;
    };
    _NanoSQLTransactionQuery.prototype.exec = function () {
        this._queries.push({
            type: "std",
            action: this._action,
            actionArgs: this._actionArgs,
            table: this._table,
            query: this._modifiers
        });
    };
    return _NanoSQLTransactionQuery;
}());
exports._NanoSQLTransactionQuery = _NanoSQLTransactionQuery;


/***/ })
/******/ ]);
});