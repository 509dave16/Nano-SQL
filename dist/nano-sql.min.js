(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var immutable_store_1 = __webpack_require__(2);
var lie_ts_1 = __webpack_require__(1);
exports._assign = function (obj) {
    return JSON.parse(JSON.stringify(obj));
};
var NanoSQLInstance = (function () {
    function NanoSQLInstance() {
        var t = this;
        t._actions = {};
        t._views = {};
        t._models = {};
        t._query = [];
        t._preConnectExtend = [];
        t._events = ["change", "delete", "upsert", "drop", "select", "error"];
        t._callbacks = {};
        t._hasEvents = {};
        t._callbacks["*"] = {};
        var i = t._events.length;
        while (i--) {
            t._callbacks["*"][t._events[i]] = [];
        }
        t._functions = {};
        t._rowFilters = {};
    }
    NanoSQLInstance.prototype.from = function (table) {
        if (table)
            this._selectedTable = table, this.activeTable = table;
        return this;
    };
    NanoSQLInstance.prototype.connect = function (backend) {
        var _this = this;
        var t = this;
        if (t.backend) {
            return new lie_ts_1.Promise(function (res, rej) {
                rej();
                throw Error();
            });
        }
        t.backend = backend || new immutable_store_1._NanoSQLImmuDB();
        return new lie_ts_1.Promise(function (res, rej) {
            t.backend._connect({
                _models: t._models,
                _actions: t._actions,
                _views: t._views,
                _functions: t._functions,
                _config: t._preConnectExtend,
                _parent: _this,
                _onSuccess: function (result) {
                    res(result, t);
                },
                _onFail: function (rejected) {
                    if (rej)
                        rej(rejected, t);
                }
            });
        });
    };
    NanoSQLInstance.prototype.on = function (actions, callBack) {
        var t = this;
        var l = t._selectedTable;
        var i = 0;
        var a = actions.split(" ");
        if (!t._callbacks[l]) {
            t._callbacks[l] = {};
            t._callbacks[l]["*"] = [];
            while (i--) {
                t._callbacks[l][t._events[i]] = [];
            }
        }
        i = a.length;
        while (i--) {
            if (t._events.indexOf(a[i]) !== -1) {
                t._callbacks[l][a[i]].push(callBack);
            }
        }
        t._refreshEventChecker();
        return t;
    };
    NanoSQLInstance.prototype.off = function (callBack) {
        var t = this;
        for (var key in t._callbacks) {
            for (var key2 in t._callbacks[key]) {
                t._callbacks[key][key2] = t._callbacks[key][key2].filter(function (cBs) {
                    return cBs !== callBack;
                });
            }
        }
        t._refreshEventChecker();
        return t;
    };
    NanoSQLInstance.prototype._refreshEventChecker = function () {
        var _this = this;
        this._hasEvents = {};
        Object.keys(this._models).concat(["*"]).forEach(function (table) {
            _this._hasEvents[table] = _this._events.reduce(function (prev, cur) {
                return prev + _this._callbacks[table][cur].length;
            }, 0) > 0;
        });
    };
    NanoSQLInstance.prototype.model = function (dataModel) {
        var t = this;
        var l = t._selectedTable;
        var i = t._events.length;
        if (!t._callbacks[l]) {
            t._callbacks[l] = {};
            t._callbacks[l]["*"] = [];
            while (i--) {
                t._callbacks[l][t._events[i]] = [];
            }
        }
        t._models[l] = dataModel;
        t._views[l] = [];
        t._actions[l] = [];
        return t;
    };
    NanoSQLInstance.prototype.views = function (viewArray) {
        return this._views[this._selectedTable] = viewArray, this;
    };
    NanoSQLInstance.prototype.getView = function (viewName, viewArgs) {
        if (viewArgs === void 0) { viewArgs = {}; }
        var t = this;
        var l = t._selectedTable;
        var selView;
        var i = t._views[l].length;
        while (i--) {
            if (t._views[l][i].name === viewName) {
                selView = t._views[l][i];
            }
        }
        if (!selView)
            throw Error;
        t._activeActionOrView = viewName;
        return selView.call.apply(t, [t._cleanArgs(selView.args ? selView.args : [], viewArgs), t]);
    };
    NanoSQLInstance.prototype._cleanArgs = function (argDeclarations, args) {
        var t = this;
        var l = t._selectedTable;
        var a = {};
        var i = argDeclarations.length ? argDeclarations.length : -1;
        if (i > 0) {
            while (i--) {
                var k2 = argDeclarations[i].split(":");
                if (k2.length > 1) {
                    a[k2[0]] = t._cast(k2[1], args[k2[0]] || null);
                }
                else {
                    a[k2[0]] = args[k2[0]] || null;
                }
            }
        }
        return a;
    };
    NanoSQLInstance.prototype._cast = function (type, val) {
        var t = typeof val;
        var types = {
            "string": t !== "string" ? String(val || "") : val,
            "int": t !== "number" || val % 1 !== 0 ? parseInt(val || 0) : val,
            "float": t !== "number" ? parseFloat(val || 0) : val,
            "array": Array.isArray(val) ? exports._assign(val || []) : [],
            "map": t === 'object' ? exports._assign(val || {}) : {},
            "bool": val === true
        };
        return types[type] || val;
    };
    NanoSQLInstance.prototype.actions = function (actionArray) {
        return this._actions[this._selectedTable] = actionArray, this;
    };
    NanoSQLInstance.prototype.doAction = function (actionName, actionArgs) {
        if (actionArgs === void 0) { actionArgs = {}; }
        var t = this;
        var l = t._selectedTable;
        var selAction;
        var i = t._actions[l].length;
        while (i--) {
            if (t._actions[l][i].name === actionName) {
                selAction = t._actions[l][i];
            }
        }
        if (!selAction)
            throw Error;
        t._activeActionOrView = actionName;
        return selAction.call.apply(t, [t._cleanArgs(selAction.args ? selAction.args : [], actionArgs), t]);
    };
    NanoSQLInstance.prototype.newFunction = function (functionName, functionType, filterFunction) {
        return this._functions[functionName] = { type: functionType, call: filterFunction }, this;
    };
    NanoSQLInstance.prototype.query = function (action, args) {
        var _this = this;
        this._query = [];
        var a = action.toLowerCase();
        if (["select", "upsert", "delete", "drop", "show tables", "describe"].indexOf(a) !== -1) {
            var newArgs_1 = args || (a === "select" || a === "delete" ? [] : {});
            if (action === "upsert") {
                var inputArgs_1 = {};
                this._models[this._selectedTable].forEach(function (model) {
                    if (newArgs_1[model.key]) {
                        inputArgs_1[model.key] = _this._cast(model.type, newArgs_1[model.key]);
                    }
                });
                if (this._rowFilters[this._selectedTable]) {
                    inputArgs_1 = this._rowFilters[this._selectedTable](inputArgs_1);
                }
                newArgs_1 = inputArgs_1;
            }
            this._query.push({ type: a, args: newArgs_1 });
        }
        else {
            throw Error;
        }
        return this;
    };
    NanoSQLInstance.prototype.where = function (args) {
        return this._addCmd("where", args);
    };
    NanoSQLInstance.prototype.orderBy = function (args) {
        return this._addCmd("orderby", args);
    };
    NanoSQLInstance.prototype.groupBy = function (columns) {
        return this._addCmd("groupby", columns);
    };
    NanoSQLInstance.prototype.having = function (args) {
        return this._addCmd("having", args);
    };
    NanoSQLInstance.prototype.join = function (args) {
        return this._addCmd("join", args);
    };
    NanoSQLInstance.prototype.limit = function (args) {
        return this._addCmd("limit", args);
    };
    NanoSQLInstance.prototype.offset = function (args) {
        return this._addCmd("offset", args);
    };
    NanoSQLInstance.prototype._addCmd = function (type, args) {
        return this._query.push({ type: type, args: args }), this;
    };
    NanoSQLInstance.prototype.triggerEvent = function (eventData, triggerEvents) {
        var t = this;
        setTimeout(function () {
            var i = triggerEvents.length;
            var j = 0;
            var e;
            var c;
            while (i--) {
                e = triggerEvents[i];
                c = t._callbacks[t._selectedTable][e].concat(t._callbacks[t._selectedTable]["*"]);
                j = c.length;
                while (j--) {
                    eventData.name = e;
                    eventData.actionOrView = t._activeActionOrView || "";
                    c[j](eventData, t);
                }
            }
            t._activeActionOrView = undefined;
        }, 0);
    };
    NanoSQLInstance.prototype.default = function (replaceObj) {
        var newObj = {};
        var t = this;
        t._models[t._selectedTable].forEach(function (m) {
            newObj[m.key] = (replaceObj && replaceObj[m.key]) ? replaceObj[m.key] : m.default;
            if (!newObj[m.key]) {
                newObj[m.key] = t._cast(m.type, null);
            }
        });
        return newObj;
    };
    NanoSQLInstance.prototype.beginTransaction = function () {
        if (this.backend._transaction)
            return this.backend._transaction("start");
    };
    NanoSQLInstance.prototype.endTransaction = function () {
        if (this.backend._transaction)
            return this.backend._transaction("end");
    };
    NanoSQLInstance.prototype.exec = function () {
        var t = this;
        var _t = t._selectedTable;
        if (t._hasEvents[_t]) {
            t._triggerEvents = t._query.map(function (q) {
                switch (q.type) {
                    case "select": return [q.type];
                    case "delete":
                    case "upsert":
                    case "drop": return [q.type, "change"];
                    default: return [];
                }
            }).reduce(function (a, b) { return a.concat(b); });
        }
        return new lie_ts_1.Promise(function (res, rej) {
            if (!t.backend) {
                rej();
                throw Error;
            }
            var _tEvent = function (data, callBack, type, changedRows, isError) {
                if (t._hasEvents[_t]) {
                    t.triggerEvent({
                        name: "error",
                        actionOrView: "",
                        table: _t,
                        query: t._query,
                        time: new Date().getTime(),
                        result: data,
                        changeType: type,
                        changedRows: changedRows
                    }, t._triggerEvents);
                }
                callBack(data, t);
            };
            t.backend._exec({
                _table: _t,
                _query: t._query,
                _viewOrAction: t._activeActionOrView || "",
                _onSuccess: function (rows, type, affectedRows) {
                    _tEvent(rows, res, type, affectedRows, false);
                },
                _onFail: function (err) {
                    t._triggerEvents = ["error"];
                    if (rej)
                        _tEvent(err, rej, "error", [], true);
                }
            });
        });
    };
    NanoSQLInstance.prototype.config = function (args) {
        var t = this;
        if (!t.backend)
            t._preConnectExtend.push(args);
        return t;
    };
    NanoSQLInstance.prototype.extend = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var t = this;
        if (t.backend) {
            if (t.backend._extend) {
                args.unshift(t);
                return t.backend._extend.apply(t.backend, args);
            }
            else {
                return undefined;
            }
        }
    };
    NanoSQLInstance.prototype.loadJS = function (rows) {
        var t = this;
        t.beginTransaction();
        return new lie_ts_1.Promise(function (res, rej) {
            lie_ts_1.Promise.all(rows.map(function (row) {
                return t.from(t._selectedTable).query("upsert", row).exec();
            })).then(function (rowData) {
                t.endTransaction();
                res(rowData, t);
            });
        });
    };
    NanoSQLInstance.prototype.rowFilter = function (callBack) {
        return this._rowFilters[this._selectedTable] = callBack, this;
    };
    NanoSQLInstance.prototype.loadCSV = function (csv) {
        var t = this;
        var fields = [];
        t.beginTransaction();
        return new lie_ts_1.Promise(function (res, rej) {
            lie_ts_1.Promise.all(csv.split("\n").map(function (v, k) {
                return new lie_ts_1.Promise(function (resolve, reject) {
                    if (k === 0) {
                        fields = v.split(",");
                        resolve();
                    }
                    else {
                        var record = {};
                        var row = v.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
                        row = row.map(function (str) { return str.replace(/^"(.+(?="$))"$/, "$1"); });
                        var i = fields.length;
                        while (i--) {
                            if (row[i].indexOf("{") === 0 || row[i].indexOf("[") === 0) {
                                row[i] = JSON.parse(row[i].replace(/'/g, ""));
                            }
                            record[fields[i]] = row[i];
                        }
                        t.from(t._selectedTable).query("upsert", record).exec().then(function () {
                            resolve();
                        });
                    }
                });
            })).then(function () {
                t.endTransaction();
                res([], t);
            });
        });
    };
    NanoSQLInstance.uuid = function () {
        var r, s, buf;
        var random16Bits = function () {
            if (typeof crypto === "undefined") {
                return Math.round(Math.random() * Math.pow(2, 16));
            }
            else {
                if (window.crypto.getRandomValues) {
                    buf = new Uint16Array(1);
                    window.crypto.getRandomValues(buf);
                    return buf[0];
                }
                else if (crypto.randomBytes) {
                    return crypto.randomBytes(2).reduce(function (prev, cur) { return cur * prev; });
                }
                else {
                    return Math.round(Math.random() * Math.pow(2, 16));
                }
            }
        }, b = "";
        return [b, b, b, b, b, b, b, b, b].reduce(function (prev, cur, i) {
            r = random16Bits();
            s = (i === 4 ? i : (i === 5 ? (r % 16 & 0x3 | 0x8).toString(16) : b));
            r = r.toString(16);
            while (r.length < 4)
                r = "0" + r;
            return prev + ([3, 4, 5, 6].indexOf(i) >= 0 ? "-" : b) + (s + r).slice(0, 4);
        }, b);
    };
    ;
    NanoSQLInstance._hash = function (key) {
        return Math.abs(key.split("").reduce(function (prev, next, i) {
            return ((prev << 5) + prev) + key.charCodeAt(i);
        }, 0));
    };
    NanoSQLInstance.prototype.toCSV = function (headers) {
        var t = this;
        return new lie_ts_1.Promise(function (res, rej) {
            t.exec().then(function (json) {
                var header = t._query.filter(function (q) {
                    return q.type === "select";
                }).map(function (q) {
                    return q.args.length ? q.args.map(function (m) {
                        return t._models[t._selectedTable].filter(function (f) { return f["key"] === m; })[0];
                    }) : t._models[t._selectedTable];
                })[0];
                if (headers) {
                    json.unshift(header.map(function (h) {
                        return h["key"];
                    }));
                }
                res(json.map(function (row, i) {
                    if (headers && i === 0)
                        return row;
                    return header.filter(function (column) {
                        return row[column["key"]] ? true : false;
                    }).map(function (column) {
                        switch (column["type"]) {
                            case "map":
                            case "array": return '"' + JSON.stringify(row[column["key"]]).replace(/"/g, "'") + '"';
                            default: return row[column["key"]];
                        }
                    }).join(",");
                }).join("\n"), t);
            });
        });
    };
    return NanoSQLInstance;
}());
exports.NanoSQLInstance = NanoSQLInstance;
var _NanoSQLStatic = new NanoSQLInstance();
exports.nSQL = function (setTablePointer) {
    return _NanoSQLStatic.from(setTablePointer);
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _INTERNAL = function () { };
var _REJECTED = ['R'];
var _FULFILLED = ['F'];
var _PENDING = ['P'];
var Promise = (function () {
    function Promise(resolver) {
        this._state = _PENDING;
        this._queue = [];
        this._outcome = void 0;
        if (resolver !== _INTERNAL) {
            _safelyResolveThenable(this, resolver);
        }
    }
    Promise.prototype.catch = function (onRejected) {
        return this.then(function () { }, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this._state === _FULFILLED ||
            typeof onRejected !== 'function' && this._state === _REJECTED) {
            return this;
        }
        var promise = new Promise(_INTERNAL);
        if (this._state !== _PENDING) {
            var resolver = this._state === _FULFILLED ? onFulfilled : onRejected;
            _unwrap(promise, resolver, this._outcome);
        }
        else {
            this._queue.push(new _QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
    };
    /**
     *
     * @static
     * @param {any} value
     * @returns
     *
     * @memberOf Promise
     */
    Promise.resolve = function (value) {
        if (value instanceof this) {
            return value;
        }
        return _handlers._resolve(new Promise(_INTERNAL), value);
    };
    /**
     *
     * @static
     * @param {any} reason
     * @returns
     *
     * @memberOf Promise
     */
    Promise.reject = function (reason) {
        return _handlers._reject(new Promise(_INTERNAL), reason);
    };
    Promise.all = function (iterable) {
        var self = this;
        var len = iterable.length;
        var called = false;
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new Promise(_INTERNAL);
        if (!len) {
            return this.resolve([]);
        }
        while (++i < len) {
            allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i) {
            self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                    called = true;
                    _handlers._reject(promise, error);
                }
            });
            function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len && !called) {
                    called = true;
                    _handlers._resolve(promise, values);
                }
            }
        }
    };
    Promise.race = function (iterable) {
        var self = this;
        var len = iterable.length;
        var called = false;
        var i = -1;
        var promise = new Promise(_INTERNAL);
        if (Array.isArray(iterable) !== false) {
            return this.reject(new TypeError());
        }
        function resolver(value) {
            self.resolve(value).then(function (response) {
                if (!called) {
                    called = true;
                    _handlers._resolve(promise, response);
                }
            }, function (error) {
                if (!called) {
                    called = true;
                    _handlers._reject(promise, error);
                }
            });
        }
        if (!len) {
            return this.resolve([]);
        }
        while (++i < len) {
            resolver(iterable[i]);
        }
        return promise;
    };
    return Promise;
}());
exports.Promise = Promise;
/**
 * @internal
 *
 * @export
 * @class _QueueItem
 */
var _QueueItem = (function () {
    function _QueueItem(promise, onFulfilled, onRejected) {
        this._promise = promise;
        if (typeof onFulfilled === 'function') {
            this._onFulfilled = onFulfilled;
            this._callFulfilled = this._otherCallFulfilled;
        }
        if (typeof onRejected === 'function') {
            this._onRejected = onRejected;
            this._callRejected = this._otherCallRejected;
        }
    }
    _QueueItem.prototype._callFulfilled = function (value) {
        _handlers._resolve(this._promise, value);
    };
    ;
    _QueueItem.prototype._otherCallFulfilled = function (value) {
        _unwrap(this._promise, this._onFulfilled, value);
    };
    ;
    _QueueItem.prototype._callRejected = function (value) {
        _handlers._reject(this._promise, value);
    };
    ;
    _QueueItem.prototype._otherCallRejected = function (value) {
        _unwrap(this._promise, this._onRejected, value);
    };
    ;
    return _QueueItem;
}());
exports._QueueItem = _QueueItem;
/**
 *
 * @internal
 * @param {any} promise
 * @param {any} func
 * @param {any} value
 */
function _unwrap(promise, func, value) {
    setTimeout(function () {
        var returnValue;
        try {
            returnValue = func.apply(null, value);
        }
        catch (e) {
            return _handlers._reject(promise, e);
        }
        if (returnValue === promise) {
            _handlers._reject(promise, new TypeError());
        }
        else {
            _handlers._resolve(promise, returnValue);
        }
        return null;
    });
}
/**
 *
 * @internal
 * @class _handlers
 */
var _handlers = (function () {
    function _handlers() {
    }
    _handlers._resolve = function (self, value) {
        var result = _tryCatch(_getThen, value);
        var thenable = result._value;
        var i = -1;
        var len = self._queue.length;
        if (result._status === 'error') {
            return _handlers._reject(self, result._value);
        }
        if (thenable) {
            _safelyResolveThenable(self, thenable);
        }
        else {
            self._state = _FULFILLED;
            self._outcome = value;
            while (++i < len) {
                self._queue[i]._callFulfilled(value);
            }
        }
        return self;
    };
    ;
    _handlers._reject = function (self, error) {
        self._state = _REJECTED;
        self._outcome = error;
        var i = -1;
        var len = self._queue.length;
        while (++i < len) {
            self._queue[i]._callRejected(error);
        }
        return self;
    };
    ;
    return _handlers;
}());
/**
 *
 * @internal
 * @param {any} obj
 * @returns
 */
function _getThen(obj) {
    // Make sure we only access the accessor once as required by the spec
    var then = obj && obj.then;
    if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
        return function appyThen() {
            then.apply(obj, arguments);
        };
    }
    else {
        return null;
    }
}
/**
 *
 * @internal
 * @param {Promise<any>} self
 * @param {(onSuccess:(...T) => void, onFail:(...T) => void) => void} thenable
 */
function _safelyResolveThenable(self, thenable) {
    // Either fulfill, reject or reject with error
    var called = false;
    function onError() {
        var value = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            value[_i] = arguments[_i];
        }
        if (called) {
            return;
        }
        called = true;
        _handlers._reject(self, value);
    }
    function onSuccess() {
        var value = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            value[_i] = arguments[_i];
        }
        if (called) {
            return;
        }
        called = true;
        _handlers._resolve(self, value);
    }
    function tryToUnwrap() {
        thenable(onSuccess, onError);
    }
    var result = _tryCatch(tryToUnwrap);
    if (result._status === 'error') {
        onError(result._value);
    }
}
/**
 *
 * @internal
 * @param {any} func
 * @param {*} [values]
 * @returns
 */
function _tryCatch(func, values) {
    var out = { _status: null, _value: null };
    try {
        out._value = func(values);
        out._status = 'success';
    }
    catch (e) {
        out._status = 'error';
        out._value = e;
    }
    return out;
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var index_1 = __webpack_require__(0);
var lie_ts_1 = __webpack_require__(1);
var minMax = function (type, row, args, ptr, prev) {
    var key = args[0];
    if (ptr[0] == 0)
        prev[key] = type == -1 ? Number.MAX_VALUE : Number.MIN_VALUE;
    var nextRow = {};
    if (type == -1 ? parseFloat(row[key]) < parseFloat(prev[key]) : parseFloat(row[key]) > parseFloat(prev[key])) {
        nextRow = row;
    }
    else {
        nextRow = prev;
    }
    if (ptr[0] === ptr[1]) {
        var r = index_1._assign(nextRow);
        r[type == -1 ? "MIN" : "MAX"] = nextRow[key];
        return r;
    }
    else {
        return nextRow;
    }
};
var _functions = {
    SUM: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] == 0)
                prev = 0;
            prev += parseInt(row[args[0]]);
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.SUM = prev;
                return r;
            }
            else {
                return prev;
            }
        }
    },
    MIN: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            return minMax(-1, row, args, ptr, prev);
        }
    },
    MAX: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            return minMax(1, row, args, ptr, prev);
        }
    },
    AVG: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] == 0)
                prev = 0;
            prev += parseInt(row[args[0]]);
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.AVG = (prev / (ptr[1] + 1)) || prev;
                return r;
            }
            else {
                return prev;
            }
        }
    },
    COUNT: {
        type: "aggregate",
        call: function (row, args, ptr, prev) {
            if (ptr[0] == 0)
                prev = 0;
            if (args[0] === "*") {
                prev++;
            }
            else {
                prev += row[args[0]] ? 1 : 0;
            }
            if (ptr[0] === ptr[1]) {
                var r = index_1._assign(row);
                r.COUNT = prev;
                return r;
            }
            else {
                return prev;
            }
        }
    }
};
var _NanoSQLImmuDB = (function () {
    function _NanoSQLImmuDB() {
        var t = this;
        t._models = {};
        t._tables = {};
        t._pendingQuerys = [];
        t._historyRecords = [];
        t._historyPoint = 0;
        t._historyArray = [0, 0];
        t._queryCache = {};
        t._doingTransaction = false;
    }
    _NanoSQLImmuDB.prototype._getRow = function (tableID, primaryKey) {
        return this._tables[tableID]._rows[primaryKey][this._tables[tableID]._historyPointers[primaryKey]];
    };
    _NanoSQLImmuDB.prototype._getTable = function () {
        return this._tables[this._selectedTable];
    };
    _NanoSQLImmuDB.prototype._newTable = function (tableName, dataModels) {
        var t = this;
        var ta = index_1.NanoSQLInstance._hash(tableName);
        t._models[ta] = dataModels;
        t._queryCache[ta] = {};
        t._tables[ta] = {
            _pk: "",
            _pkType: "",
            _keys: [],
            _defaults: [],
            _name: tableName,
            _incriment: 1,
            _index: [],
            _historyPointers: {},
            _rows: {}
        };
        var i = t._models[ta].length;
        var keys = [];
        var defaults = [];
        while (i--) {
            var p = t._models[ta][i];
            t._tables[ta]._keys.unshift(p.key);
            t._tables[ta]._defaults[i] = p.default;
            if (p.props && p.props.indexOf("pk") >= 0) {
                t._tables[ta]._pk = p.key;
                t._tables[ta]._pkType = p.type;
            }
        }
        return tableName;
    };
    _NanoSQLImmuDB.prototype._connect = function (connectArgs) {
        var t = this;
        var i = 0;
        var p;
        var tables = [];
        var upgrading = false;
        var index = 0;
        t._parent = connectArgs._parent;
        t._persistent = connectArgs._config.length ? connectArgs._config[0].persistent || false : false;
        Object.keys(connectArgs._models).forEach(function (tableName) {
            tables.push(t._newTable(tableName, connectArgs._models[tableName]));
        });
        t._databaseID = index_1.NanoSQLInstance._hash(JSON.stringify(connectArgs._models));
        Object.keys(connectArgs._functions || []).forEach(function (f) {
            _functions[f] = connectArgs._functions[f];
        });
        if (t._persistent) {
            if (typeof indexedDB !== "undefined") {
                var idb = indexedDB.open(String(t._databaseID), 1);
                idb.onupgradeneeded = function (event) {
                    upgrading = true;
                    var db = event.target.result;
                    var next = function () {
                        if (index < tables.length) {
                            var ta = index_1.NanoSQLInstance._hash(tables[index]);
                            var config = t._tables[ta]._pk ? { keyPath: t._tables[ta]._pk } : {};
                            db.createObjectStore(tables[index], config);
                            index++;
                            next();
                        }
                        else {
                            connectArgs._onSuccess();
                        }
                    };
                    next();
                };
                idb.onsuccess = function (event) {
                    t._indexedDB = event.target.result;
                    if (!upgrading) {
                        var next_1 = function () {
                            if (index < tables.length) {
                                var ta = index_1.NanoSQLInstance._hash(tables[index]);
                                var transaction = t._indexedDB.transaction(tables[index], "readonly");
                                var store = transaction.objectStore(tables[index]);
                                var cursorRequest = store.openCursor();
                                var items_1 = [];
                                transaction.oncomplete = function () {
                                    t._parent.from(tables[index]).loadJS(items_1).then(function () {
                                        index++;
                                        next_1();
                                    });
                                };
                                cursorRequest.onsuccess = function (evt) {
                                    var cursor = evt.target.result;
                                    if (cursor) {
                                        items_1.push(cursor.value);
                                        cursor.continue();
                                    }
                                };
                            }
                            else {
                                connectArgs._onSuccess();
                            }
                        };
                        next_1();
                    }
                    ;
                };
            }
        }
        else {
            connectArgs._onSuccess();
        }
    };
    _NanoSQLImmuDB.prototype._exec = function (execArgs) {
        var t = this;
        if (t._pendingQuerys.length) {
            t._pendingQuerys.push(execArgs);
        }
        else {
            t._selectedTable = index_1.NanoSQLInstance._hash(execArgs._table);
            new _NanoSQLQuery(t)._doQuery(execArgs, function (query) {
                if (t._pendingQuerys.length) {
                    t._exec(t._pendingQuerys.pop());
                }
            });
        }
    };
    _NanoSQLImmuDB.prototype._invalidateCache = function (changedRows, type, action) {
        var t = this;
        t._queryCache[t._selectedTable] = {};
        if (changedRows.length && action) {
            t._parent.triggerEvent({
                name: "change",
                actionOrView: "",
                table: t._getTable()._name,
                query: [],
                time: new Date().getTime(),
                result: [{ msg: action + " was performed.", type: action }],
                changedRows: changedRows,
                changeType: type
            }, ["change"]);
        }
    };
    _NanoSQLImmuDB.prototype._extend = function (db, command) {
        var t = this;
        var i;
        var h;
        var rowID;
        var rowData;
        var rowKey;
        var store;
        if (t._indexedDB && t._getTable()) {
            store = t._indexedDB.transaction(t._getTable()._name, "readwrite").objectStore(t._getTable()._name);
        }
        var shiftRowIDs = function (direction) {
            var tableID = t._historyRecords[t._historyPoint]._tableID;
            i = t._historyRecords[t._historyPoint]._rowKeys.length;
            var rows = [];
            while (i--) {
                rowID = t._historyRecords[t._historyPoint]._rowKeys[i];
                if (t._tables[tableID]._pkType === "int")
                    rowID = parseInt(rowID);
                rowData = t._getRow(tableID, rowID) || {};
                if (direction > 0)
                    rows.push(rowData);
                t._tables[tableID]._historyPointers[rowID] += direction;
                rowData = t._getRow(tableID, rowID);
                if (direction < 0)
                    rows.push(t._getRow(tableID, rowID));
                if (store) {
                    if (rowData) {
                        store.put(rowData);
                    }
                    else {
                        store.delete(rowID);
                    }
                }
                if (t._tables[tableID]._historyPointers[rowID] < 0)
                    t._tables[tableID]._historyPointers[rowID] = 0;
            }
            return rows;
        };
        return new lie_ts_1.Promise(function (res, rej) {
            switch (command) {
                case "<":
                    if (!t._historyRecords.length || t._historyPoint === t._historyRecords.length) {
                        res(false);
                    }
                    else {
                        var rows = shiftRowIDs(1);
                        var description = t._historyRecords[t._historyPoint]._type;
                        t._historyPoint++;
                        switch (description) {
                            case "inserted":
                                description = "deleted";
                                break;
                            case "deleted":
                                description = "inserted";
                                break;
                        }
                        t._invalidateCache(rows, description, "undo");
                        res(true);
                    }
                    break;
                case ">":
                    if (!t._historyRecords.length || t._historyPoint < 1) {
                        res(false);
                    }
                    else {
                        t._historyPoint--;
                        var rows = shiftRowIDs(-1);
                        t._invalidateCache(rows, t._historyRecords[t._historyPoint]._type, "redo");
                        res(true);
                    }
                    break;
                case "?":
                    h = [t._historyRecords.length, t._historyRecords.length - t._historyPoint];
                    if (t._historyArray.join("+") !== h.join("+")) {
                        t._historyArray = h;
                    }
                    res(t._historyArray);
                    break;
                case "flush_db":
                    if (t._indexedDB) {
                        indexedDB.deleteDatabase(String(t._databaseID));
                    }
                    break;
                case "before_import":
                    t._doingTransaction = true;
                    res(!!t._doingTransaction);
                    break;
                case "after_import":
                    t._doingTransaction = false;
                    res(!!t._doingTransaction);
                    break;
            }
        });
    };
    return _NanoSQLImmuDB;
}());
exports._NanoSQLImmuDB = _NanoSQLImmuDB;
var _NanoSQLQuery = (function () {
    function _NanoSQLQuery(database) {
        this._db = database;
    }
    _NanoSQLQuery.prototype._doQuery = function (query, callBack) {
        var _this = this;
        var t = this;
        t._mod = [];
        t._act = undefined;
        var simpleQuery = [];
        query._query.forEach(function (q) {
            if (["upsert", "select", "delete", "drop"].indexOf(q.type) >= 0) {
                t._act = q;
                if (q.type === "select")
                    t._queryHash = index_1.NanoSQLInstance._hash(JSON.stringify(query._query));
            }
            else if (["show tables", "describe"].indexOf(q.type) >= 0) {
                simpleQuery.push(q);
            }
            else {
                t._mod.push(q);
            }
        });
        if (simpleQuery.length) {
            switch (simpleQuery[0].type) {
                case "show tables":
                    callBack();
                    query._onSuccess([{ tables: Object.keys(this._db._tables).map(function (ta) { return _this._db._tables[ta]._name; }) }], "info", []);
                    break;
                case "describe":
                    var getTable_1;
                    var tableName_1 = this._db._selectedTable;
                    var rows = {};
                    Object.keys(this._db._tables).forEach(function (ta) {
                        if (parseInt(ta) === _this._db._selectedTable) {
                            getTable_1 = index_1._assign(_this._db._models[ta]);
                            tableName_1 = _this._db._tables[ta]._name;
                        }
                    });
                    rows[tableName_1] = getTable_1;
                    callBack();
                    query._onSuccess([rows], "info", []);
                    break;
            }
        }
        else {
            t._execQuery(function (result, changeType, affectedRows) {
                query._onSuccess(result, changeType, affectedRows);
                callBack(t);
            });
        }
    };
    _NanoSQLQuery.prototype._deepFreeze = function (obj) {
        var _this = this;
        this._db._models[this._db._selectedTable].forEach(function (model) {
            var prop = obj[model.key];
            if (["map", "array"].indexOf(typeof prop) >= 0) {
                obj[model.key] = _this._deepFreeze(prop);
            }
        });
        return Object.freeze(obj);
    };
    _NanoSQLQuery.prototype._getMod = function (name) {
        return this._mod.filter(function (v) { return v.type === name; }).pop();
    };
    ;
    _NanoSQLQuery.prototype._transaction = function (type) {
    };
    _NanoSQLQuery.prototype._execQuery = function (callBack) {
        var t = this;
        if (!t._act)
            return;
        var queryIndex = [];
        if (!t._getMod("join") && t._act.type !== "drop") {
            if (t._getMod("where")) {
                queryIndex = t._where(t._db._selectedTable, t._db._getTable()._index.slice(), t._getMod("where").args);
            }
            else {
                queryIndex = t._act.type !== "upsert" ? t._db._getTable()._index.slice() : [];
            }
        }
        switch (t._act.type) {
            case "upsert":
                this._upsert(queryIndex, callBack);
                break;
            case "select":
                this._select(queryIndex, callBack);
                break;
            case "drop":
            case "delete":
                this._remove(queryIndex, callBack);
                break;
        }
    };
    _NanoSQLQuery.prototype._updateRow = function (rowPK) {
        var t = this;
        var newRow;
        var oldRow = t._db._getRow(t._db._selectedTable, rowPK);
        var qArgs = t._act.args;
        var updateType = (function () {
            if (t._act) {
                if (t._act.type === "delete" && !qArgs.length) {
                    return "drop";
                }
            }
            return t._act ? t._act.type : "";
        })();
        switch (updateType) {
            case "upsert":
                if (!t._db._doingTransaction) {
                    newRow = oldRow ? index_1._assign(oldRow) : {};
                }
                else {
                    newRow = oldRow || {};
                }
                Object.keys(qArgs).forEach(function (k) {
                    newRow[k] = qArgs[k];
                });
                t._db._getTable()._keys.forEach(function (k, i) {
                    var def = t._db._getTable()._defaults[i];
                    if (!newRow[k] && def)
                        newRow[k] = def;
                });
                break;
            case "delete":
                newRow = oldRow ? index_1._assign(oldRow) : {};
                if (qArgs && qArgs.length) {
                    qArgs.forEach(function (column) {
                        newRow[column] = null;
                    });
                }
                else {
                    newRow = null;
                }
                break;
        }
        if (!t._db._doingTransaction) {
            t._db._getTable()._rows[rowPK].unshift(newRow ? t._deepFreeze(newRow) : null);
        }
        else {
            t._db._getTable()._rows[rowPK][t._db._getTable()._historyPointers[rowPK]] = t._deepFreeze(newRow);
        }
        if (t._db._indexedDB) {
            var tableName = t._db._getTable()._name;
            var transaction = t._db._indexedDB.transaction(tableName, "readwrite").objectStore(tableName);
            if (updateType === "upsert") {
                transaction.put(newRow);
            }
            else {
                transaction.delete(rowPK);
            }
        }
    };
    _NanoSQLQuery.prototype._tableChanged = function (updatedRowPKs, describe, callBack) {
        var _this = this;
        var t = this, k;
        if (updatedRowPKs.length > 0) {
            if (t._db._historyPoint > 0 && t._db._doingTransaction !== true) {
                t._db._historyRecords = t._db._historyRecords.filter(function (val, index) {
                    if (index < t._db._historyPoint) {
                        k = val._rowKeys.length;
                        while (k--) {
                            t._db._tables[val._tableID]._historyPointers[val._rowKeys[k]] = 0;
                            t._db._tables[val._tableID]._rows[val._rowKeys[k]].shift();
                        }
                        return false;
                    }
                    return true;
                });
                t._db._historyPoint = 0;
            }
            if (!t._db._doingTransaction) {
                t._db._historyRecords.unshift({
                    _tableID: t._db._selectedTable,
                    _rowKeys: updatedRowPKs,
                    _type: describe
                });
            }
            t._db._invalidateCache([], "");
            callBack([{ msg: updatedRowPKs.length + " row(s) " + describe }], describe, updatedRowPKs.map(function (r) { return _this._db._getRow(_this._db._selectedTable, r) || {}; }));
        }
        else {
            callBack([{ msg: "0 rows " + describe }], describe, []);
        }
    };
    ;
    _NanoSQLQuery.prototype._upsert = function (queryIndex, callBack) {
        var scribe = "", i, changedPKs = [];
        var qArgs = this._act.args || {}, table = this._db._getTable(), pk = table._pk, whereMod = this._getMod("where");
        if (whereMod) {
            scribe = "modified";
            changedPKs = queryIndex;
            i = queryIndex.length;
            while (i--) {
                this._updateRow(queryIndex[i]);
            }
        }
        else {
            scribe = "inserted";
            if (!qArgs[pk]) {
                if (table._pkType === "int") {
                    qArgs[pk] = table._incriment++;
                }
                else if (table._pkType === "uint") {
                    qArgs[pk] = index_1.NanoSQLInstance.uuid();
                }
            }
            else {
                if (table._pkType === "int") {
                    table._incriment = Math.max(qArgs[pk] + 1, table._incriment);
                }
            }
            var objPK = qArgs[pk] ? String(qArgs[pk]) : String(table._index.length);
            changedPKs = [objPK];
            if (!table._rows[objPK]) {
                table._rows[objPK] = [null];
                table._historyPointers[objPK] = 0;
                table._index.push(objPK);
            }
            this._updateRow(objPK);
        }
        this._tableChanged(changedPKs, scribe, callBack);
    };
    _NanoSQLQuery.prototype._getTableID = function () {
        return this._joinTable ? this._joinTable : this._db._selectedTable;
    };
    _NanoSQLQuery.prototype._select = function (queryIndex, callBack) {
        var t = this;
        if (t._db._queryCache[t._db._selectedTable][t._queryHash]) {
            callBack(t._db._queryCache[t._db._selectedTable][t._queryHash], "none", []);
            return;
        }
        var mods = ["join", "groupby", "having", "orderby", "offset", "limit"];
        var curMod, column, i, k, rows, obj, rowData, groups = {};
        var sortObj = function (objA, objB, columns) {
            return Object.keys(columns).reduce(function (prev, cur) {
                if (!prev) {
                    if (objA[cur] == objB[cur])
                        return 0;
                    return (objA[cur] > objB[cur] ? 1 : -1) * (columns[cur] === "desc" ? -1 : 1);
                }
                else {
                    return prev;
                }
            }, 0);
        };
        var modifyQuery = function (tableIndex, modIndex, next) {
            curMod = t._getMod(mods[modIndex]);
            if (modIndex === 1) {
                tableIndex = tableIndex.map(function (index) {
                    return t._db._getRow(t._getTableID(), index);
                }).filter(function (r) { return r; });
            }
            if (modIndex === 2) {
                var functions_1 = [];
                if (qArgs.length) {
                    var funcs_1 = Object.keys(_functions).map(function (f) { return f + "("; });
                    var keepColumns_1 = [];
                    functions_1 = qArgs.filter(function (q) {
                        var hasFunc = funcs_1.reduce(function (prev, cur) {
                            return (q.indexOf(cur) < 0 ? 0 : 1) + prev;
                        }, 0) || 0;
                        if (hasFunc > 0) {
                            return true;
                        }
                        else {
                            keepColumns_1.push(q);
                            return false;
                        }
                    }).map(function (selectString) {
                        var regex = selectString.match(/(.*)\((.*)\)/);
                        var funcName = regex[1].trim();
                        var columnName = (selectString.match(/\sAS\s(.*)/) || []).pop() || funcName;
                        var args = regex[2].split(",").map(function (s) { return s.trim(); });
                        if (_functions[funcName].type === "simple" && columnName === funcName) {
                            columnName = args[0];
                        }
                        keepColumns_1.push(columnName);
                        return {
                            name: funcName,
                            args: args,
                            as: columnName.trim(),
                            type: _functions[funcName].type
                        };
                    });
                    var rows_1 = [];
                    if (functions_1.length) {
                        var prevFunc_1;
                        var doFunctions_1 = function (rows) {
                            return functions_1.sort(function (a, b) {
                                return a.type > b.type ? 1 : -1;
                            }).reduce(function (prev, curr) {
                                var len = prev.length - 1;
                                if (curr.type === "aggregate") {
                                    var newRows = rows.slice();
                                    len = newRows.length - 1;
                                    newRows = [newRows.reduce(function (p, v, i) {
                                            return _functions[curr.name].call(v, curr.args, [i, len], p);
                                        }, {})];
                                    if (prevFunc_1) {
                                        newRows[0][prevFunc_1] = prev[0][prevFunc_1];
                                    }
                                    prev = newRows;
                                    prevFunc_1 = curr.name;
                                }
                                else {
                                    prev = prev.map(function (v, i) {
                                        return _functions[curr.name].call(v, curr.args, [i, len]);
                                    });
                                }
                                if (curr.name !== curr.as) {
                                    keepColumns_1.push(curr.name + " AS " + curr.as);
                                }
                                else {
                                    keepColumns_1.push(curr.name);
                                }
                                return prev;
                            }, rows.slice());
                        };
                        var groupKeys = Object.keys(groups);
                        if (groupKeys.length) {
                            rows_1 = groupKeys
                                .map(function (k) { return doFunctions_1(groups[k]); })
                                .reduce(function (prev, curr) {
                                return prev = prev.concat(curr), prev;
                            }, []);
                        }
                        else {
                            rows_1 = doFunctions_1(tableIndex);
                        }
                    }
                    else {
                        rows_1 = tableIndex;
                    }
                    var convertKeys_1 = keepColumns_1.map(function (n) {
                        return n.match(/(.*)\sAS\s(.*)/) || n;
                    }).filter(function (n) { return n; }) || [];
                    if (convertKeys_1.length) {
                        rows_1 = rows_1.map(function (r) {
                            r = index_1._assign(r);
                            var newRow = {};
                            convertKeys_1.forEach(function (key) {
                                if (typeof key === "string") {
                                    newRow[key] = r[key];
                                }
                                else {
                                    newRow[key[2]] = r[key[1]];
                                }
                            });
                            return newRow;
                        });
                    }
                    tableIndex = rows_1;
                }
            }
            if (!curMod)
                return next(tableIndex);
            switch (modIndex) {
                case 0:
                    var joinConditions = void 0;
                    if (curMod.args.type !== "cross") {
                        joinConditions = {
                            _left: curMod.args.where[0].split(".").pop(),
                            _check: curMod.args.where[1],
                            _right: curMod.args.where[2].split(".").pop()
                        };
                    }
                    var leftTableID = t._db._selectedTable;
                    var rightTableID = index_1.NanoSQLInstance._hash(curMod.args.table);
                    var joinedIndex = t._join(curMod.args.type, leftTableID, t._db._tables[leftTableID]._index.slice(), rightTableID, t._db._tables[rightTableID]._index.slice(), joinConditions);
                    var where = t._getMod("where");
                    if (where) {
                        joinedIndex = t._where(t._getTableID(), joinedIndex, where.args);
                    }
                    next(joinedIndex);
                    break;
                case 1:
                    var columns_1 = curMod.args;
                    var sortGroups_1 = {};
                    if (columns_1) {
                        groups = tableIndex.reduce(function (prev, curr) {
                            var key = Object.keys(columns_1).reduce(function (p, c) { return p + "." + String(curr[c]); }, "").slice(1);
                            (prev[key] = prev[key] || []).push(curr);
                            sortGroups_1[key] = Object.keys(columns_1).reduce(function (pr, cu) {
                                pr[cu] = curr[cu];
                                return pr;
                            }, {});
                            return prev;
                        }, {});
                        next(Object.keys(groups).sort(function (a, b) {
                            return sortObj(sortGroups_1[a], sortGroups_1[b], columns_1);
                        }).reduce(function (prev, curr) {
                            return prev.concat(groups[curr]);
                        }, []));
                    }
                    else {
                        next(tableIndex);
                    }
                    break;
                case 2:
                    t._db._tables[t._queryHash] = {
                        _defaults: [],
                        _historyPointers: {},
                        _incriment: 0,
                        _index: [],
                        _keys: [],
                        _name: t._queryHash.toString(),
                        _pk: "",
                        _pkType: "",
                        _rows: {}
                    };
                    t._joinTable = t._queryHash;
                    tableIndex.forEach(function (row, i) {
                        t._db._tables[t._queryHash]._historyPointers[i] = 0;
                        t._db._tables[t._queryHash]._rows[i] = [row];
                        t._db._tables[t._queryHash]._index.push(i.toString());
                    });
                    next(t._where(t._queryHash, t._db._tables[t._queryHash]._index, t._getMod("having").args).map(function (i) {
                        return t._db._getRow(t._queryHash, i);
                    }).filter(function (r) { return r; }));
                    break;
                case 3:
                    next(tableIndex.sort(function (a, b) {
                        return sortObj(a, b, curMod.args);
                    }));
                    break;
                case 4:
                    next(tableIndex.filter(function (row, index) {
                        return curMod ? index >= curMod.args : true;
                    }));
                    break;
                case 5:
                    next(tableIndex.filter(function (row, index) {
                        return curMod ? index < curMod.args : true;
                    }));
                    break;
            }
        };
        i = -1;
        var qArgs = t._act.args || [];
        var stepQuery = function (rowPKs) {
            if (i < mods.length) {
                i++;
                modifyQuery(rowPKs, i, function (resultRows) {
                    stepQuery(resultRows);
                });
            }
            else {
                if (!t._getMod("join")) {
                    t._db._queryCache[t._db._selectedTable][t._queryHash] = rowPKs;
                }
                callBack(rowPKs, "none", []);
            }
        };
        stepQuery(queryIndex);
    };
    _NanoSQLQuery.prototype._remove = function (queryIndex, callBack) {
        var scribe = "deleted", i;
        var t = this;
        var qArgs = t._act.args || [];
        i = queryIndex.length;
        while (i--)
            t._updateRow(queryIndex[i]);
        if (qArgs.length)
            scribe = "modified";
        t._tableChanged(queryIndex, scribe, callBack);
    };
    _NanoSQLQuery.prototype._where = function (tableID, searchIndex, conditions) {
        var t = this;
        var commands = ["AND", "OR"];
        var doJoin;
        var whereJoin = function (indexes, type) {
            return (indexes[0].concat(indexes[1]).sort().filter(function (item, pos, ary) {
                var last = ary.lastIndexOf(item);
                return type === "OR" ? true : (pos !== last);
            }));
        };
        var filterRows = function (index, singleWhereStatement) {
            var r;
            return index.filter(function (v) {
                r = t._db._getRow(tableID, v);
                return !r ? false : t._compare(singleWhereStatement[2], singleWhereStatement[1], r[singleWhereStatement[0]]) === 0 ? true : false;
            });
        };
        if (typeof conditions[0] === "string") {
            return filterRows(searchIndex, conditions);
        }
        else {
            return conditions.map(function (value) {
                return commands.indexOf(value) >= 0 ? value : filterRows(searchIndex.slice(), value);
            }).reduce(function (prev, cur, k) {
                if (commands.indexOf(cur) < 0) {
                    return k === 0 ? cur : whereJoin([prev, cur], doJoin);
                }
                else {
                    doJoin = cur;
                    return prev;
                }
            });
        }
    };
    _NanoSQLQuery.prototype._join = function (type, leftTableID, leftIndex, rightTableID, rightIndex, joinConditions) {
        var newTableName = JSON.stringify(joinConditions) || String(leftTableID) + String(rightTableID);
        var L = "left";
        var R = "right";
        var O = "outer";
        var dataModel = [];
        var incriment = 0;
        var joinHelper = {};
        var t = this;
        var rightIndexUsed = ([R, O].indexOf(type) >= 0) ? rightIndex.slice() : [];
        [leftTableID, rightTableID].forEach(function (id) {
            var keys = [];
            t._db._models[id].forEach(function (m) {
                keys.push(m.key);
                dataModel.push({
                    key: t._db._tables[id]._name + "." + m.key,
                    type: m.type,
                    default: m.default || null
                });
            });
            joinHelper[id] = {
                _keys: keys,
                _name: t._db._tables[id]._name
            };
        });
        t._db._newTable(newTableName, dataModel);
        t._joinTable = index_1.NanoSQLInstance._hash(newTableName);
        var joinInsert = function (leftRow, rightRow) {
            var idx = String(incriment++);
            var newRow = {};
            var oldRows = [leftRow, rightRow];
            [leftTableID, rightTableID].forEach(function (id, tableIndex) {
                var row = oldRows[tableIndex];
                joinHelper[id]._keys.forEach(function (key) {
                    newRow[joinHelper[id]._name + "." + key] = row ? row[key] : null;
                });
            });
            t._db._tables[t._joinTable]._index.push(idx);
            t._db._tables[t._joinTable]._historyPointers[idx] = 0;
            t._db._tables[t._joinTable]._rows[idx] = [newRow];
        };
        var rightInserts = function (leftRow, idxs) {
            idxs.forEach(function (i) {
                if (rightIndexUsed.length) {
                    var pos = rightIndexUsed.indexOf(i);
                    if (pos > 0)
                        rightIndexUsed.splice(pos, 1);
                }
                joinInsert(leftRow, t._db._getRow(rightTableID, i));
            });
        };
        leftIndex.forEach(function (leftI, leftCounter) {
            var leftRow = t._db._getRow(leftTableID, leftI) || {};
            var whereIndex = !joinConditions ? rightIndex.slice() : t._where(rightTableID, rightIndex.slice(), [joinConditions._right, joinConditions._check, leftRow[joinConditions._left]]);
            if (whereIndex.length) {
                rightInserts(leftRow, whereIndex);
            }
            else if ([L, O].indexOf(type) >= 0) {
                joinInsert(leftRow, null);
            }
        });
        if (rightIndexUsed.length) {
            rightInserts(null, rightIndexUsed.slice());
        }
        return t._db._tables[t._joinTable]._index.slice();
    };
    _NanoSQLQuery.prototype._compare = function (val1, compare, val2) {
        switch (compare) {
            case "=": return val2 === val1 ? 0 : 1;
            case ">": return val2 > val1 ? 0 : 1;
            case "<": return val2 < val1 ? 0 : 1;
            case "<=": return val2 <= val1 ? 0 : 1;
            case ">=": return val2 >= val1 ? 0 : 1;
            case "IN": return val1.indexOf(val2) < 0 ? 1 : 0;
            case "NOT IN": return val1.indexOf(val2) < 0 ? 0 : 1;
            case "REGEX":
            case "LIKE": return val2.search(val1) < 0 ? 1 : 0;
            case "BETWEEN": return val1[0] < val2 && val1[1] > val2 ? 0 : 1;
            default: return 0;
        }
    };
    return _NanoSQLQuery;
}());


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ })
/******/ ]);
});