{
  "errors": [],
  "warnings": [],
  "version": "2.3.3",
  "hash": "3662a97c42231c55d111",
  "time": 9382,
  "publicPath": "",
  "assetsByChunkName": {
    "nano-sql": "nano-sql.min.js"
  },
  "assets": [
    {
      "name": "nano-sql.min.js",
      "size": 37318,
      "chunks": [
        0
      ],
      "chunkNames": [
        "nano-sql"
      ],
      "emitted": true
    }
  ],
  "entrypoints": {
    "nano-sql": {
      "chunks": [
        0
      ],
      "assets": [
        "nano-sql.min.js"
      ]
    }
  },
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 121282,
      "names": [
        "nano-sql"
      ],
      "files": [
        "nano-sql.min.js"
      ],
      "hash": "95eafd1e934c18f49a0f",
      "parents": [],
      "modules": [
        {
          "id": 0,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "name": "./src/index.ts",
          "index": 1,
          "index2": 5,
          "size": 22301,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "issuerId": 6,
          "issuerName": "multi ./src/index.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
              "module": "./src/db-index.ts",
              "moduleName": "./src/db-index.ts",
              "type": "cjs require",
              "userRequest": "./index",
              "loc": "2:14-32"
            },
            {
              "moduleId": 3,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
              "module": "./src/db-query.ts",
              "moduleName": "./src/db-query.ts",
              "type": "cjs require",
              "userRequest": "./index",
              "loc": "2:14-32"
            },
            {
              "moduleId": 4,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
              "module": "./src/db-storage.ts",
              "moduleName": "./src/db-storage.ts",
              "type": "cjs require",
              "userRequest": "./index",
              "loc": "2:14-32"
            },
            {
              "moduleId": 6,
              "moduleIdentifier": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
              "module": "multi ./src/index.ts",
              "moduleName": "multi ./src/index.ts",
              "type": "single entry",
              "userRequest": "C:\\Users\\Scott\\nano-sql\\src\\index.ts",
              "loc": "nano-sql:100000"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 1,
          "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar db_index_1 = require(\"./db-index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nexports._assign = function (obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n};\r\nvar NanoSQLInstance = (function () {\r\n    function NanoSQLInstance() {\r\n        var t = this;\r\n        t._actions = {};\r\n        t._views = {};\r\n        t._models = {};\r\n        t._preConnectExtend = [];\r\n        t._transactionTables = [];\r\n        t._events = [\"change\", \"delete\", \"upsert\", \"drop\", \"select\", \"error\"];\r\n        t._callbacks = {};\r\n        t._hasEvents = {};\r\n        t._callbacks[\"*\"] = {};\r\n        var i = t._events.length;\r\n        while (i--) {\r\n            t._callbacks[\"*\"][t._events[i]] = [];\r\n        }\r\n        t._functions = {};\r\n        t._rowFilters = {};\r\n    }\r\n    NanoSQLInstance.prototype.table = function (table) {\r\n        if (table)\r\n            this._selectedTable = table;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.connect = function (backend) {\r\n        var _this = this;\r\n        var t = this;\r\n        if (t.backend) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                rej();\r\n                throw Error();\r\n            });\r\n        }\r\n        t.backend = backend || new db_index_1._NanoSQLDB();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.backend._connect({\r\n                _models: t._models,\r\n                _actions: t._actions,\r\n                _views: t._views,\r\n                _functions: t._functions,\r\n                _config: t._preConnectExtend,\r\n                _parent: _this,\r\n                _onSuccess: function (result) {\r\n                    res(result, t);\r\n                },\r\n                _onFail: function (rejected) {\r\n                    if (rej)\r\n                        rej(rejected, t);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.on = function (actions, callBack) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = 0;\r\n        var a = actions.split(\" \");\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        i = a.length;\r\n        while (i--) {\r\n            if (t._events.indexOf(a[i]) !== -1) {\r\n                t._callbacks[l][a[i]].push(callBack);\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.off = function (callBack) {\r\n        var t = this;\r\n        for (var key in t._callbacks) {\r\n            for (var key2 in t._callbacks[key]) {\r\n                t._callbacks[key][key2] = t._callbacks[key][key2].filter(function (cBs) {\r\n                    return cBs !== callBack;\r\n                });\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype._refreshEventChecker = function () {\r\n        var _this = this;\r\n        this._hasEvents = {};\r\n        Object.keys(this._models).concat([\"*\"]).forEach(function (table) {\r\n            _this._hasEvents[table] = _this._events.reduce(function (prev, cur) {\r\n                return prev + (_this._callbacks[table] ? _this._callbacks[table][cur].length : 0);\r\n            }, 0) > 0;\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.model = function (dataModel) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = t._events.length;\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        t._models[l] = dataModel;\r\n        t._views[l] = [];\r\n        t._actions[l] = [];\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.views = function (viewArray) {\r\n        return this._views[this._selectedTable] = viewArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.getView = function (viewName, viewArgs) {\r\n        if (viewArgs === void 0) { viewArgs = {}; }\r\n        return this._doAV(\"View\", this._views[this._selectedTable], viewName, viewArgs);\r\n    };\r\n    NanoSQLInstance.prototype.cleanArgs = function (argDeclarations, args) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var a = {};\r\n        var i = argDeclarations.length ? argDeclarations.length : -1;\r\n        if (i > 0) {\r\n            while (i--) {\r\n                var k2 = argDeclarations[i].split(\":\");\r\n                if (k2.length > 1) {\r\n                    a[k2[0]] = t._cast(k2[1], args[k2[0]] || null);\r\n                }\r\n                else {\r\n                    a[k2[0]] = args[k2[0]] || null;\r\n                }\r\n            }\r\n        }\r\n        return a;\r\n    };\r\n    NanoSQLInstance.prototype._cast = function (type, val) {\r\n        var _this = this;\r\n        var t = typeof val;\r\n        var types = {\r\n            string: t !== \"string\" ? String(val) : val,\r\n            int: t !== \"number\" || val % 1 !== 0 ? parseInt(val || 0) : val,\r\n            float: t !== \"number\" ? parseFloat(val || 0) : val,\r\n            array: Array.isArray(val) ? exports._assign(val || []) : [],\r\n            \"any[]\": Array.isArray(val) ? exports._assign(val || []) : [],\r\n            any: val,\r\n            blob: val,\r\n            uudi: val,\r\n            timeId: val,\r\n            map: t === \"object\" ? exports._assign(val || {}) : {},\r\n            bool: val === true\r\n        };\r\n        var newVal = types[type];\r\n        if (newVal !== undefined) {\r\n            return newVal;\r\n        }\r\n        else if (type.indexOf(\"[]\") !== -1) {\r\n            var arrayOf_1 = type.slice(0, type.lastIndexOf(\"[]\"));\r\n            return (val || []).map(function (v) {\r\n                return _this._cast(arrayOf_1, v);\r\n            });\r\n        }\r\n        return val;\r\n    };\r\n    NanoSQLInstance.prototype.actions = function (actionArray) {\r\n        return this._actions[this._selectedTable] = actionArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.doAction = function (actionName, actionArgs) {\r\n        return this._doAV(\"Action\", this._actions[this._selectedTable], actionName, actionArgs);\r\n    };\r\n    NanoSQLInstance.prototype._doAV = function (AVType, AVList, AVName, AVargs) {\r\n        var _this = this;\r\n        var t = this;\r\n        var selAV = AVList.reduce(function (prev, cur) {\r\n            if (cur.name === AVName)\r\n                return cur;\r\n            return prev;\r\n        }, null);\r\n        if (!selAV) {\r\n            return new lie_ts_1.Promise(function (res, rej) { return rej(\"Action/View Not Found!\"); });\r\n        }\r\n        t._activeAV = AVName;\r\n        var cleanArgs = selAV.args ? t.cleanArgs(selAV.args, AVargs) : {};\r\n        if (t._AVMod) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                t._AVMod(_this._selectedTable, AVType, t._activeAV || \"\", cleanArgs, function (args) {\r\n                    selAV ? selAV.call(args, t).then(function (result) {\r\n                        res(result, t);\r\n                    }) : false;\r\n                }, function (err) {\r\n                    rej(err);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return selAV.call(cleanArgs, t);\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.newFunction = function (functionName, functionType, filterFunction) {\r\n        return this._functions[functionName] = { type: functionType, call: filterFunction }, this;\r\n    };\r\n    NanoSQLInstance.prototype.query = function (action, args) {\r\n        var t = this;\r\n        var query = new _NanoSQLQuery(t._selectedTable, t, t._activeAV);\r\n        t._activeAV = undefined;\r\n        var a = action.toLowerCase();\r\n        if ([\"select\", \"upsert\", \"delete\", \"drop\", \"show tables\", \"describe\"].indexOf(a) !== -1) {\r\n            var newArgs_1 = args || (a === \"select\" || a === \"delete\" ? [] : {});\r\n            if ([\"upsert\", \"delete\", \"drop\"].indexOf(a) !== -1) {\r\n                this._transactionTables.push(t._selectedTable);\r\n            }\r\n            if (action === \"upsert\") {\r\n                var inputArgs_1 = {};\r\n                t._models[t._selectedTable].forEach(function (model) {\r\n                    if (newArgs_1[model.key]) {\r\n                        inputArgs_1[model.key] = t._cast(model.type, newArgs_1[model.key]);\r\n                    }\r\n                });\r\n                if (t._rowFilters[t._selectedTable]) {\r\n                    inputArgs_1 = t._rowFilters[t._selectedTable](inputArgs_1);\r\n                }\r\n                newArgs_1 = inputArgs_1;\r\n            }\r\n            query._action = { type: a, args: newArgs_1 };\r\n        }\r\n        else {\r\n            throw Error;\r\n        }\r\n        return query;\r\n    };\r\n    NanoSQLInstance.prototype.triggerEvent = function (eventData, triggerEvents) {\r\n        var t = this;\r\n        setTimeout(function () {\r\n            var i = triggerEvents.length;\r\n            var j = 0;\r\n            var e;\r\n            var c;\r\n            while (i--) {\r\n                e = triggerEvents[i];\r\n                c = t._callbacks[eventData.table][e].concat(t._callbacks[eventData.table][\"*\"]);\r\n                j = c.length;\r\n                while (j--) {\r\n                    eventData.name = e;\r\n                    c[j](eventData, t);\r\n                }\r\n            }\r\n        }, 0);\r\n    };\r\n    NanoSQLInstance.prototype.default = function (replaceObj) {\r\n        var newObj = {};\r\n        var t = this;\r\n        t._models[t._selectedTable].forEach(function (m) {\r\n            newObj[m.key] = (replaceObj && replaceObj[m.key]) ? replaceObj[m.key] : m.default;\r\n            if (!newObj[m.key]) {\r\n                newObj[m.key] = t._cast(m.type, null);\r\n            }\r\n        });\r\n        return newObj;\r\n    };\r\n    NanoSQLInstance.prototype.beginTransaction = function () {\r\n        this.doingTransaction = true;\r\n        this._transactionTables = [];\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"start\");\r\n    };\r\n    NanoSQLInstance.prototype.endTransaction = function () {\r\n        var _this = this;\r\n        this.doingTransaction = false;\r\n        this._transactionTables.forEach(function (table) {\r\n            if (table.indexOf(\"_\") !== 0) {\r\n                _this.triggerEvent({\r\n                    table: table,\r\n                    query: [],\r\n                    time: new Date().getTime(),\r\n                    result: [],\r\n                    name: \"change\",\r\n                    actionOrView: \"\",\r\n                    changeType: \"transaction\",\r\n                    changedRows: []\r\n                }, [\"change\"]);\r\n            }\r\n        });\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"end\");\r\n    };\r\n    NanoSQLInstance.prototype.queryFilter = function (callBack) {\r\n        this._queryMod = callBack;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.avFilter = function (filterFunc) {\r\n        this._AVMod = filterFunc;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.config = function (args) {\r\n        var t = this;\r\n        if (!t.backend)\r\n            t._preConnectExtend.push(args);\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.extend = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var t = this;\r\n        if (t.backend) {\r\n            if (t.backend._extend) {\r\n                args.unshift(t);\r\n                return t.backend._extend.apply(t.backend, args);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.loadJS = function (table, rows) {\r\n        var t = this;\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            var pointer = 0;\r\n            var rowData = [];\r\n            var next = function () {\r\n                if (pointer < rows.length) {\r\n                    if (rows[pointer]) {\r\n                        t.table(table).query(\"upsert\", rows[pointer]).exec().then(function (res) {\r\n                            rowData.push(res);\r\n                            pointer++;\r\n                            next();\r\n                        });\r\n                    }\r\n                    else {\r\n                        pointer++;\r\n                        next();\r\n                    }\r\n                }\r\n                else {\r\n                    t.endTransaction();\r\n                    res(rowData, t);\r\n                }\r\n            };\r\n            next();\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.rowFilter = function (callBack) {\r\n        return this._rowFilters[this._selectedTable] = callBack, this;\r\n    };\r\n    NanoSQLInstance.prototype.loadCSV = function (table, csv) {\r\n        var t = this;\r\n        var fields = [];\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            lie_ts_1.Promise.all(csv.split(\"\\n\").map(function (v, k) {\r\n                return new lie_ts_1.Promise(function (resolve, reject) {\r\n                    if (k === 0) {\r\n                        fields = v.split(\",\");\r\n                        resolve();\r\n                    }\r\n                    else {\r\n                        var record = {};\r\n                        var row = v.match(/(\".*?\"|[^\",\\s]+)(?=\\s*,|\\s*$)/g) || [];\r\n                        row = row.map(function (str) { return str.replace(/^\"(.+(?=\"$))\"$/, \"$1\"); });\r\n                        var i = fields.length;\r\n                        while (i--) {\r\n                            if (row[i].indexOf(\"{\") === 0 || row[i].indexOf(\"[\") === 0) {\r\n                                row[i] = JSON.parse(row[i].replace(/'/g, \"\"));\r\n                            }\r\n                            record[fields[i]] = row[i];\r\n                        }\r\n                        t.table(table).query(\"upsert\", record).exec().then(function () {\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            })).then(function () {\r\n                t.endTransaction();\r\n                res([], t);\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance._random16Bits = function () {\r\n        if (typeof crypto === \"undefined\") {\r\n            return Math.round(Math.random() * Math.pow(2, 16));\r\n        }\r\n        else {\r\n            if (crypto.getRandomValues) {\r\n                var buf = new Uint16Array(1);\r\n                crypto.getRandomValues(buf);\r\n                return buf[0];\r\n            }\r\n            else if (global !== \"undefined\" && global._crypto.randomBytes) {\r\n                return global._crypto.randomBytes(2).reduce(function (prev, cur) { return cur * prev; });\r\n            }\r\n            else {\r\n                return Math.round(Math.random() * Math.pow(2, 16));\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.timeid = function (ms) {\r\n        var t = this;\r\n        if (!t._tzOffset) {\r\n            t._tzOffset = new Date().getTimezoneOffset() * 60000;\r\n        }\r\n        var time = Math.round((new Date().getTime() + t._tzOffset) / (ms ? 1 : 1000)).toString();\r\n        while (time.length < (ms ? 13 : 10)) {\r\n            time = \"0\" + time;\r\n        }\r\n        return time + \"-\" + (t._random16Bits() + t._random16Bits()).toString(16);\r\n    };\r\n    NanoSQLInstance.uuid = function () {\r\n        var _this = this;\r\n        var r, s, b = \"\";\r\n        return [b, b, b, b, b, b, b, b, b].reduce(function (prev, cur, i) {\r\n            r = _this._random16Bits();\r\n            s = (i === 4 ? i : (i === 5 ? (r % 16 & 0x3 | 0x8).toString(16) : b));\r\n            r = r.toString(16);\r\n            while (r.length < 4)\r\n                r = \"0\" + r;\r\n            return prev + ([3, 4, 5, 6].indexOf(i) >= 0 ? \"-\" : b) + (s + r).slice(0, 4);\r\n        }, b);\r\n    };\r\n    ;\r\n    NanoSQLInstance._hash = function (key) {\r\n        return Math.abs(key.split(\"\").reduce(function (prev, next, i) {\r\n            return ((prev << 5) + prev) + key.charCodeAt(i);\r\n        }, 0));\r\n    };\r\n    return NanoSQLInstance;\r\n}());\r\nexports.NanoSQLInstance = NanoSQLInstance;\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(table, db, actionOrView) {\r\n        this._db = db;\r\n        this._modifiers = [];\r\n        this._table = table;\r\n        this._AV = actionOrView || \"\";\r\n    }\r\n    _NanoSQLQuery.prototype.where = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Where condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"where\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.range = function (limit, offset) {\r\n        return this._addCmd(\"range\", [limit, offset]);\r\n    };\r\n    _NanoSQLQuery.prototype.orderBy = function (args) {\r\n        return this._addCmd(\"orderby\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.groupBy = function (columns) {\r\n        return this._addCmd(\"groupby\", columns);\r\n    };\r\n    _NanoSQLQuery.prototype.having = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Having condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"having\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.join = function (args) {\r\n        if (!args.table || !args.type) {\r\n            this._error = \"Join command requires table and type arguments!\";\r\n        }\r\n        return this._addCmd(\"join\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.limit = function (args) {\r\n        return this._addCmd(\"limit\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.trieSearch = function (column, stringToSearch) {\r\n        return this._addCmd(\"trie\", [column, stringToSearch]);\r\n    };\r\n    _NanoSQLQuery.prototype.offset = function (args) {\r\n        return this._addCmd(\"offset\", args);\r\n    };\r\n    _NanoSQLQuery.prototype._addCmd = function (type, args) {\r\n        return this._modifiers.push({ type: type, args: args }), this;\r\n    };\r\n    _NanoSQLQuery.prototype.toCSV = function (headers) {\r\n        var t = this;\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.exec().then(function (json) {\r\n                var header = t._action.args.length ? t._action.args.map(function (m) {\r\n                    return t._db._models[t._table].filter(function (f) { return f[\"key\"] === m; })[0];\r\n                }) : t._db._models[t._table];\r\n                if (headers) {\r\n                    json.unshift(header.map(function (h) {\r\n                        return h[\"key\"];\r\n                    }));\r\n                }\r\n                res(json.map(function (row, i) {\r\n                    if (headers && i === 0)\r\n                        return row;\r\n                    return header.filter(function (column) {\r\n                        return row[column[\"key\"]] ? true : false;\r\n                    }).map(function (column) {\r\n                        switch (column[\"type\"]) {\r\n                            case \"map\":\r\n                            case \"array\": return '\"' + JSON.stringify(row[column[\"key\"]]).replace(/\"/g, \"'\") + '\"';\r\n                            default: return row[column[\"key\"]];\r\n                        }\r\n                    }).join(\",\");\r\n                }).join(\"\\n\"), t);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype.exec = function () {\r\n        var t = this;\r\n        var _t = t._table;\r\n        if (t._db._hasEvents[_t]) {\r\n            t._db._triggerEvents = (function () {\r\n                switch (t._action.type) {\r\n                    case \"select\": return [t._action.type];\r\n                    case \"delete\":\r\n                    case \"upsert\":\r\n                    case \"drop\": return [t._action.type, \"change\"];\r\n                    default: return [];\r\n                }\r\n            })();\r\n        }\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            if (t._error) {\r\n                rej(t._error);\r\n                throw Error;\r\n            }\r\n            if (!t._db.backend) {\r\n                rej();\r\n                throw Error;\r\n            }\r\n            var _tEvent = function (data, callBack, type, changedRows, isError) {\r\n                if (t._db._hasEvents[_t]) {\r\n                    t._db.triggerEvent({\r\n                        name: \"error\",\r\n                        actionOrView: t._AV,\r\n                        table: _t,\r\n                        query: [t._action].concat(t._modifiers),\r\n                        time: new Date().getTime(),\r\n                        result: data,\r\n                        changeType: type,\r\n                        changedRows: changedRows\r\n                    }, t._db._triggerEvents);\r\n                }\r\n                callBack(data, t._db);\r\n            };\r\n            var execArgs = {\r\n                table: _t,\r\n                query: [t._action].concat(t._modifiers),\r\n                viewOrAction: t._AV,\r\n                onSuccess: function (rows, type, affectedRows) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(rows, t._db);\r\n                    }\r\n                    else {\r\n                        _tEvent(rows, res, type, affectedRows, false);\r\n                    }\r\n                },\r\n                onFail: function (err) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(err, t._db);\r\n                    }\r\n                    else {\r\n                        t._db._triggerEvents = [\"error\"];\r\n                        if (rej)\r\n                            _tEvent(err, rej, \"error\", [], true);\r\n                    }\r\n                }\r\n            };\r\n            if (t._db._queryMod) {\r\n                t._db._queryMod(execArgs, function (newArgs) {\r\n                    t._db.backend._exec(newArgs);\r\n                });\r\n            }\r\n            else {\r\n                t._db.backend._exec(execArgs);\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\nvar _NanoSQLStatic = new NanoSQLInstance();\r\nexports.nSQL = function (setTablePointer) {\r\n    return _NanoSQLStatic.table(setTablePointer);\r\n};\r\n"
        },
        {
          "id": 1,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "name": "./src/db-index.ts",
          "index": 2,
          "index2": 4,
          "size": 9753,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "issuerId": 0,
          "issuerName": "./src/index.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 0,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
              "module": "./src/index.ts",
              "moduleName": "./src/index.ts",
              "type": "cjs require",
              "userRequest": "./db-index",
              "loc": "2:17-38"
            },
            {
              "moduleId": 3,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
              "module": "./src/db-query.ts",
              "moduleName": "./src/db-query.ts",
              "type": "cjs require",
              "userRequest": "./db-index",
              "loc": "3:17-38"
            },
            {
              "moduleId": 4,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
              "module": "./src/db-storage.ts",
              "moduleName": "./src/db-storage.ts",
              "type": "cjs require",
              "userRequest": "./db-index",
              "loc": "3:17-38"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nvar db_storage_1 = require(\"./db-storage\");\r\nvar db_query_1 = require(\"./db-query\");\r\nexports._str = function (index) {\r\n    return [\"_utility\", \"_historyPoints\", \"_pointer\", \"_historyDataRowIDs\"][index];\r\n};\r\nvar _NanoSQLDB = (function () {\r\n    function _NanoSQLDB() {\r\n        var t = this;\r\n        t._pendingQuerys = [];\r\n        t._queryCache = {};\r\n    }\r\n    _NanoSQLDB.prototype._connect = function (connectArgs) {\r\n        var t = this;\r\n        t._databaseID = index_1.NanoSQLInstance._hash(JSON.stringify(connectArgs._models)).toString();\r\n        t._parent = connectArgs._parent;\r\n        t._store = new db_storage_1._NanoSQL_Storage(t, connectArgs);\r\n    };\r\n    _NanoSQLDB.prototype._exec = function (execArgs) {\r\n        var t = this;\r\n        new db_query_1._NanoSQLQuery(t)._doQuery(execArgs);\r\n    };\r\n    _NanoSQLDB.prototype._invalidateCache = function (changedTableID, changedRows, type, action) {\r\n        var t = this;\r\n        t._queryCache[changedTableID] = {};\r\n        if (changedRows.length && action) {\r\n            t._parent.triggerEvent({\r\n                name: \"change\",\r\n                actionOrView: \"\",\r\n                table: t._store._tables[changedTableID]._name,\r\n                query: [],\r\n                time: new Date().getTime(),\r\n                result: [{ msg: action + \" was performed.\", type: action }],\r\n                changedRows: changedRows,\r\n                changeType: type\r\n            }, [\"change\"]);\r\n        }\r\n    };\r\n    _NanoSQLDB.prototype._deepFreeze = function (obj, tableID) {\r\n        if (!obj)\r\n            return obj;\r\n        var t = this;\r\n        t._store._models[tableID].forEach(function (model) {\r\n            var prop = obj[model.key];\r\n            if ([\"map\", \"array\"].indexOf(typeof prop) >= 0) {\r\n                obj[model.key] = t._deepFreeze(prop, tableID);\r\n            }\r\n        });\r\n        return Object.freeze(obj);\r\n    };\r\n    _NanoSQLDB.prototype._transaction = function (type) {\r\n        var t = this;\r\n        if (type === \"start\") {\r\n            t._store._transactionData = {};\r\n            t._store._doingTransaction = true;\r\n        }\r\n        ;\r\n        if (type === \"end\") {\r\n            t._store._doingTransaction = false;\r\n            t._store._execTransaction();\r\n        }\r\n        ;\r\n        return !!t._store._doingTransaction;\r\n    };\r\n    _NanoSQLDB.prototype._extend = function (db, command) {\r\n        var t = this;\r\n        var i;\r\n        var h;\r\n        var j;\r\n        var rowID;\r\n        var rowData;\r\n        var rowKey;\r\n        var store;\r\n        var shiftRowIDs = function (direction, callBack) {\r\n            var results = {};\r\n            var check = (t._store._historyLength - t._store._historyPoint);\r\n            t._store._read(\"_historyPoints\", function (row) {\r\n                return row.historyPoint === check;\r\n            }, function (hps) {\r\n                j = 0;\r\n                var nextPoint = function () {\r\n                    if (j < hps.length) {\r\n                        i = 0;\r\n                        var tableID_1 = hps[j].tableID;\r\n                        var table_1 = t._store._tables[tableID_1];\r\n                        var rows_1 = [];\r\n                        var nextRow_1 = function () {\r\n                            if (i < hps[j].rowKeys.length) {\r\n                                rowID = hps[j].rowKeys[i];\r\n                                if (table_1._pkType === \"int\")\r\n                                    rowID = parseInt(rowID);\r\n                                t._store._read(table_1._name, rowID, function (rowData) {\r\n                                    if (direction > 0)\r\n                                        rows_1.push(rowData[0]);\r\n                                    t._store._read(\"_\" + table_1._name + \"_hist__meta\", rowID, function (row) {\r\n                                        row = index_1._assign(row);\r\n                                        row[0][exports._str(2)] += direction;\r\n                                        var historyRowID = row[0][exports._str(3)][row[0][exports._str(2)]];\r\n                                        t._store._upsert(\"_\" + table_1._name + \"_hist__meta\", rowID, row[0], function () {\r\n                                            t._store._read(\"_\" + table_1._name + \"_hist__data\", historyRowID, function (row) {\r\n                                                var newRow = row[0] ? index_1._assign(row[0]) : null;\r\n                                                t._store._upsert(table_1._name, rowID, newRow, function () {\r\n                                                    if (direction < 0)\r\n                                                        rows_1.push(newRow);\r\n                                                    if (!results[tableID_1])\r\n                                                        results[tableID_1] = { type: hps[j].type, rows: [] };\r\n                                                    results[tableID_1].rows = results[tableID_1].rows.concat(rows_1);\r\n                                                    i++;\r\n                                                    nextRow_1();\r\n                                                });\r\n                                            });\r\n                                        });\r\n                                    });\r\n                                });\r\n                            }\r\n                            else {\r\n                                j++;\r\n                                nextPoint();\r\n                            }\r\n                        };\r\n                        nextRow_1();\r\n                    }\r\n                    else {\r\n                        callBack(results);\r\n                    }\r\n                };\r\n                nextPoint();\r\n            });\r\n        };\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            switch (command) {\r\n                case \"<\":\r\n                    if (!t._store._historyLength || t._store._historyPoint === t._store._historyLength) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        shiftRowIDs(1, function (affectedTables) {\r\n                            t._store._historyPoint++;\r\n                            t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                var description = affectedTables[tableID].type;\r\n                                switch (description) {\r\n                                    case \"inserted\":\r\n                                        description = \"deleted\";\r\n                                        break;\r\n                                    case \"deleted\":\r\n                                        description = \"inserted\";\r\n                                        break;\r\n                                }\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, description, \"undo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \">\":\r\n                    if (!t._store._historyLength || t._store._historyPoint < 1) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        t._store._historyPoint--;\r\n                        t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                        shiftRowIDs(-1, function (affectedTables) {\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, affectedTables[tableID].type, \"redo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \"?\":\r\n                    h = [t._store._historyLength, t._store._historyLength - t._store._historyPoint];\r\n                    if (t._store._historyArray.join(\"+\") !== h.join(\"+\")) {\r\n                        t._store._historyArray = h;\r\n                    }\r\n                    res(t._store._historyArray);\r\n                    break;\r\n                case \"flush_history\":\r\n                case \"flush_db\":\r\n                    t._store._utility(\"w\", \"historyPoint\", 0);\r\n                    t._store._utility(\"w\", \"historyLength\", 0);\r\n                    t._store._historyPoint = 0;\r\n                    t._store._historyLength = 0;\r\n                    Object.keys(t._store._tables).forEach(function (tableID) {\r\n                        var rows;\r\n                        if (t._store._tables[parseInt(tableID)]._name.indexOf(\"_\") === 0) {\r\n                            rows = [];\r\n                        }\r\n                        else {\r\n                            rows = t._store._tables[parseInt(tableID)]._rows;\r\n                            rows = Object.keys(rows).map(function (r) { return rows[r]; });\r\n                        }\r\n                        t._invalidateCache(parseInt(tableID), rows, \"remove\", \"clear\");\r\n                    });\r\n                    if (command === \"flush_db\") {\r\n                        t._store._clear(\"all\", res);\r\n                    }\r\n                    else {\r\n                        t._store._clear(\"hist\", res);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLDB;\r\n}());\r\nexports._NanoSQLDB = _NanoSQLDB;\r\n"
        },
        {
          "id": 2,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\lie-ts\\index.js",
          "name": "./~/lie-ts/index.js",
          "index": 3,
          "index2": 0,
          "size": 8489,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "issuerId": 0,
          "issuerName": "./src/index.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 0,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
              "module": "./src/index.ts",
              "moduleName": "./src/index.ts",
              "type": "cjs require",
              "userRequest": "lie-ts",
              "loc": "3:15-32"
            },
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
              "module": "./src/db-index.ts",
              "moduleName": "./src/db-index.ts",
              "type": "cjs require",
              "userRequest": "lie-ts",
              "loc": "3:15-32"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar _INTERNAL = function () { };\r\nvar _REJECTED = ['R'];\r\nvar _FULFILLED = ['F'];\r\nvar _PENDING = ['P'];\r\nvar setFast = typeof setImmediate !== \"undefined\" ? setImmediate : setTimeout;\r\nvar Promise = (function () {\r\n    function Promise(resolver) {\r\n        this._state = _PENDING;\r\n        this._queue = [];\r\n        this._outcome = void 0;\r\n        if (resolver !== _INTERNAL) {\r\n            _safelyResolveThenable(this, resolver);\r\n        }\r\n    }\r\n    Promise.prototype.catch = function (onRejected) {\r\n        return this.then(function () { }, onRejected);\r\n    };\r\n    Promise.prototype.then = function (onFulfilled, onRejected) {\r\n        if (typeof onFulfilled !== 'function' && this._state === _FULFILLED ||\r\n            typeof onRejected !== 'function' && this._state === _REJECTED) {\r\n            return this;\r\n        }\r\n        var promise = new Promise(_INTERNAL);\r\n        if (this._state !== _PENDING) {\r\n            var resolver = this._state === _FULFILLED ? onFulfilled : onRejected;\r\n            _unwrap(promise, resolver, this._outcome);\r\n        }\r\n        else {\r\n            this._queue.push(new _QueueItem(promise, onFulfilled, onRejected));\r\n        }\r\n        return promise;\r\n    };\r\n    /**\r\n     *\r\n     * @static\r\n     * @param {any} value\r\n     * @returns\r\n     *\r\n     * @memberOf Promise\r\n     */\r\n    Promise.resolve = function (value) {\r\n        if (value instanceof this) {\r\n            return value;\r\n        }\r\n        return _handlers._resolve(new Promise(_INTERNAL), value);\r\n    };\r\n    /**\r\n     *\r\n     * @static\r\n     * @param {any} reason\r\n     * @returns\r\n     *\r\n     * @memberOf Promise\r\n     */\r\n    Promise.reject = function (reason) {\r\n        return _handlers._reject(new Promise(_INTERNAL), reason);\r\n    };\r\n    Promise.all = function (iterable) {\r\n        var self = this;\r\n        var len = iterable.length;\r\n        var called = false;\r\n        var values = new Array(len);\r\n        var resolved = 0;\r\n        var i = -1;\r\n        var promise = new Promise(_INTERNAL);\r\n        if (!len) {\r\n            return this.resolve([]);\r\n        }\r\n        while (++i < len) {\r\n            allResolver(iterable[i], i);\r\n        }\r\n        return promise;\r\n        function allResolver(value, i) {\r\n            self.resolve(value).then(resolveFromAll, function (error) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._reject(promise, error);\r\n                }\r\n            });\r\n            function resolveFromAll(outValue) {\r\n                values[i] = outValue;\r\n                if (++resolved === len && !called) {\r\n                    called = true;\r\n                    _handlers._resolve(promise, values);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Promise.race = function (iterable) {\r\n        var self = this;\r\n        var len = iterable.length;\r\n        var called = false;\r\n        var i = -1;\r\n        var promise = new Promise(_INTERNAL);\r\n        if (Array.isArray(iterable) !== false) {\r\n            return this.reject(new TypeError());\r\n        }\r\n        function resolver(value) {\r\n            self.resolve(value).then(function (response) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._resolve(promise, response);\r\n                }\r\n            }, function (error) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._reject(promise, error);\r\n                }\r\n            });\r\n        }\r\n        if (!len) {\r\n            return this.resolve([]);\r\n        }\r\n        while (++i < len) {\r\n            resolver(iterable[i]);\r\n        }\r\n        return promise;\r\n    };\r\n    return Promise;\r\n}());\r\nexports.Promise = Promise;\r\n/**\r\n * @internal\r\n *\r\n * @export\r\n * @class _QueueItem\r\n */\r\nvar _QueueItem = (function () {\r\n    function _QueueItem(promise, onFulfilled, onRejected) {\r\n        this._promise = promise;\r\n        if (typeof onFulfilled === 'function') {\r\n            this._onFulfilled = onFulfilled;\r\n            this._callFulfilled = this._otherCallFulfilled;\r\n        }\r\n        if (typeof onRejected === 'function') {\r\n            this._onRejected = onRejected;\r\n            this._callRejected = this._otherCallRejected;\r\n        }\r\n    }\r\n    _QueueItem.prototype._callFulfilled = function (value) {\r\n        _handlers._resolve(this._promise, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._otherCallFulfilled = function (value) {\r\n        _unwrap(this._promise, this._onFulfilled, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._callRejected = function (value) {\r\n        _handlers._reject(this._promise, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._otherCallRejected = function (value) {\r\n        _unwrap(this._promise, this._onRejected, value);\r\n    };\r\n    ;\r\n    return _QueueItem;\r\n}());\r\nexports._QueueItem = _QueueItem;\r\n/**\r\n *\r\n * @internal\r\n * @param {any} promise\r\n * @param {any} func\r\n * @param {any} value\r\n */\r\nfunction _unwrap(promise, func, value) {\r\n    setFast(function () {\r\n        var returnValue;\r\n        try {\r\n            returnValue = func.apply(null, value);\r\n        }\r\n        catch (e) {\r\n            return _handlers._reject(promise, e);\r\n        }\r\n        if (returnValue === promise) {\r\n            _handlers._reject(promise, new TypeError());\r\n        }\r\n        else {\r\n            _handlers._resolve(promise, returnValue);\r\n        }\r\n        return null;\r\n    });\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @class _handlers\r\n */\r\nvar _handlers = (function () {\r\n    function _handlers() {\r\n    }\r\n    _handlers._resolve = function (self, value) {\r\n        var result = _tryCatch(_getThen, value);\r\n        var thenable = result._value;\r\n        var i = -1;\r\n        var len = self._queue.length;\r\n        if (result._status === 'error') {\r\n            return _handlers._reject(self, result._value);\r\n        }\r\n        if (thenable) {\r\n            _safelyResolveThenable(self, thenable);\r\n        }\r\n        else {\r\n            self._state = _FULFILLED;\r\n            self._outcome = value;\r\n            while (++i < len) {\r\n                self._queue[i]._callFulfilled(value);\r\n            }\r\n        }\r\n        return self;\r\n    };\r\n    ;\r\n    _handlers._reject = function (self, error) {\r\n        self._state = _REJECTED;\r\n        self._outcome = error;\r\n        var i = -1;\r\n        var len = self._queue.length;\r\n        while (++i < len) {\r\n            self._queue[i]._callRejected(error);\r\n        }\r\n        return self;\r\n    };\r\n    ;\r\n    return _handlers;\r\n}());\r\n/**\r\n *\r\n * @internal\r\n * @param {any} obj\r\n * @returns\r\n */\r\nfunction _getThen(obj) {\r\n    // Make sure we only access the accessor once as required by the spec\r\n    var then = obj && obj.then;\r\n    if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\r\n        return function appyThen() {\r\n            then.apply(obj, arguments);\r\n        };\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @param {Promise<any>} self\r\n * @param {(onSuccess:(...T) => void, onFail:(...T) => void) => void} thenable\r\n */\r\nfunction _safelyResolveThenable(self, thenable) {\r\n    // Either fulfill, reject or reject with error\r\n    var called = false;\r\n    function onError() {\r\n        var value = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            value[_i] = arguments[_i];\r\n        }\r\n        if (called) {\r\n            return;\r\n        }\r\n        called = true;\r\n        _handlers._reject(self, value);\r\n    }\r\n    function onSuccess() {\r\n        var value = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            value[_i] = arguments[_i];\r\n        }\r\n        if (called) {\r\n            return;\r\n        }\r\n        called = true;\r\n        _handlers._resolve(self, value);\r\n    }\r\n    function tryToUnwrap() {\r\n        thenable(onSuccess, onError);\r\n    }\r\n    var result = _tryCatch(tryToUnwrap);\r\n    if (result._status === 'error') {\r\n        onError(result._value);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @param {any} func\r\n * @param {*} [values]\r\n * @returns\r\n */\r\nfunction _tryCatch(func, values) {\r\n    var out = { _status: null, _value: null };\r\n    try {\r\n        out._value = func(values);\r\n        out._status = 'success';\r\n    }\r\n    catch (e) {\r\n        out._status = 'error';\r\n        out._value = e;\r\n    }\r\n    return out;\r\n}\r\n"
        },
        {
          "id": 3,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
          "name": "./src/db-query.ts",
          "index": 5,
          "index2": 1,
          "size": 42349,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "issuerId": 1,
          "issuerName": "./src/db-index.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
              "module": "./src/db-index.ts",
              "moduleName": "./src/db-index.ts",
              "type": "cjs require",
              "userRequest": "./db-query",
              "loc": "5:17-38"
            },
            {
              "moduleId": 4,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
              "module": "./src/db-storage.ts",
              "moduleName": "./src/db-storage.ts",
              "type": "cjs require",
              "userRequest": "./db-query",
              "loc": "4:17-38"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 3,
          "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar minMax = function (type, row, args, ptr, prev) {\r\n    var key = args[0];\r\n    if (ptr[0] === 0)\r\n        prev[key] = type === -1 ? Number.MAX_VALUE : Number.MIN_VALUE;\r\n    var nextRow = {};\r\n    if (type === -1 ? parseFloat(row[key]) < parseFloat(prev[key]) : parseFloat(row[key]) > parseFloat(prev[key])) {\r\n        nextRow = row;\r\n    }\r\n    else {\r\n        nextRow = prev;\r\n    }\r\n    if (ptr[0] === ptr[1]) {\r\n        var r = index_1._assign(nextRow);\r\n        r[type === -1 ? \"MIN\" : \"MAX\"] = nextRow[key];\r\n        return r;\r\n    }\r\n    else {\r\n        return nextRow;\r\n    }\r\n};\r\nexports._functions = {\r\n    SUM: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.SUM = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    MIN: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(-1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    MAX: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    AVG: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.AVG = (prev / (ptr[1] + 1)) || prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    COUNT: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            if (args[0] === \"*\") {\r\n                prev++;\r\n            }\r\n            else {\r\n                prev += row[args[0]] ? 1 : 0;\r\n            }\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.COUNT = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    }\r\n};\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(database) {\r\n        this._db = database;\r\n    }\r\n    _NanoSQLQuery.prototype._doQuery = function (query) {\r\n        var t = this;\r\n        t._tableID = index_1.NanoSQLInstance._hash(query.table);\r\n        t._mod = [];\r\n        t._act = undefined;\r\n        var simpleQuery = [];\r\n        query.query.forEach(function (q) {\r\n            if ([\"upsert\", \"select\", \"delete\", \"drop\"].indexOf(q.type) >= 0) {\r\n                t._act = q;\r\n                if (q.type === \"select\")\r\n                    t._queryHash = index_1.NanoSQLInstance._hash(JSON.stringify(query.query));\r\n            }\r\n            else if ([\"show tables\", \"describe\"].indexOf(q.type) >= 0) {\r\n                simpleQuery.push(q);\r\n            }\r\n            else {\r\n                t._mod.push(q);\r\n            }\r\n        });\r\n        if (simpleQuery.length) {\r\n            switch (simpleQuery[0].type) {\r\n                case \"show tables\":\r\n                    query.onSuccess([{ tables: Object.keys(t._db._store._tables).map(function (ta) { return t._db._store._tables[ta]._name; }) }], \"info\", []);\r\n                    break;\r\n                case \"describe\":\r\n                    var getTable_1;\r\n                    var tableName_1 = t._tableID;\r\n                    var rows = {};\r\n                    Object.keys(t._db._store._tables).forEach(function (ta) {\r\n                        if (parseInt(ta) === t._tableID) {\r\n                            getTable_1 = index_1._assign(t._db._store._models[ta]);\r\n                            tableName_1 = t._db._store._tables[ta]._name;\r\n                        }\r\n                    });\r\n                    rows[tableName_1] = getTable_1;\r\n                    query.onSuccess([rows], \"info\", []);\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            t._execQuery(function (result, changeType, affectedRows) {\r\n                query.onSuccess(result, changeType, affectedRows);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getMod = function (name) {\r\n        return this._mod.filter(function (v) { return v.type === name; }).pop();\r\n    };\r\n    _NanoSQLQuery.prototype._execQuery = function (callBack) {\r\n        var t = this;\r\n        if (!t._act)\r\n            return;\r\n        var doQuery = function (rows) {\r\n            if (!t._act)\r\n                return;\r\n            switch (t._act.type) {\r\n                case \"upsert\":\r\n                    t._upsert(rows, callBack);\r\n                    break;\r\n                case \"select\":\r\n                    t._select(rows, callBack);\r\n                    break;\r\n                case \"drop\":\r\n                case \"delete\":\r\n                    t._remove(rows, callBack);\r\n                    break;\r\n            }\r\n        };\r\n        var tableData = t._db._store._tables[t._tableID];\r\n        if (!t._getMod(\"join\") && t._act.type !== \"drop\") {\r\n            if (t._getMod(\"where\")) {\r\n                var whereArgs_1 = t._getMod(\"where\").args;\r\n                var isOptimizedWhere_1 = function (wArgs) {\r\n                    if ([\"=\", \"IN\", \"BETWEEN\"].indexOf(wArgs[1]) !== -1) {\r\n                        if (wArgs[0] === tableData._pk) {\r\n                            return 0;\r\n                        }\r\n                        else if (tableData._secondaryIndexes.indexOf(wArgs[0]) !== -1) {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                    return 1;\r\n                };\r\n                var doFastWhere_1 = function (wArgs, callBack) {\r\n                    var tableName = wArgs[0] === tableData._pk ? tableData._name : \"_\" + tableData._name + \"_idx_\" + wArgs[0];\r\n                    switch (wArgs[1]) {\r\n                        case \"=\":\r\n                            t._db._store._read(tableName, wArgs[2], function (rows) {\r\n                                callBack(rows);\r\n                            });\r\n                            break;\r\n                        case \"IN\":\r\n                            var ptr_1 = 0;\r\n                            var resultRows_1 = [];\r\n                            var step_1 = function () {\r\n                                if (ptr_1 < wArgs[2].length) {\r\n                                    t._db._store._read(tableName, wArgs[2][ptr_1], function (rows) {\r\n                                        resultRows_1 = resultRows_1.concat(rows);\r\n                                        ptr_1++;\r\n                                        step_1();\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    callBack(resultRows_1);\r\n                                }\r\n                            };\r\n                            step_1();\r\n                            break;\r\n                        case \"BETWEEN\":\r\n                            t._db._store._readRange(tableName, wArgs[0], wArgs[2], callBack);\r\n                            break;\r\n                    }\r\n                };\r\n                var doFastRead = false;\r\n                if (typeof whereArgs_1[0] === \"string\") {\r\n                    doFastRead = isOptimizedWhere_1(whereArgs_1) === 0;\r\n                }\r\n                else {\r\n                    doFastRead = whereArgs_1.reduce(function (prev, cur, i) {\r\n                        if (i % 2 === 1)\r\n                            return prev;\r\n                        return prev + isOptimizedWhere_1(cur);\r\n                    }, 0) === 0;\r\n                }\r\n                if (doFastRead) {\r\n                    if (typeof whereArgs_1[0] === \"string\") {\r\n                        doFastWhere_1(whereArgs_1, doQuery);\r\n                    }\r\n                    else {\r\n                        var resultRows_2 = [];\r\n                        var ptr_2 = 0;\r\n                        var lastCommand_1 = \"\";\r\n                        var nextWhere_1 = function () {\r\n                            if (ptr_2 < whereArgs_1.length) {\r\n                                if (ptr_2 % 2 === 1) {\r\n                                    lastCommand_1 = whereArgs_1[ptr_2];\r\n                                    ptr_2++;\r\n                                    nextWhere_1();\r\n                                }\r\n                                else {\r\n                                    doFastWhere_1(whereArgs_1[ptr_2], function (rows) {\r\n                                        if (lastCommand_1 === \"AND\") {\r\n                                            var idx_1 = rows.map(function (r) { return r[tableData._pk]; });\r\n                                            resultRows_2 = resultRows_2.filter(function (row) {\r\n                                                return idx_1.indexOf(row[tableData._pk]) !== -1;\r\n                                            });\r\n                                        }\r\n                                        else {\r\n                                            resultRows_2 = resultRows_2.concat(rows);\r\n                                        }\r\n                                        ptr_2++;\r\n                                        nextWhere_1();\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                doQuery(resultRows_2);\r\n                            }\r\n                        };\r\n                        nextWhere_1();\r\n                    }\r\n                }\r\n                else {\r\n                    t._db._store._read(tableData._name, function (row) {\r\n                        return row && t._where(row, whereArgs_1);\r\n                    }, function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n            }\r\n            else if (t._getMod(\"range\")) {\r\n                var rangeArgs = t._getMod(\"range\").args;\r\n                t._getRange(rangeArgs[0], rangeArgs[1], doQuery);\r\n            }\r\n            else if (t._getMod(\"trie\")) {\r\n                var trieArgs = t._getMod(\"trie\").args;\r\n                var words_1 = tableData._trieObjects[trieArgs[0]].getPrefix(String(trieArgs[1]).toLocaleLowerCase());\r\n                var indexTable_1 = \"_\" + tableData._name + \"_idx_\" + trieArgs[0];\r\n                var ptr_3 = 0;\r\n                var resultRows_3 = [];\r\n                var step_2 = function () {\r\n                    if (ptr_3 < words_1.length) {\r\n                        t._db._store._read(indexTable_1, words_1[ptr_3], function (rows) {\r\n                            resultRows_3 = resultRows_3.concat(rows);\r\n                            ptr_3++;\r\n                            step_2();\r\n                        });\r\n                    }\r\n                    else {\r\n                        doQuery(resultRows_3);\r\n                    }\r\n                };\r\n                step_2();\r\n            }\r\n            else {\r\n                if (t._act.type !== \"upsert\") {\r\n                    t._db._store._read(tableData._name, \"all\", function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n                else {\r\n                    doQuery([]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            doQuery([]);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getRange = function (limit, offset, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var startIndex = table._index[offset];\r\n        var endIndex = table._index[offset + (limit - 1)];\r\n        t._db._store._readRange(table._name, table._pk, [startIndex, endIndex], function (rows) {\r\n            callBack(rows);\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._updateRow = function (rowPK, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var qArgs = t._act.args;\r\n        var updateType = (function () {\r\n            if (t._act) {\r\n                if (t._act.type === \"delete\" && !qArgs.length) {\r\n                    return \"drop\";\r\n                }\r\n            }\r\n            return t._act ? t._act.type : \"\";\r\n        })();\r\n        var updateSecondaryIndex = function (newRow, rem) {\r\n            if (table._name.indexOf(\"_\") !== 0) {\r\n                var emptyColumns_1 = [];\r\n                table._secondaryIndexes.forEach(function (key) {\r\n                    var idxTable = \"_\" + table._name + \"_idx_\" + key;\r\n                    var rowID = String(newRow[key]).toLocaleLowerCase();\r\n                    t._db._store._read(idxTable, rowID, function (rows) {\r\n                        var indexedRows = [];\r\n                        if (rows.length && rows[0].rowPK)\r\n                            indexedRows = indexedRows.concat(rows[0].rowPK);\r\n                        if (!rem)\r\n                            indexedRows.push(newRow[table._pk]);\r\n                        indexedRows = indexedRows.filter(function (item, pos) {\r\n                            return indexedRows.indexOf(item) === pos || !(rem && item === newRow[table._pk]);\r\n                        });\r\n                        if (indexedRows.length) {\r\n                            t._db._store._upsert(idxTable, rowID, {\r\n                                id: newRow[key],\r\n                                rowPK: indexedRows\r\n                            }, function () { });\r\n                        }\r\n                        else {\r\n                            emptyColumns_1.push(key);\r\n                            t._db._store._delete(idxTable, rowID);\r\n                        }\r\n                    }, true);\r\n                });\r\n                table._trieColumns.forEach(function (key) {\r\n                    var word = String(newRow[key]).toLocaleLowerCase();\r\n                    if (emptyColumns_1.indexOf(key) !== -1) {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].removeWord(word);\r\n                    }\r\n                    else {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].addWord(word);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        var writeChanges = function (newRow) {\r\n            if (updateType === \"upsert\") {\r\n                updateSecondaryIndex(newRow);\r\n                t._db._store._upsert(table._name, rowPK, newRow, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n            else {\r\n                updateSecondaryIndex(newRow, true);\r\n                t._db._store._delete(table._name, rowPK, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n        };\r\n        if (t._db._store._doingTransaction) {\r\n            if (updateType === \"upsert\") {\r\n                writeChanges(qArgs);\r\n            }\r\n            else {\r\n                writeChanges({});\r\n            }\r\n            return;\r\n        }\r\n        t._db._store._read(table._name, rowPK, function (rows) {\r\n            var newRow = {};\r\n            var oldRow = rows[0] || {};\r\n            var doRemove = false;\r\n            switch (updateType) {\r\n                case \"upsert\":\r\n                    newRow = oldRow ? index_1._assign(oldRow) : {};\r\n                    Object.keys(qArgs).forEach(function (k) {\r\n                        newRow[k] = qArgs[k];\r\n                    });\r\n                    var table_1 = t._db._store._tables[t._tableID];\r\n                    table_1._keys.forEach(function (k, i) {\r\n                        var def = table_1._defaults[i];\r\n                        if (!newRow[k] && def)\r\n                            newRow[k] = def;\r\n                    });\r\n                    break;\r\n                case \"delete\":\r\n                    newRow = oldRow ? index_1._assign(oldRow) : {};\r\n                    if (qArgs && qArgs.length) {\r\n                        qArgs.forEach(function (column) {\r\n                            newRow[column] = null;\r\n                        });\r\n                    }\r\n                    else {\r\n                        doRemove = true;\r\n                        newRow = {};\r\n                    }\r\n                    break;\r\n            }\r\n            var finishUpdate = function () {\r\n                if (table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory && table._pk.length) {\r\n                    t._db._store._read(\"_\" + table._name + \"_hist__meta\", rowPK, function (rows) {\r\n                        if (!rows.length || !rows[0]) {\r\n                            rows[0] = {};\r\n                            rows[0][db_index_1._str(2)] = 0;\r\n                            rows[0][db_index_1._str(3)] = [];\r\n                            rows[0].id = rowPK;\r\n                        }\r\n                        rows[0][db_index_1._str(3)].unshift(len);\r\n                        t._db._store._upsert(\"_\" + table._name + \"_hist__meta\", rowPK, rows[0]);\r\n                    });\r\n                }\r\n                writeChanges(newRow);\r\n            };\r\n            var len = 0;\r\n            if (!doRemove && table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                t._db._store._upsert(\"_\" + table._name + \"_hist__data\", null, newRow, function (rowID) {\r\n                    len = parseInt(rowID);\r\n                    finishUpdate();\r\n                });\r\n            }\r\n            else {\r\n                finishUpdate();\r\n            }\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._tableChanged = function (updatedRowPKs, describe, callBack) {\r\n        var _this = this;\r\n        var t = this, k = 0, j = 0;\r\n        if (t._db._store._doingTransaction) {\r\n            callBack([], \"trans\", []);\r\n            return;\r\n        }\r\n        if (updatedRowPKs.length > 0) {\r\n            var completeChange_1 = function () {\r\n                if (t._db._store._doHistory) {\r\n                    if (!t._db._store._doingTransaction && t._db._store._historyPoint === 0) {\r\n                        t._db._store._historyLength++;\r\n                    }\r\n                    t._db._store._utility(\"w\", \"historyLength\", t._db._store._historyLength);\r\n                    t._db._store._utility(\"w\", \"historyPoint\", t._db._store._historyPoint);\r\n                    t._db._store._upsert(\"_historyPoints\", null, {\r\n                        historyPoint: t._db._store._historyLength - t._db._store._historyPoint,\r\n                        tableID: t._tableID,\r\n                        rowKeys: updatedRowPKs.map(function (r) { return parseInt(r); }),\r\n                        type: describe\r\n                    }, function (rowID) {\r\n                        var table = t._db._store._tables[_this._tableID];\r\n                        t._db._invalidateCache(t._tableID, [], \"\");\r\n                        t._db._store._read(table._name, function (row) {\r\n                            return row && updatedRowPKs.indexOf(row[table._pk]) !== -1;\r\n                        }, function (rows) {\r\n                            callBack([{ msg: updatedRowPKs.length + \" row(s) \" + describe }], describe, rows);\r\n                        });\r\n                    });\r\n                }\r\n                else {\r\n                    var table_2 = t._db._store._tables[t._tableID];\r\n                    t._db._invalidateCache(t._tableID, [], \"\");\r\n                    t._db._store._read(table_2._name, function (row) {\r\n                        return row && updatedRowPKs.indexOf(row[table_2._pk]) !== -1;\r\n                    }, function (rows) {\r\n                        callBack([{ msg: updatedRowPKs.length + \" row(s) \" + describe }], describe, rows);\r\n                    });\r\n                }\r\n            };\r\n            if (t._db._store._doHistory) {\r\n                if (t._db._store._historyPoint > 0) {\r\n                    t._db._store._read(\"_historyPoints\", function (hp) {\r\n                        if (hp.historyPoint > t._db._store._historyLength - t._db._store._historyPoint)\r\n                            return true;\r\n                        return false;\r\n                    }, function (historyPoints) {\r\n                        j = 0;\r\n                        var nextPoint = function () {\r\n                            if (j < historyPoints.length) {\r\n                                var tableName_2 = t._db._store._tables[historyPoints[j].tableID]._name;\r\n                                k = 0;\r\n                                var nextRow_1 = function () {\r\n                                    if (k < historyPoints[j].rowKeys.length) {\r\n                                        t._db._store._read(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], function (rows) {\r\n                                            rows[0] = index_1._assign(rows[0]);\r\n                                            rows[0][db_index_1._str(2)] = 0;\r\n                                            var del = rows[0][db_index_1._str(3)].shift();\r\n                                            t._db._store._upsert(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], rows[0], function () {\r\n                                                if (del) {\r\n                                                    t._db._store._delete(\"_\" + tableName_2 + \"_hist__data\", del, function () {\r\n                                                        k++;\r\n                                                        nextRow_1();\r\n                                                    });\r\n                                                }\r\n                                                else {\r\n                                                    k++;\r\n                                                    nextRow_1();\r\n                                                }\r\n                                            });\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        j++;\r\n                                        nextPoint();\r\n                                    }\r\n                                };\r\n                                t._db._store._delete(\"_historyPoints\", historyPoints[j].id, function () {\r\n                                    nextRow_1();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._db._store._historyLength -= t._db._store._historyPoint;\r\n                                t._db._store._historyPoint = 0;\r\n                                completeChange_1();\r\n                                return;\r\n                            }\r\n                        };\r\n                        nextPoint();\r\n                    });\r\n                }\r\n                else {\r\n                    completeChange_1();\r\n                }\r\n            }\r\n            else {\r\n                completeChange_1();\r\n            }\r\n        }\r\n        else {\r\n            callBack([{ msg: \"0 rows \" + describe }], describe, []);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._upsert = function (queryRows, callBack) {\r\n        var t = this;\r\n        var scribe = \"\", i, changedPKs = [];\r\n        var qArgs = t._act.args || {}, table = t._db._store._tables[t._tableID], pk = table._pk, whereMod = t._getMod(\"where\");\r\n        if (whereMod) {\r\n            scribe = \"modified\";\r\n            changedPKs = queryRows.map(function (r) { return r[table._pk]; });\r\n            i = 0;\r\n            var update_1 = function () {\r\n                if (i < queryRows.length) {\r\n                    t._updateRow(queryRows[i][pk], function () {\r\n                        i++;\r\n                        update_1();\r\n                    });\r\n                }\r\n                else {\r\n                    t._tableChanged(changedPKs, scribe, callBack);\r\n                }\r\n            };\r\n            update_1();\r\n        }\r\n        else {\r\n            scribe = \"inserted\";\r\n            if (!qArgs[pk]) {\r\n                switch (table._pkType) {\r\n                    case \"int\":\r\n                        qArgs[pk] = table._incriment++;\r\n                        break;\r\n                    case \"uuid\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.uuid();\r\n                        break;\r\n                    case \"timeId\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid();\r\n                        break;\r\n                    case \"timeIdms\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid(true);\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (table._pkType === \"int\") {\r\n                    table._incriment = Math.max(qArgs[pk] + 1, table._incriment);\r\n                }\r\n            }\r\n            var objPK = qArgs[pk] ? qArgs[pk] : table._index.length;\r\n            changedPKs = [objPK];\r\n            if (table._index.indexOf(objPK) === -1) {\r\n                var tableName = t._db._store._tables[t._tableID]._name;\r\n                if (tableName.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                    var histTable = \"_\" + tableName + \"_hist__meta\";\r\n                    var histRow = {};\r\n                    histRow[db_index_1._str(2)] = 0;\r\n                    histRow[db_index_1._str(3)] = [0];\r\n                    t._db._store._upsert(histTable, objPK, histRow);\r\n                }\r\n                table._index.push(objPK);\r\n            }\r\n            t._updateRow(objPK, function () {\r\n                t._tableChanged(changedPKs, scribe, callBack);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getTableID = function () {\r\n        return this._joinTable ? this._joinTable : this._tableID;\r\n    };\r\n    _NanoSQLQuery.prototype._select = function (queryRows, callBack) {\r\n        var t = this;\r\n        if (t._db._queryCache[t._tableID][t._queryHash]) {\r\n            callBack(t._db._queryCache[t._tableID][t._queryHash], \"none\", []);\r\n            return;\r\n        }\r\n        var mods = [\"join\", \"groupby\", \"having\", \"orderby\", \"offset\", \"limit\"];\r\n        var curMod, column, i, k, rows, obj, rowData, groups = {};\r\n        var sortObj = function (objA, objB, columns) {\r\n            return Object.keys(columns).reduce(function (prev, cur) {\r\n                if (!prev) {\r\n                    if (objA[cur] === objB[cur])\r\n                        return 0;\r\n                    return (objA[cur] > objB[cur] ? 1 : -1) * (columns[cur] === \"desc\" ? -1 : 1);\r\n                }\r\n                else {\r\n                    return prev;\r\n                }\r\n            }, 0);\r\n        };\r\n        var modifyQuery = function (tableIndex, modIndex, next) {\r\n            curMod = t._getMod(mods[modIndex]);\r\n            if (modIndex === 2) {\r\n                var functions_1 = [];\r\n                if (qArgs.length) {\r\n                    var funcs_1 = Object.keys(exports._functions).map(function (f) { return f + \"(\"; });\r\n                    var keepColumns_1 = [];\r\n                    functions_1 = qArgs.filter(function (q) {\r\n                        var hasFunc = funcs_1.reduce(function (prev, cur) {\r\n                            return (q.indexOf(cur) < 0 ? 0 : 1) + prev;\r\n                        }, 0) || 0;\r\n                        if (hasFunc > 0) {\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            keepColumns_1.push(q);\r\n                            return false;\r\n                        }\r\n                    }).map(function (selectString) {\r\n                        var regex = selectString.match(/(.*)\\((.*)\\)/);\r\n                        var funcName = regex[1].trim();\r\n                        var columnName = (selectString.match(/\\sAS\\s(.*)/) || []).pop() || funcName;\r\n                        var args = regex[2].split(\",\").map(function (s) { return s.trim(); });\r\n                        if (exports._functions[funcName].type === \"simple\" && columnName === funcName) {\r\n                            columnName = args[0];\r\n                        }\r\n                        keepColumns_1.push(columnName);\r\n                        return {\r\n                            name: funcName,\r\n                            args: args,\r\n                            as: columnName.trim(),\r\n                            type: exports._functions[funcName].type\r\n                        };\r\n                    });\r\n                    var rows_1 = [];\r\n                    if (functions_1.length) {\r\n                        var prevFunc_1;\r\n                        var doFunctions_1 = function (rows) {\r\n                            return functions_1.sort(function (a, b) {\r\n                                return a.type > b.type ? 1 : -1;\r\n                            }).reduce(function (prev, curr) {\r\n                                var len = prev.length - 1;\r\n                                if (curr.type === \"aggregate\") {\r\n                                    var newRows = rows.slice();\r\n                                    len = newRows.length - 1;\r\n                                    newRows = [newRows.reduce(function (p, v, i) {\r\n                                            return exports._functions[curr.name].call(v, curr.args, [i, len], p);\r\n                                        }, {})];\r\n                                    if (prevFunc_1) {\r\n                                        newRows[0][prevFunc_1] = prev[0][prevFunc_1];\r\n                                    }\r\n                                    prev = newRows;\r\n                                    prevFunc_1 = curr.name;\r\n                                }\r\n                                else {\r\n                                    prev = prev.map(function (v, i) {\r\n                                        return exports._functions[curr.name].call(v, curr.args, [i, len]);\r\n                                    });\r\n                                }\r\n                                if (curr.name !== curr.as) {\r\n                                    keepColumns_1.push(curr.name + \" AS \" + curr.as);\r\n                                }\r\n                                else {\r\n                                    keepColumns_1.push(curr.name);\r\n                                }\r\n                                return prev;\r\n                            }, rows.slice());\r\n                        };\r\n                        var groupKeys = Object.keys(groups);\r\n                        if (groupKeys.length) {\r\n                            rows_1 = groupKeys\r\n                                .map(function (k) { return prevFunc_1 = null, doFunctions_1(groups[k]); })\r\n                                .reduce(function (prev, curr) {\r\n                                return prev = prev.concat(curr), prev;\r\n                            }, []);\r\n                        }\r\n                        else {\r\n                            rows_1 = doFunctions_1(tableIndex);\r\n                        }\r\n                    }\r\n                    else {\r\n                        rows_1 = tableIndex;\r\n                    }\r\n                    var convertKeys_1 = keepColumns_1.map(function (n) {\r\n                        return n.match(/(.*)\\sAS\\s(.*)/) || n;\r\n                    }).filter(function (n) { return n; }) || [];\r\n                    if (convertKeys_1.length) {\r\n                        rows_1 = rows_1.map(function (r) {\r\n                            r = index_1._assign(r);\r\n                            var newRow = {};\r\n                            convertKeys_1.forEach(function (key) {\r\n                                if (typeof key === \"string\") {\r\n                                    newRow[key] = r[key];\r\n                                }\r\n                                else {\r\n                                    newRow[key[2]] = r[key[1]];\r\n                                }\r\n                            });\r\n                            return newRow;\r\n                        });\r\n                    }\r\n                    tableIndex = rows_1;\r\n                }\r\n            }\r\n            if (!curMod)\r\n                return next(tableIndex);\r\n            switch (modIndex) {\r\n                case 0:\r\n                    var joinConditions = void 0;\r\n                    if (curMod.args.type !== \"cross\") {\r\n                        joinConditions = {\r\n                            _left: curMod.args.where[0].split(\".\").pop(),\r\n                            _check: curMod.args.where[1],\r\n                            _right: curMod.args.where[2].split(\".\").pop()\r\n                        };\r\n                    }\r\n                    var leftTableID = t._tableID;\r\n                    var rightTableID = index_1.NanoSQLInstance._hash(curMod.args.table);\r\n                    var where_1 = t._getMod(\"where\");\r\n                    var range_1 = t._getMod(\"range\");\r\n                    t._join(curMod.args.type, leftTableID, rightTableID, joinConditions, function (joinedRows) {\r\n                        if (where_1) {\r\n                            next(joinedRows.filter(function (row) {\r\n                                return t._where(row, where_1.args);\r\n                            }));\r\n                        }\r\n                        else if (range_1) {\r\n                            t._getRange(range_1.args[0], range_1.args[1], next);\r\n                        }\r\n                        else {\r\n                            next(joinedRows);\r\n                        }\r\n                    });\r\n                    break;\r\n                case 1:\r\n                    var columns_1 = curMod.args;\r\n                    var sortGroups_1 = {};\r\n                    if (columns_1) {\r\n                        groups = tableIndex.reduce(function (prev, curr) {\r\n                            var key = Object.keys(columns_1).reduce(function (p, c) { return p + \".\" + String(curr[c]); }, \"\").slice(1);\r\n                            (prev[key] = prev[key] || []).push(curr);\r\n                            sortGroups_1[key] = Object.keys(columns_1).reduce(function (pr, cu) {\r\n                                pr[cu] = curr[cu];\r\n                                return pr;\r\n                            }, {});\r\n                            return prev;\r\n                        }, {});\r\n                        next(Object.keys(groups).sort(function (a, b) {\r\n                            return sortObj(sortGroups_1[a], sortGroups_1[b], columns_1);\r\n                        }).reduce(function (prev, curr) {\r\n                            return prev.concat(groups[curr]);\r\n                        }, []));\r\n                    }\r\n                    else {\r\n                        next(tableIndex);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    next(tableIndex.filter(function (row) {\r\n                        return t._where(row, t._getMod(\"having\").args);\r\n                    }));\r\n                    break;\r\n                case 3:\r\n                    next(tableIndex.sort(function (a, b) {\r\n                        return sortObj(a, b, curMod.args);\r\n                    }));\r\n                    break;\r\n                case 4:\r\n                    next(tableIndex.filter(function (row, index) {\r\n                        return curMod ? index >= curMod.args : true;\r\n                    }));\r\n                    break;\r\n                case 5:\r\n                    next(tableIndex.filter(function (row, index) {\r\n                        return curMod ? index < curMod.args : true;\r\n                    }));\r\n                    break;\r\n            }\r\n        };\r\n        i = -1;\r\n        var qArgs = t._act.args || [];\r\n        var stepQuery = function (rowPKs) {\r\n            if (i < mods.length) {\r\n                i++;\r\n                modifyQuery(rowPKs, i, function (resultRows) {\r\n                    stepQuery(resultRows);\r\n                });\r\n            }\r\n            else {\r\n                rowPKs = rowPKs.filter(function (r) { return r; });\r\n                if (!t._getMod(\"join\")) {\r\n                    t._db._queryCache[t._tableID][t._queryHash] = rowPKs;\r\n                }\r\n                callBack(rowPKs, \"none\", []);\r\n            }\r\n        };\r\n        stepQuery(queryRows);\r\n    };\r\n    _NanoSQLQuery.prototype._remove = function (queryRows, callBack) {\r\n        var scribe = \"deleted\", i;\r\n        var t = this;\r\n        var qArgs = t._act.args || [];\r\n        var pk = t._db._store._tables[t._tableID]._pk;\r\n        i = 0;\r\n        var remove = function () {\r\n            if (i < queryRows.length) {\r\n                t._updateRow(queryRows[i][pk], function () {\r\n                    i++;\r\n                    remove();\r\n                });\r\n            }\r\n            else {\r\n                if (qArgs.length)\r\n                    scribe = \"modified\";\r\n                t._tableChanged(queryRows.map(function (r) { return r[pk]; }), scribe, callBack);\r\n            }\r\n        };\r\n        remove();\r\n    };\r\n    _NanoSQLQuery.prototype._where = function (row, conditions) {\r\n        var t = this;\r\n        var commands = [\"AND\", \"OR\"];\r\n        if (typeof conditions[0] !== \"string\") {\r\n            var prevCmd_1;\r\n            return conditions.reduce(function (prev, cur, i) {\r\n                if (commands.indexOf(cur) !== -1) {\r\n                    prevCmd_1 = cur;\r\n                    return prev;\r\n                }\r\n                else {\r\n                    var compare = t._compare(cur[2], cur[1], row[cur[0]]) === 0 ? true : false;\r\n                    if (i === 0)\r\n                        return compare;\r\n                    if (prevCmd_1 === \"AND\") {\r\n                        return prev && compare;\r\n                    }\r\n                    else {\r\n                        return prev || compare;\r\n                    }\r\n                }\r\n            }, true);\r\n        }\r\n        else {\r\n            return t._compare(conditions[2], conditions[1], row[conditions[0]]) === 0 ? true : false;\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._join = function (type, leftTableID, rightTableID, joinConditions, complete) {\r\n        var L = \"left\";\r\n        var R = \"right\";\r\n        var O = \"outer\";\r\n        var joinHelper = {};\r\n        var t = this;\r\n        var leftTableData = t._db._store._tables[leftTableID];\r\n        var rightTableData = t._db._store._tables[rightTableID];\r\n        var doJoinRows = function (leftRow, rightRow) {\r\n            return [leftTableData, rightTableData].reduce(function (prev, cur, i) {\r\n                cur._keys.forEach(function (k) {\r\n                    prev[cur._name + \".\" + k] = ((i === 0 ? leftRow : rightRow) || {})[k];\r\n                });\r\n                return prev;\r\n            }, {});\r\n        };\r\n        var joinTable = [];\r\n        var rightUsedPKs = [];\r\n        t._db._store._read(leftTableData._name, \"all\", function (leftRows) {\r\n            t._db._store._read(rightTableData._name, \"all\", function (rightRows) {\r\n                leftRows.forEach(function (leftRow) {\r\n                    var joinRows = rightRows.filter(function (rightRow) {\r\n                        if (!joinConditions)\r\n                            return true;\r\n                        var joinedRow = doJoinRows(leftRow, rightRow);\r\n                        var keep = t._where(joinedRow, [joinConditions._left, joinConditions._check, joinConditions._right]);\r\n                        if (keep)\r\n                            rightUsedPKs.push(rightRow[rightTableData._pk]);\r\n                        return keep;\r\n                    });\r\n                    if (joinRows.length) {\r\n                        joinTable = joinTable.concat(joinRows);\r\n                    }\r\n                    else if ([L, O].indexOf(type) >= 0) {\r\n                        joinTable.push(doJoinRows(leftRow, null));\r\n                    }\r\n                });\r\n                rightUsedPKs = rightUsedPKs.sort().filter(function (item, pos, ary) {\r\n                    return !pos || item !== ary[pos - 1];\r\n                });\r\n                if ([R, O].indexOf(type) >= 0) {\r\n                    rightRows.filter(function (r) {\r\n                        return rightUsedPKs.indexOf(r[rightTableData._pk]) === -1;\r\n                    }).forEach(function (rightRow) {\r\n                        joinTable.push(doJoinRows(null, rightRow));\r\n                    });\r\n                }\r\n                complete(joinTable);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._compare = function (val1, compare, val2) {\r\n        var setValue = function (val) {\r\n            if (compare !== \"LIKE\")\r\n                return val;\r\n            if (typeof val === \"string\")\r\n                return String(val).toLowerCase();\r\n            if (Array.isArray(val))\r\n                return val.map(function (v) { return setValue(v); });\r\n            return val;\r\n        };\r\n        var left = setValue(val2);\r\n        var right = setValue(val1);\r\n        switch (compare) {\r\n            case \"=\": return left === right ? 0 : 1;\r\n            case \">\": return left > right ? 0 : 1;\r\n            case \"<\": return left < right ? 0 : 1;\r\n            case \"<=\": return left <= right ? 0 : 1;\r\n            case \">=\": return left >= right ? 0 : 1;\r\n            case \"IN\": return right.indexOf(left) < 0 ? 1 : 0;\r\n            case \"NOT IN\": return right.indexOf(left) < 0 ? 0 : 1;\r\n            case \"REGEX\":\r\n            case \"LIKE\": return left.search(right) < 0 ? 1 : 0;\r\n            case \"BETWEEN\": return right[0] <= left && right[1] >= left ? 0 : 1;\r\n            case \"HAVE\": return (left || []).indexOf(right) < 0 ? 1 : 0;\r\n            default: return 0;\r\n        }\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\n"
        },
        {
          "id": 4,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "name": "./src/db-storage.ts",
          "index": 4,
          "index2": 3,
          "size": 35100,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "issuerId": 1,
          "issuerName": "./src/db-index.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
              "module": "./src/db-index.ts",
              "moduleName": "./src/db-index.ts",
              "type": "cjs require",
              "userRequest": "./db-storage",
              "loc": "4:19-42"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 3,
          "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar db_query_1 = require(\"./db-query\");\r\nvar trie_1 = require(\"./trie\");\r\nvar _NanoSQL_Storage = (function () {\r\n    function _NanoSQL_Storage(database, args) {\r\n        this._savedArgs = args;\r\n        this.init(database, args);\r\n    }\r\n    _NanoSQL_Storage.prototype.init = function (database, args) {\r\n        var _this = this;\r\n        var t = this;\r\n        t._models = {};\r\n        t._tables = {};\r\n        t._levelDBs = {};\r\n        t._historyPoint = 0;\r\n        t._historyLength = 0;\r\n        t._historyArray = [0, 0];\r\n        t._doingTransaction = false;\r\n        t._doHistory = true;\r\n        t._storeMemory = true;\r\n        t._persistent = false;\r\n        t._utilityTable = {};\r\n        t._mode = 0;\r\n        t._parent = database;\r\n        var size = 5;\r\n        if (args._config.length) {\r\n            t._persistent = args._config[0].persistent !== undefined ? args._config[0].persistent : false;\r\n            t._doHistory = args._config[0].history !== undefined ? args._config[0].history : true;\r\n            t._storeMemory = args._config[0].memory !== undefined ? args._config[0].memory : true;\r\n            size = args._config[0].size || 5;\r\n            t._mode = {\r\n                IDB: 1,\r\n                LS: 2,\r\n                LVL: 4\r\n            }[args._config[0].mode] || 0;\r\n            if (args._config[0].rebuildIndexes)\r\n                t._rebuildIndexes = true;\r\n            if (args._config[0].id)\r\n                t._parent._databaseID = String(args._config[0].id);\r\n        }\r\n        var upgrading = false;\r\n        var index = 0;\r\n        var isNewStore = true;\r\n        Object.keys(args._models).forEach(function (t) {\r\n            var pkRow = { key: \"x\", type: \"x\" };\r\n            var secondaryIndexes = [];\r\n            args._models[t].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    pkRow = index_1._assign(m);\r\n                }\r\n                if (m.props && (m.props.indexOf(\"idx\") !== -1 || m.props.indexOf(\"trie\") !== -1)) {\r\n                    secondaryIndexes.push(m);\r\n                }\r\n            });\r\n            if (pkRow.key !== \"x\" && pkRow.type !== \"x\") {\r\n                args._models[\"_\" + t + \"_hist__data\"] = index_1._assign(args._models[t]).map(function (m) {\r\n                    delete m.props;\r\n                    return m;\r\n                });\r\n                args._models[\"_\" + t + \"_hist__meta\"] = [\r\n                    pkRow,\r\n                    { key: \"_pointer\", type: \"int\" },\r\n                    { key: \"_historyDataRowIDs\", type: \"array\" },\r\n                ];\r\n            }\r\n            if (secondaryIndexes.length && (pkRow.key !== \"x\" && pkRow.type !== \"x\")) {\r\n                secondaryIndexes.forEach(function (s) {\r\n                    args._models[\"_\" + t + \"_idx_\" + s.key] = [\r\n                        { key: \"id\", type: s.type, props: [\"pk\"] },\r\n                        { key: \"rowPK\", type: pkRow.type }\r\n                    ];\r\n                });\r\n            }\r\n        });\r\n        args._models[db_index_1._str(0)] = [\r\n            { key: \"key\", type: \"string\", props: [\"pk\"] },\r\n            { key: \"value\", type: \"blob\" },\r\n        ];\r\n        args._models[db_index_1._str(1)] = [\r\n            { key: \"id\", type: \"int\", props: [\"ai\", \"pk\"] },\r\n            { key: \"tableID\", type: \"int\" },\r\n            { key: \"historyPoint\", type: \"int\" },\r\n            { key: \"rowKeys\", type: \"array\" },\r\n            { key: \"type\", type: \"string\" }\r\n        ];\r\n        var tables = Object.keys(args._models);\r\n        var beforeHist;\r\n        var beforeMode;\r\n        Object.keys(args._models).forEach(function (tableName) {\r\n            t._newTable(tableName, args._models[tableName]);\r\n        });\r\n        Object.keys(args._functions || []).forEach(function (f) {\r\n            db_query_1._functions[f] = args._functions[f];\r\n        });\r\n        var rebuildTries = function () {\r\n            var rebuildJob = {};\r\n            var jobLength = 0;\r\n            Object.keys(args._models).forEach(function (table) {\r\n                if (table.indexOf(\"_\") !== 0) {\r\n                    var ta = index_1.NanoSQLInstance._hash(table);\r\n                    if (t._tables[ta]._trieColumns.length) {\r\n                        rebuildJob[table] = t._tables[ta]._trieColumns;\r\n                        jobLength++;\r\n                    }\r\n                }\r\n            });\r\n            if (jobLength === 0) {\r\n                args._onSuccess();\r\n            }\r\n            else {\r\n                var tables_1 = Object.keys(rebuildJob);\r\n                var ptr_1 = 0;\r\n                var step_1 = function () {\r\n                    if (ptr_1 < tables_1.length) {\r\n                        var ta_1 = index_1.NanoSQLInstance._hash(tables_1[ptr_1]);\r\n                        t._read(tables_1[ptr_1], \"all\", function (rows) {\r\n                            rows.forEach(function (row, i) {\r\n                                rebuildJob[tables_1[ptr_1]].forEach(function (key) {\r\n                                    if (row[key])\r\n                                        t._tables[ta_1]._trieObjects[key].addWord(String(row[key]).toLocaleLowerCase());\r\n                                });\r\n                            });\r\n                            ptr_1++;\r\n                            step_1();\r\n                        });\r\n                    }\r\n                    else {\r\n                        args._onSuccess();\r\n                    }\r\n                };\r\n                step_1();\r\n            }\r\n        };\r\n        var rebuildSecondaryIndexes = function () {\r\n            if (!t._rebuildIndexes) {\r\n                rebuildTries();\r\n            }\r\n            else {\r\n                var rebuildJob_1 = {};\r\n                Object.keys(args._models).forEach(function (table) {\r\n                    if (table.indexOf(\"_\") !== 0) {\r\n                        var ta = index_1.NanoSQLInstance._hash(table);\r\n                        if (t._tables[ta]._secondaryIndexes.length) {\r\n                            rebuildJob_1[table] = t._tables[ta]._secondaryIndexes;\r\n                        }\r\n                    }\r\n                });\r\n                var tables_2 = Object.keys(rebuildJob_1);\r\n                var tablePTR_1 = 0;\r\n                var step_2 = function () {\r\n                    if (tablePTR_1 < tables_2.length) {\r\n                        var ta_2 = index_1.NanoSQLInstance._hash(tables_2[tablePTR_1]);\r\n                        var rowPTR_1 = 0;\r\n                        _this._read(tables_2[tablePTR_1], \"all\", function (rows) {\r\n                            var PK = t._tables[ta_2]._pk;\r\n                            var step2 = function () {\r\n                                if (rowPTR_1 < rows.length) {\r\n                                    var ptr3_1 = 0;\r\n                                    var step3_1 = function () {\r\n                                        if (ptr3_1 < rebuildJob_1[tables_2[tablePTR_1]].length) {\r\n                                            var key_1 = rebuildJob_1[tables_2[tablePTR_1]][ptr3_1];\r\n                                            var idxTbl_1 = \"_\" + tables_2[tablePTR_1] + \"_idx_\" + key_1;\r\n                                            var rowKey_1 = String(rows[rowPTR_1][key_1]).toLocaleLowerCase();\r\n                                            t._read(idxTbl_1, rowKey_1, function (readRows) {\r\n                                                var indexedRows = [rows[rowPTR_1][PK]];\r\n                                                if (readRows.length && readRows[0].rowPK) {\r\n                                                    indexedRows = indexedRows.concat(readRows[0].rowPK).filter(function (item, pos) {\r\n                                                        return indexedRows.indexOf(item) === pos;\r\n                                                    });\r\n                                                }\r\n                                                t._upsert(idxTbl_1, rowKey_1, {\r\n                                                    id: rows[rowPTR_1][key_1],\r\n                                                    rowPK: indexedRows\r\n                                                }, function () {\r\n                                                    ptr3_1++;\r\n                                                    step3_1();\r\n                                                });\r\n                                            }, true);\r\n                                        }\r\n                                        else {\r\n                                            rowPTR_1++;\r\n                                            step2();\r\n                                        }\r\n                                    };\r\n                                    step3_1();\r\n                                }\r\n                                else {\r\n                                    tablePTR_1++;\r\n                                    step_2();\r\n                                }\r\n                            };\r\n                            step2();\r\n                        });\r\n                    }\r\n                    else {\r\n                        rebuildTries();\r\n                    }\r\n                };\r\n                step_2();\r\n            }\r\n        };\r\n        var completeSetup = function () {\r\n            var tables = Object.keys(args._models);\r\n            var i = 0;\r\n            t._mode = beforeMode;\r\n            if (beforeHist) {\r\n                t._read(db_index_1._str(0), \"all\", function (rows) {\r\n                    rows.forEach(function (d) {\r\n                        t._utility(\"w\", d.key, d.value);\r\n                        if (d.key === \"historyPoint\")\r\n                            t._historyPoint = d.value || 0;\r\n                        if (d.key === \"historyLength\")\r\n                            t._historyLength = d.value || 0;\r\n                    });\r\n                });\r\n            }\r\n            if (isNewStore) {\r\n                var step_3 = function () {\r\n                    if (i < tables.length) {\r\n                        if (tables[i].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[i], 0, null, function () {\r\n                                i++;\r\n                                step_3();\r\n                            });\r\n                        }\r\n                        else {\r\n                            i++;\r\n                            step_3();\r\n                        }\r\n                    }\r\n                    else {\r\n                        t._doHistory = beforeHist;\r\n                        rebuildSecondaryIndexes();\r\n                    }\r\n                };\r\n                step_3();\r\n            }\r\n            else {\r\n                t._doHistory = beforeHist;\r\n                rebuildSecondaryIndexes();\r\n            }\r\n        };\r\n        beforeMode = t._mode;\r\n        if (t._persistent) {\r\n            if (t._mode !== 0) {\r\n                switch (t._mode) {\r\n                    case 1:\r\n                        if (typeof indexedDB === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 2:\r\n                        if (typeof localStorage === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 4:\r\n                        if (typeof window !== \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (typeof window !== \"undefined\") {\r\n                    if (typeof localStorage !== \"undefined\")\r\n                        t._mode = 2;\r\n                    if (typeof indexedDB !== \"undefined\")\r\n                        t._mode = 1;\r\n                }\r\n                if (typeof global !== \"undefined\") {\r\n                    if (typeof global._levelup !== \"undefined\" && typeof global._fs !== \"undefined\") {\r\n                        t._mode = 4;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            t._mode = 0;\r\n            completeSetup();\r\n        }\r\n        beforeHist = t._doHistory;\r\n        beforeMode = t._mode;\r\n        t._mode = 0;\r\n        t._doHistory = false;\r\n        var createTables = function (makeTable, complete) {\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    makeTable(tables[index], ta, t._tables[ta]);\r\n                    index++;\r\n                    next();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        var cacheTableData = function (args) {\r\n            isNewStore = false;\r\n            var index = 0;\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta_3 = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    if (!beforeHist && (tables[index].indexOf(\"_hist__data\") !== -1 || tables[index].indexOf(\"_hist__meta\") !== -1)) {\r\n                        index++;\r\n                        next();\r\n                        return;\r\n                    }\r\n                    if (t._storeMemory) {\r\n                        args.requestTable(tables[index], function (tableData) {\r\n                            if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                                t._tables[ta_3]._index.push(\"0\");\r\n                                t._tables[ta_3]._rows[\"0\"] = null;\r\n                                t._tables[ta_3]._incriment++;\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                    else if (!t._storeMemory || args.forceIndex) {\r\n                        args.requestIndex(tables[index], function (indexData) {\r\n                            t._parent._store._tables[ta_3]._index = indexData;\r\n                            t._parent._store._tables[ta_3]._incriment = indexData.reduce(function (prev, cur) {\r\n                                return Math.max(prev, parseInt(cur) || 0);\r\n                            }, 0);\r\n                            t._parent._store._tables[ta_3]._incriment++;\r\n                            index++;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    if (args.cleanup) {\r\n                        args.cleanup(function () {\r\n                            completeSetup();\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeSetup();\r\n                    }\r\n                    return;\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        switch (beforeMode) {\r\n            case 0:\r\n                completeSetup();\r\n                break;\r\n            case 1:\r\n                var idb = indexedDB.open(t._parent._databaseID, 1);\r\n                idb.onupgradeneeded = function (event) {\r\n                    upgrading = true;\r\n                    var db = event.target.result;\r\n                    var transaction = event.target.transaction;\r\n                    t._indexedDB = db;\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        var config = tableObj._pk ? { keyPath: tableObj._pk } : {};\r\n                        db.createObjectStore(tableName, config);\r\n                    }, function () {\r\n                        transaction.oncomplete = function () {\r\n                            completeSetup();\r\n                        };\r\n                    });\r\n                };\r\n                idb.onsuccess = function (event) {\r\n                    t._indexedDB = event.target.result;\r\n                    if (!upgrading) {\r\n                        var getIDBData_1 = function (tName, callBack) {\r\n                            var items = [];\r\n                            var transaction = t._indexedDB.transaction(tName, \"readonly\");\r\n                            var store = transaction.objectStore(tName);\r\n                            var cursorRequest = store.openCursor();\r\n                            cursorRequest.onsuccess = function (evt) {\r\n                                var cursor = evt.target.result;\r\n                                if (cursor) {\r\n                                    items.push(t._storeMemory ? cursor.value : cursor.key);\r\n                                    cursor.continue();\r\n                                }\r\n                            };\r\n                            transaction.oncomplete = function () {\r\n                                callBack(items);\r\n                            };\r\n                        };\r\n                        cacheTableData({\r\n                            requestIndex: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            },\r\n                            requestTable: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                break;\r\n            case 2:\r\n                if (localStorage.getItem(\"dbID\") !== t._parent._databaseID) {\r\n                    localStorage.setItem(\"dbID\", t._parent._databaseID);\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        localStorage.setItem(tableName, JSON.stringify([]));\r\n                    }, function () {\r\n                        completeSetup();\r\n                    });\r\n                }\r\n                else {\r\n                    cacheTableData({\r\n                        forceIndex: true,\r\n                        requestIndex: function (tableName, complete) {\r\n                            var tableIndex = JSON.parse(localStorage.getItem(tableName) || \"[]\");\r\n                            complete(tableIndex);\r\n                        },\r\n                        requestTable: function (tableName, complete) {\r\n                            var items = [];\r\n                            JSON.parse(localStorage.getItem(tableName) || \"[]\").forEach(function (ptr) {\r\n                                items.push(JSON.parse(localStorage.getItem(tableName + \"-\" + ptr) || \"\"));\r\n                            });\r\n                            complete(items);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._execTransaction = function () {\r\n        var t = this;\r\n        switch (t._mode) {\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._clear = function (type, complete) {\r\n        var t = this;\r\n        var tables = Object.keys(t._tables).map(function (k) { return t._tables[k]._name; });\r\n        var index = 0;\r\n        var setupNewHist = function () {\r\n            var index = 0;\r\n            var histStep = function () {\r\n                if (index < tables.length) {\r\n                    if (tables[index].indexOf(\"_hist__meta\") !== -1) {\r\n                        var referenceTable_1 = String(tables[index]).slice(1).replace(\"_hist__meta\", \"\");\r\n                        var ta = index_1.NanoSQLInstance._hash(referenceTable_1);\r\n                        var pk_1 = t._tables[ta]._pk;\r\n                        t._read(referenceTable_1, \"all\", function (rows) {\r\n                            rows.forEach(function (row, i) {\r\n                                var hist = {};\r\n                                hist[db_index_1._str(2)] = 0;\r\n                                hist[db_index_1._str(3)] = [i + 1];\r\n                                t._upsert(tables[index], row[pk_1], hist);\r\n                                t._upsert(\"_\" + referenceTable_1 + \"_hist__data\", i + 1, row);\r\n                            });\r\n                            index++;\r\n                            histStep();\r\n                        });\r\n                    }\r\n                    else {\r\n                        index++;\r\n                        histStep();\r\n                    }\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            histStep();\r\n        };\r\n        var step = function () {\r\n            if (index < tables.length) {\r\n                var deleteTable = false;\r\n                if (type === \"hist\" && (tables[index] === \"_historyPoints\" || tables[index].indexOf(\"_hist__meta\") !== -1 || tables[index].indexOf(\"_hist__data\") !== -1)) {\r\n                    deleteTable = true;\r\n                }\r\n                if (type === \"all\" && tables[index] !== \"_utility\") {\r\n                    deleteTable = true;\r\n                }\r\n                if (deleteTable) {\r\n                    t._delete(tables[index], \"all\", function () {\r\n                        if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[index], 0, null);\r\n                        }\r\n                        index++;\r\n                        step();\r\n                    });\r\n                }\r\n                else {\r\n                    index++;\r\n                    step();\r\n                }\r\n            }\r\n            else {\r\n                if (type === \"hist\") {\r\n                    setupNewHist();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            }\r\n        };\r\n        step();\r\n    };\r\n    _NanoSQL_Storage.prototype._delete = function (tableName, rowID, callBack) {\r\n        var t = this;\r\n        var editingHistory = false;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        var deleteRowIDS = [];\r\n        if (rowID === \"all\") {\r\n            deleteRowIDS = t._tables[ta]._index.slice();\r\n            t._tables[ta]._index = [];\r\n        }\r\n        else {\r\n            deleteRowIDS.push(rowID);\r\n            t._tables[ta]._index.splice(t._tables[ta]._index.indexOf(rowID), 1);\r\n        }\r\n        if (t._storeMemory) {\r\n            if (rowID === \"all\") {\r\n                t._tables[ta]._rows = {};\r\n            }\r\n            else {\r\n                delete t._tables[ta]._rows[rowID];\r\n            }\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(true);\r\n        }\r\n        if (t._mode > 0) {\r\n            var i_1 = 0;\r\n            var step_4 = function () {\r\n                if (i_1 < deleteRowIDS.length) {\r\n                    switch (t._mode) {\r\n                        case 1:\r\n                            t._indexedDB.transaction(tableName, \"readwrite\").objectStore(tableName).delete(parseInt(deleteRowIDS[i_1]));\r\n                            i_1++;\r\n                            step_4();\r\n                            break;\r\n                        case 2:\r\n                            localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                            localStorage.removeItem(tableName + \"-\" + String(deleteRowIDS[i_1]));\r\n                            i_1++;\r\n                            step_4();\r\n                            break;\r\n                        default:\r\n                            i_1++;\r\n                            step_4();\r\n                    }\r\n                }\r\n                else {\r\n                    if (callBack)\r\n                        callBack(true);\r\n                }\r\n            };\r\n            step_4();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._upsert = function (tableName, rowID, value, callBack) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (rowID === undefined || rowID === null) {\r\n            t._models[ta].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    if (m.type === \"uuid\") {\r\n                        rowID = index_1.NanoSQLInstance.uuid();\r\n                    }\r\n                    else {\r\n                        rowID = t._tables[ta]._incriment++;\r\n                    }\r\n                }\r\n            });\r\n            if (!rowID)\r\n                rowID = parseInt(t._tables[ta]._index[t._tables[ta]._index.length - 1] || \"0\") + 1;\r\n        }\r\n        if (t._tables[ta]._pkType === \"int\")\r\n            rowID = parseInt(rowID);\r\n        var pk = t._tables[ta]._pk;\r\n        if (pk && pk.length && value && !value[pk]) {\r\n            value[pk] = rowID;\r\n        }\r\n        if (t._tables[ta]._index.indexOf(rowID) === -1) {\r\n            t._tables[ta]._index.push(rowID);\r\n        }\r\n        if (t._storeMemory) {\r\n            t._tables[ta]._rows[rowID] = t._parent._deepFreeze(value, ta);\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(rowID);\r\n        }\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readwrite\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (pk.length && value) {\r\n                    store.put(value);\r\n                }\r\n                else {\r\n                    if (tableName.indexOf(\"_hist__data\") !== -1) {\r\n                        store.put(value, rowID);\r\n                    }\r\n                    else {\r\n                        if (value)\r\n                            store.put(value);\r\n                        if (!value)\r\n                            store.delete(rowID);\r\n                    }\r\n                }\r\n                transaction.oncomplete = function () {\r\n                    if (callBack)\r\n                        callBack(rowID);\r\n                };\r\n                break;\r\n            case 2:\r\n                localStorage.setItem(tableName + \"-\" + String(rowID), value ? JSON.stringify(value) : \"\");\r\n                localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                if (callBack)\r\n                    callBack(rowID);\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._indexRead = function (tableName, rows, callBack, getIndex) {\r\n        var _this = this;\r\n        var isSecondIndex = tableName.indexOf(\"_\") === 0 && tableName.indexOf(\"_idx_\") !== -1;\r\n        if (!isSecondIndex || getIndex) {\r\n            callBack(rows);\r\n        }\r\n        else {\r\n            var parentTable_1 = !isSecondIndex ? \"\" : tableName.slice(1, tableName.indexOf(\"_idx_\"));\r\n            var allRowIDs_1 = rows.reduce(function (prev, cur) {\r\n                return prev.concat(cur.rowPK);\r\n            }, []);\r\n            var resultRows_1 = [];\r\n            var ptr_2 = 0;\r\n            var step_5 = function () {\r\n                if (ptr_2 < allRowIDs_1.length) {\r\n                    _this._read(parentTable_1, allRowIDs_1[ptr_2], function (rows) {\r\n                        resultRows_1 = resultRows_1.concat(rows);\r\n                        ptr_2++;\r\n                        step_5();\r\n                    });\r\n                }\r\n                else {\r\n                    callBack(resultRows_1);\r\n                }\r\n            };\r\n            step_5();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._readRange = function (tableName, key, between, callBack) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (t._mode === 0 || t._mode === 2) {\r\n            var startPtr_1 = t._tables[ta]._index.indexOf(between[0]);\r\n            var resultRows_2 = [];\r\n            var stepRead_1 = function () {\r\n                var pk = t._tables[ta]._index[startPtr_1];\r\n                if (pk <= between[1]) {\r\n                    _this._read(tableName, pk, function (rows) {\r\n                        resultRows_2 = resultRows_2.concat(rows);\r\n                        startPtr_1++;\r\n                        stepRead_1();\r\n                    });\r\n                }\r\n                else {\r\n                    _this._indexRead(tableName, resultRows_2, callBack);\r\n                }\r\n            };\r\n            stepRead_1();\r\n            return;\r\n        }\r\n        var rows = [];\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                var cursorRequest = store.openCursor(IDBKeyRange.bound(between[0], between[1]));\r\n                transaction.oncomplete = function () {\r\n                    _this._indexRead(tableName, rows, callBack);\r\n                };\r\n                cursorRequest.onsuccess = function (evt) {\r\n                    var cursor = evt.target.result;\r\n                    if (cursor) {\r\n                        rows.push(cursor.value);\r\n                        cursor.continue();\r\n                    }\r\n                };\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._read = function (tableName, row, callBack, readIndex) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        switch (t._mode) {\r\n            case 0:\r\n                var rows_1 = t._tables[ta]._rows;\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var allRows = Object.keys(rows_1).map(function (r) { return rows_1[r]; });\r\n                    if (row === \"all\") {\r\n                        this._indexRead(tableName, allRows.filter(function (r) { return r; }), callBack, readIndex);\r\n                    }\r\n                    else {\r\n                        this._indexRead(tableName, allRows.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    this._indexRead(tableName, [rows_1[row]].filter(function (r) { return r; }), callBack, readIndex);\r\n                }\r\n                break;\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var cursorRequest = store.openCursor();\r\n                    var rows_2 = [];\r\n                    transaction.oncomplete = function () {\r\n                        _this._indexRead(tableName, rows_2, callBack, readIndex);\r\n                    };\r\n                    cursorRequest.onsuccess = function (evt) {\r\n                        var cursor = evt.target.result;\r\n                        if (cursor) {\r\n                            if (row !== \"all\") {\r\n                                if (row(cursor.value))\r\n                                    rows_2.push(cursor.value);\r\n                            }\r\n                            else {\r\n                                rows_2.push(cursor.value);\r\n                            }\r\n                            cursor.continue();\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    var singleReq_1 = store.get(row);\r\n                    singleReq_1.onsuccess = function (event) {\r\n                        _this._indexRead(tableName, [singleReq_1.result], callBack, readIndex);\r\n                    };\r\n                }\r\n                break;\r\n            case 2:\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var rows_3 = t._tables[ta]._index.map(function (idx) {\r\n                        var item = localStorage.getItem(tableName + \"-\" + idx);\r\n                        return item && item.length ? JSON.parse(item) : null;\r\n                    });\r\n                    if (row !== \"all\") {\r\n                        this._indexRead(tableName, rows_3.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                    }\r\n                    else {\r\n                        this._indexRead(tableName, rows_3, callBack, readIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    var item = localStorage.getItem(tableName + \"-\" + row);\r\n                    this._indexRead(tableName, [item && item.length ? JSON.parse(item) : null], callBack, readIndex);\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._utility = function (type, key, value) {\r\n        var t = this;\r\n        if (type === \"r\") {\r\n            if (t._utilityTable[key]) {\r\n                return t._utilityTable[key].value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            t._upsert(db_index_1._str(0), key, { key: key, value: value });\r\n            t._utility[key] = {\r\n                key: key,\r\n                value: value\r\n            };\r\n            return value;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._newTable = function (tableName, dataModels) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        t._models[ta] = dataModels;\r\n        t._parent._queryCache[ta] = {};\r\n        t._tables[ta] = {\r\n            _pk: \"\",\r\n            _pkType: \"\",\r\n            _keys: [],\r\n            _defaults: [],\r\n            _secondaryIndexes: [],\r\n            _trieColumns: [],\r\n            _trieObjects: {},\r\n            _name: tableName,\r\n            _incriment: 1,\r\n            _index: [],\r\n            _rows: {}\r\n        };\r\n        var i = t._models[ta].length;\r\n        var keys = [];\r\n        var defaults = [];\r\n        while (i--) {\r\n            var p = t._models[ta][i];\r\n            t._tables[ta]._keys.unshift(p.key);\r\n            t._tables[ta]._defaults[i] = p.default;\r\n            if (p.props && p.props.indexOf(\"pk\") >= 0) {\r\n                t._tables[ta]._pk = p.key;\r\n                t._tables[ta]._pkType = p.type;\r\n            }\r\n            if (p.props && (p.props.indexOf(\"idx\") >= 0 || p.props.indexOf(\"trie\") >= 0)) {\r\n                t._tables[ta]._secondaryIndexes.push(p.key);\r\n            }\r\n            if (p.props && p.props.indexOf(\"trie\") >= 0) {\r\n                t._tables[ta]._trieColumns.push(p.key);\r\n                t._tables[ta]._trieObjects[p.key] = new trie_1.Trie([]);\r\n            }\r\n        }\r\n        return tableName;\r\n    };\r\n    return _NanoSQL_Storage;\r\n}());\r\nexports._NanoSQL_Storage = _NanoSQL_Storage;\r\n"
        },
        {
          "id": 5,
          "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\trie.ts",
          "name": "./src/trie.ts",
          "index": 6,
          "index2": 2,
          "size": 3262,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "issuerId": 4,
          "issuerName": "./src/db-storage.ts",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
              "module": "./src/db-storage.ts",
              "moduleName": "./src/db-storage.ts",
              "type": "cjs require",
              "userRequest": "./trie",
              "loc": "5:13-30"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 4,
          "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction append(trie, letter, index, array) {\r\n    trie[letter] = trie[letter] || {};\r\n    trie = trie[letter];\r\n    if (index === array.length - 1) {\r\n        trie[config.END_WORD] = 1;\r\n    }\r\n    return trie;\r\n}\r\nfunction checkPrefix(prefixNode, prefix) {\r\n    var input = prefix.toLowerCase().split(\"\");\r\n    var prefixFound = input.every(function (letter, index) {\r\n        if (!prefixNode[letter]) {\r\n            return false;\r\n        }\r\n        return prefixNode = prefixNode[letter];\r\n    });\r\n    return {\r\n        prefixFound: prefixFound,\r\n        prefixNode: prefixNode,\r\n    };\r\n}\r\nfunction create(input) {\r\n    var trie = input.reduce(function (accumulator, item) {\r\n        item\r\n            .toLowerCase()\r\n            .split(\"\")\r\n            .reduce(append, accumulator);\r\n        return accumulator;\r\n    }, {});\r\n    return trie;\r\n}\r\nfunction recursePrefix(node, prefix, prefixes) {\r\n    if (prefixes === void 0) { prefixes = []; }\r\n    var word = prefix;\r\n    for (var branch in node) {\r\n        if (branch === config.END_WORD) {\r\n            prefixes.push(word);\r\n            word = \"\";\r\n        }\r\n        recursePrefix(node[branch], prefix + branch, prefixes);\r\n    }\r\n    return prefixes.sort();\r\n}\r\nvar utils = {\r\n    objectCopy: function (obj) {\r\n        if (typeof obj === \"undefined\") {\r\n            return {};\r\n        }\r\n        return JSON.parse(JSON.stringify(obj));\r\n    },\r\n    stringify: function (obj, spacer) {\r\n        if (spacer === void 0) { spacer = 2; }\r\n        if (typeof obj === \"undefined\") {\r\n            return \"\";\r\n        }\r\n        return JSON.stringify(obj, null, spacer);\r\n    },\r\n};\r\nvar config = {\r\n    END_WORD: \"$\",\r\n    PERMS_MIN_LEN: 2,\r\n};\r\nvar PERMS_MIN_LEN = config.PERMS_MIN_LEN;\r\nvar Trie = (function () {\r\n    function Trie(input) {\r\n        this._trie = create(input);\r\n    }\r\n    Trie.prototype.dump = function (spacer) {\r\n        if (spacer === void 0) { spacer = 0; }\r\n        return utils.stringify(this._trie, spacer);\r\n    };\r\n    Trie.prototype.addWord = function (word) {\r\n        var reducer = function (previousValue, currentValue, currentIndex, array) {\r\n            return append(previousValue, currentValue, currentIndex, array);\r\n        };\r\n        var input = word.toLowerCase().split(\"\");\r\n        input.reduce(reducer, this._trie);\r\n        return this;\r\n    };\r\n    Trie.prototype.removeWord = function (word) {\r\n        var _a = checkPrefix(this._trie, word), prefixFound = _a.prefixFound, prefixNode = _a.prefixNode;\r\n        if (prefixFound) {\r\n            delete prefixNode[config.END_WORD];\r\n        }\r\n        return this;\r\n    };\r\n    Trie.prototype.isPrefix = function (prefix) {\r\n        var prefixFound = checkPrefix(this._trie, prefix).prefixFound;\r\n        return prefixFound;\r\n    };\r\n    Trie.prototype.getPrefix = function (strPrefix) {\r\n        if (!this.isPrefix(strPrefix)) {\r\n            return [];\r\n        }\r\n        var prefixNode = checkPrefix(this._trie, strPrefix).prefixNode;\r\n        return recursePrefix(prefixNode, strPrefix);\r\n    };\r\n    Trie.prototype.getWords = function () {\r\n        return recursePrefix(this._trie, \"\");\r\n    };\r\n    return Trie;\r\n}());\r\nexports.Trie = Trie;\r\n"
        },
        {
          "id": 6,
          "identifier": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "name": "multi ./src/index.ts",
          "index": 0,
          "index2": 6,
          "size": 28,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [],
          "usedExports": true,
          "providedExports": null,
          "depth": 0
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "moduleId": 6,
          "module": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "moduleIdentifier": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "moduleName": "multi ./src/index.ts",
          "loc": "",
          "name": "nano-sql",
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
      "name": "./src/index.ts",
      "index": 1,
      "index2": 5,
      "size": 22301,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
      "issuerId": 6,
      "issuerName": "multi ./src/index.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "module": "./src/db-index.ts",
          "moduleName": "./src/db-index.ts",
          "type": "cjs require",
          "userRequest": "./index",
          "loc": "2:14-32"
        },
        {
          "moduleId": 3,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
          "module": "./src/db-query.ts",
          "moduleName": "./src/db-query.ts",
          "type": "cjs require",
          "userRequest": "./index",
          "loc": "2:14-32"
        },
        {
          "moduleId": 4,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "module": "./src/db-storage.ts",
          "moduleName": "./src/db-storage.ts",
          "type": "cjs require",
          "userRequest": "./index",
          "loc": "2:14-32"
        },
        {
          "moduleId": 6,
          "moduleIdentifier": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "module": "multi ./src/index.ts",
          "moduleName": "multi ./src/index.ts",
          "type": "single entry",
          "userRequest": "C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "loc": "nano-sql:100000"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 1,
      "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar db_index_1 = require(\"./db-index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nexports._assign = function (obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n};\r\nvar NanoSQLInstance = (function () {\r\n    function NanoSQLInstance() {\r\n        var t = this;\r\n        t._actions = {};\r\n        t._views = {};\r\n        t._models = {};\r\n        t._preConnectExtend = [];\r\n        t._transactionTables = [];\r\n        t._events = [\"change\", \"delete\", \"upsert\", \"drop\", \"select\", \"error\"];\r\n        t._callbacks = {};\r\n        t._hasEvents = {};\r\n        t._callbacks[\"*\"] = {};\r\n        var i = t._events.length;\r\n        while (i--) {\r\n            t._callbacks[\"*\"][t._events[i]] = [];\r\n        }\r\n        t._functions = {};\r\n        t._rowFilters = {};\r\n    }\r\n    NanoSQLInstance.prototype.table = function (table) {\r\n        if (table)\r\n            this._selectedTable = table;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.connect = function (backend) {\r\n        var _this = this;\r\n        var t = this;\r\n        if (t.backend) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                rej();\r\n                throw Error();\r\n            });\r\n        }\r\n        t.backend = backend || new db_index_1._NanoSQLDB();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.backend._connect({\r\n                _models: t._models,\r\n                _actions: t._actions,\r\n                _views: t._views,\r\n                _functions: t._functions,\r\n                _config: t._preConnectExtend,\r\n                _parent: _this,\r\n                _onSuccess: function (result) {\r\n                    res(result, t);\r\n                },\r\n                _onFail: function (rejected) {\r\n                    if (rej)\r\n                        rej(rejected, t);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.on = function (actions, callBack) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = 0;\r\n        var a = actions.split(\" \");\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        i = a.length;\r\n        while (i--) {\r\n            if (t._events.indexOf(a[i]) !== -1) {\r\n                t._callbacks[l][a[i]].push(callBack);\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.off = function (callBack) {\r\n        var t = this;\r\n        for (var key in t._callbacks) {\r\n            for (var key2 in t._callbacks[key]) {\r\n                t._callbacks[key][key2] = t._callbacks[key][key2].filter(function (cBs) {\r\n                    return cBs !== callBack;\r\n                });\r\n            }\r\n        }\r\n        t._refreshEventChecker();\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype._refreshEventChecker = function () {\r\n        var _this = this;\r\n        this._hasEvents = {};\r\n        Object.keys(this._models).concat([\"*\"]).forEach(function (table) {\r\n            _this._hasEvents[table] = _this._events.reduce(function (prev, cur) {\r\n                return prev + (_this._callbacks[table] ? _this._callbacks[table][cur].length : 0);\r\n            }, 0) > 0;\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.model = function (dataModel) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var i = t._events.length;\r\n        if (!t._callbacks[l]) {\r\n            t._callbacks[l] = {};\r\n            t._callbacks[l][\"*\"] = [];\r\n            while (i--) {\r\n                t._callbacks[l][t._events[i]] = [];\r\n            }\r\n        }\r\n        t._models[l] = dataModel;\r\n        t._views[l] = [];\r\n        t._actions[l] = [];\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.views = function (viewArray) {\r\n        return this._views[this._selectedTable] = viewArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.getView = function (viewName, viewArgs) {\r\n        if (viewArgs === void 0) { viewArgs = {}; }\r\n        return this._doAV(\"View\", this._views[this._selectedTable], viewName, viewArgs);\r\n    };\r\n    NanoSQLInstance.prototype.cleanArgs = function (argDeclarations, args) {\r\n        var t = this;\r\n        var l = t._selectedTable;\r\n        var a = {};\r\n        var i = argDeclarations.length ? argDeclarations.length : -1;\r\n        if (i > 0) {\r\n            while (i--) {\r\n                var k2 = argDeclarations[i].split(\":\");\r\n                if (k2.length > 1) {\r\n                    a[k2[0]] = t._cast(k2[1], args[k2[0]] || null);\r\n                }\r\n                else {\r\n                    a[k2[0]] = args[k2[0]] || null;\r\n                }\r\n            }\r\n        }\r\n        return a;\r\n    };\r\n    NanoSQLInstance.prototype._cast = function (type, val) {\r\n        var _this = this;\r\n        var t = typeof val;\r\n        var types = {\r\n            string: t !== \"string\" ? String(val) : val,\r\n            int: t !== \"number\" || val % 1 !== 0 ? parseInt(val || 0) : val,\r\n            float: t !== \"number\" ? parseFloat(val || 0) : val,\r\n            array: Array.isArray(val) ? exports._assign(val || []) : [],\r\n            \"any[]\": Array.isArray(val) ? exports._assign(val || []) : [],\r\n            any: val,\r\n            blob: val,\r\n            uudi: val,\r\n            timeId: val,\r\n            map: t === \"object\" ? exports._assign(val || {}) : {},\r\n            bool: val === true\r\n        };\r\n        var newVal = types[type];\r\n        if (newVal !== undefined) {\r\n            return newVal;\r\n        }\r\n        else if (type.indexOf(\"[]\") !== -1) {\r\n            var arrayOf_1 = type.slice(0, type.lastIndexOf(\"[]\"));\r\n            return (val || []).map(function (v) {\r\n                return _this._cast(arrayOf_1, v);\r\n            });\r\n        }\r\n        return val;\r\n    };\r\n    NanoSQLInstance.prototype.actions = function (actionArray) {\r\n        return this._actions[this._selectedTable] = actionArray, this;\r\n    };\r\n    NanoSQLInstance.prototype.doAction = function (actionName, actionArgs) {\r\n        return this._doAV(\"Action\", this._actions[this._selectedTable], actionName, actionArgs);\r\n    };\r\n    NanoSQLInstance.prototype._doAV = function (AVType, AVList, AVName, AVargs) {\r\n        var _this = this;\r\n        var t = this;\r\n        var selAV = AVList.reduce(function (prev, cur) {\r\n            if (cur.name === AVName)\r\n                return cur;\r\n            return prev;\r\n        }, null);\r\n        if (!selAV) {\r\n            return new lie_ts_1.Promise(function (res, rej) { return rej(\"Action/View Not Found!\"); });\r\n        }\r\n        t._activeAV = AVName;\r\n        var cleanArgs = selAV.args ? t.cleanArgs(selAV.args, AVargs) : {};\r\n        if (t._AVMod) {\r\n            return new lie_ts_1.Promise(function (res, rej) {\r\n                t._AVMod(_this._selectedTable, AVType, t._activeAV || \"\", cleanArgs, function (args) {\r\n                    selAV ? selAV.call(args, t).then(function (result) {\r\n                        res(result, t);\r\n                    }) : false;\r\n                }, function (err) {\r\n                    rej(err);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return selAV.call(cleanArgs, t);\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.newFunction = function (functionName, functionType, filterFunction) {\r\n        return this._functions[functionName] = { type: functionType, call: filterFunction }, this;\r\n    };\r\n    NanoSQLInstance.prototype.query = function (action, args) {\r\n        var t = this;\r\n        var query = new _NanoSQLQuery(t._selectedTable, t, t._activeAV);\r\n        t._activeAV = undefined;\r\n        var a = action.toLowerCase();\r\n        if ([\"select\", \"upsert\", \"delete\", \"drop\", \"show tables\", \"describe\"].indexOf(a) !== -1) {\r\n            var newArgs_1 = args || (a === \"select\" || a === \"delete\" ? [] : {});\r\n            if ([\"upsert\", \"delete\", \"drop\"].indexOf(a) !== -1) {\r\n                this._transactionTables.push(t._selectedTable);\r\n            }\r\n            if (action === \"upsert\") {\r\n                var inputArgs_1 = {};\r\n                t._models[t._selectedTable].forEach(function (model) {\r\n                    if (newArgs_1[model.key]) {\r\n                        inputArgs_1[model.key] = t._cast(model.type, newArgs_1[model.key]);\r\n                    }\r\n                });\r\n                if (t._rowFilters[t._selectedTable]) {\r\n                    inputArgs_1 = t._rowFilters[t._selectedTable](inputArgs_1);\r\n                }\r\n                newArgs_1 = inputArgs_1;\r\n            }\r\n            query._action = { type: a, args: newArgs_1 };\r\n        }\r\n        else {\r\n            throw Error;\r\n        }\r\n        return query;\r\n    };\r\n    NanoSQLInstance.prototype.triggerEvent = function (eventData, triggerEvents) {\r\n        var t = this;\r\n        setTimeout(function () {\r\n            var i = triggerEvents.length;\r\n            var j = 0;\r\n            var e;\r\n            var c;\r\n            while (i--) {\r\n                e = triggerEvents[i];\r\n                c = t._callbacks[eventData.table][e].concat(t._callbacks[eventData.table][\"*\"]);\r\n                j = c.length;\r\n                while (j--) {\r\n                    eventData.name = e;\r\n                    c[j](eventData, t);\r\n                }\r\n            }\r\n        }, 0);\r\n    };\r\n    NanoSQLInstance.prototype.default = function (replaceObj) {\r\n        var newObj = {};\r\n        var t = this;\r\n        t._models[t._selectedTable].forEach(function (m) {\r\n            newObj[m.key] = (replaceObj && replaceObj[m.key]) ? replaceObj[m.key] : m.default;\r\n            if (!newObj[m.key]) {\r\n                newObj[m.key] = t._cast(m.type, null);\r\n            }\r\n        });\r\n        return newObj;\r\n    };\r\n    NanoSQLInstance.prototype.beginTransaction = function () {\r\n        this.doingTransaction = true;\r\n        this._transactionTables = [];\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"start\");\r\n    };\r\n    NanoSQLInstance.prototype.endTransaction = function () {\r\n        var _this = this;\r\n        this.doingTransaction = false;\r\n        this._transactionTables.forEach(function (table) {\r\n            if (table.indexOf(\"_\") !== 0) {\r\n                _this.triggerEvent({\r\n                    table: table,\r\n                    query: [],\r\n                    time: new Date().getTime(),\r\n                    result: [],\r\n                    name: \"change\",\r\n                    actionOrView: \"\",\r\n                    changeType: \"transaction\",\r\n                    changedRows: []\r\n                }, [\"change\"]);\r\n            }\r\n        });\r\n        if (this.backend._transaction)\r\n            return this.backend._transaction(\"end\");\r\n    };\r\n    NanoSQLInstance.prototype.queryFilter = function (callBack) {\r\n        this._queryMod = callBack;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.avFilter = function (filterFunc) {\r\n        this._AVMod = filterFunc;\r\n        return this;\r\n    };\r\n    NanoSQLInstance.prototype.config = function (args) {\r\n        var t = this;\r\n        if (!t.backend)\r\n            t._preConnectExtend.push(args);\r\n        return t;\r\n    };\r\n    NanoSQLInstance.prototype.extend = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var t = this;\r\n        if (t.backend) {\r\n            if (t.backend._extend) {\r\n                args.unshift(t);\r\n                return t.backend._extend.apply(t.backend, args);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.prototype.loadJS = function (table, rows) {\r\n        var t = this;\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            var pointer = 0;\r\n            var rowData = [];\r\n            var next = function () {\r\n                if (pointer < rows.length) {\r\n                    if (rows[pointer]) {\r\n                        t.table(table).query(\"upsert\", rows[pointer]).exec().then(function (res) {\r\n                            rowData.push(res);\r\n                            pointer++;\r\n                            next();\r\n                        });\r\n                    }\r\n                    else {\r\n                        pointer++;\r\n                        next();\r\n                    }\r\n                }\r\n                else {\r\n                    t.endTransaction();\r\n                    res(rowData, t);\r\n                }\r\n            };\r\n            next();\r\n        });\r\n    };\r\n    NanoSQLInstance.prototype.rowFilter = function (callBack) {\r\n        return this._rowFilters[this._selectedTable] = callBack, this;\r\n    };\r\n    NanoSQLInstance.prototype.loadCSV = function (table, csv) {\r\n        var t = this;\r\n        var fields = [];\r\n        t.beginTransaction();\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            lie_ts_1.Promise.all(csv.split(\"\\n\").map(function (v, k) {\r\n                return new lie_ts_1.Promise(function (resolve, reject) {\r\n                    if (k === 0) {\r\n                        fields = v.split(\",\");\r\n                        resolve();\r\n                    }\r\n                    else {\r\n                        var record = {};\r\n                        var row = v.match(/(\".*?\"|[^\",\\s]+)(?=\\s*,|\\s*$)/g) || [];\r\n                        row = row.map(function (str) { return str.replace(/^\"(.+(?=\"$))\"$/, \"$1\"); });\r\n                        var i = fields.length;\r\n                        while (i--) {\r\n                            if (row[i].indexOf(\"{\") === 0 || row[i].indexOf(\"[\") === 0) {\r\n                                row[i] = JSON.parse(row[i].replace(/'/g, \"\"));\r\n                            }\r\n                            record[fields[i]] = row[i];\r\n                        }\r\n                        t.table(table).query(\"upsert\", record).exec().then(function () {\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            })).then(function () {\r\n                t.endTransaction();\r\n                res([], t);\r\n            });\r\n        });\r\n    };\r\n    NanoSQLInstance._random16Bits = function () {\r\n        if (typeof crypto === \"undefined\") {\r\n            return Math.round(Math.random() * Math.pow(2, 16));\r\n        }\r\n        else {\r\n            if (crypto.getRandomValues) {\r\n                var buf = new Uint16Array(1);\r\n                crypto.getRandomValues(buf);\r\n                return buf[0];\r\n            }\r\n            else if (global !== \"undefined\" && global._crypto.randomBytes) {\r\n                return global._crypto.randomBytes(2).reduce(function (prev, cur) { return cur * prev; });\r\n            }\r\n            else {\r\n                return Math.round(Math.random() * Math.pow(2, 16));\r\n            }\r\n        }\r\n    };\r\n    NanoSQLInstance.timeid = function (ms) {\r\n        var t = this;\r\n        if (!t._tzOffset) {\r\n            t._tzOffset = new Date().getTimezoneOffset() * 60000;\r\n        }\r\n        var time = Math.round((new Date().getTime() + t._tzOffset) / (ms ? 1 : 1000)).toString();\r\n        while (time.length < (ms ? 13 : 10)) {\r\n            time = \"0\" + time;\r\n        }\r\n        return time + \"-\" + (t._random16Bits() + t._random16Bits()).toString(16);\r\n    };\r\n    NanoSQLInstance.uuid = function () {\r\n        var _this = this;\r\n        var r, s, b = \"\";\r\n        return [b, b, b, b, b, b, b, b, b].reduce(function (prev, cur, i) {\r\n            r = _this._random16Bits();\r\n            s = (i === 4 ? i : (i === 5 ? (r % 16 & 0x3 | 0x8).toString(16) : b));\r\n            r = r.toString(16);\r\n            while (r.length < 4)\r\n                r = \"0\" + r;\r\n            return prev + ([3, 4, 5, 6].indexOf(i) >= 0 ? \"-\" : b) + (s + r).slice(0, 4);\r\n        }, b);\r\n    };\r\n    ;\r\n    NanoSQLInstance._hash = function (key) {\r\n        return Math.abs(key.split(\"\").reduce(function (prev, next, i) {\r\n            return ((prev << 5) + prev) + key.charCodeAt(i);\r\n        }, 0));\r\n    };\r\n    return NanoSQLInstance;\r\n}());\r\nexports.NanoSQLInstance = NanoSQLInstance;\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(table, db, actionOrView) {\r\n        this._db = db;\r\n        this._modifiers = [];\r\n        this._table = table;\r\n        this._AV = actionOrView || \"\";\r\n    }\r\n    _NanoSQLQuery.prototype.where = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Where condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"where\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.range = function (limit, offset) {\r\n        return this._addCmd(\"range\", [limit, offset]);\r\n    };\r\n    _NanoSQLQuery.prototype.orderBy = function (args) {\r\n        return this._addCmd(\"orderby\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.groupBy = function (columns) {\r\n        return this._addCmd(\"groupby\", columns);\r\n    };\r\n    _NanoSQLQuery.prototype.having = function (args) {\r\n        if (!args.length || !Array.isArray(args)) {\r\n            this._error = \"Having condition requires an array!\";\r\n        }\r\n        return this._addCmd(\"having\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.join = function (args) {\r\n        if (!args.table || !args.type) {\r\n            this._error = \"Join command requires table and type arguments!\";\r\n        }\r\n        return this._addCmd(\"join\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.limit = function (args) {\r\n        return this._addCmd(\"limit\", args);\r\n    };\r\n    _NanoSQLQuery.prototype.trieSearch = function (column, stringToSearch) {\r\n        return this._addCmd(\"trie\", [column, stringToSearch]);\r\n    };\r\n    _NanoSQLQuery.prototype.offset = function (args) {\r\n        return this._addCmd(\"offset\", args);\r\n    };\r\n    _NanoSQLQuery.prototype._addCmd = function (type, args) {\r\n        return this._modifiers.push({ type: type, args: args }), this;\r\n    };\r\n    _NanoSQLQuery.prototype.toCSV = function (headers) {\r\n        var t = this;\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            t.exec().then(function (json) {\r\n                var header = t._action.args.length ? t._action.args.map(function (m) {\r\n                    return t._db._models[t._table].filter(function (f) { return f[\"key\"] === m; })[0];\r\n                }) : t._db._models[t._table];\r\n                if (headers) {\r\n                    json.unshift(header.map(function (h) {\r\n                        return h[\"key\"];\r\n                    }));\r\n                }\r\n                res(json.map(function (row, i) {\r\n                    if (headers && i === 0)\r\n                        return row;\r\n                    return header.filter(function (column) {\r\n                        return row[column[\"key\"]] ? true : false;\r\n                    }).map(function (column) {\r\n                        switch (column[\"type\"]) {\r\n                            case \"map\":\r\n                            case \"array\": return '\"' + JSON.stringify(row[column[\"key\"]]).replace(/\"/g, \"'\") + '\"';\r\n                            default: return row[column[\"key\"]];\r\n                        }\r\n                    }).join(\",\");\r\n                }).join(\"\\n\"), t);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype.exec = function () {\r\n        var t = this;\r\n        var _t = t._table;\r\n        if (t._db._hasEvents[_t]) {\r\n            t._db._triggerEvents = (function () {\r\n                switch (t._action.type) {\r\n                    case \"select\": return [t._action.type];\r\n                    case \"delete\":\r\n                    case \"upsert\":\r\n                    case \"drop\": return [t._action.type, \"change\"];\r\n                    default: return [];\r\n                }\r\n            })();\r\n        }\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            if (t._error) {\r\n                rej(t._error);\r\n                throw Error;\r\n            }\r\n            if (!t._db.backend) {\r\n                rej();\r\n                throw Error;\r\n            }\r\n            var _tEvent = function (data, callBack, type, changedRows, isError) {\r\n                if (t._db._hasEvents[_t]) {\r\n                    t._db.triggerEvent({\r\n                        name: \"error\",\r\n                        actionOrView: t._AV,\r\n                        table: _t,\r\n                        query: [t._action].concat(t._modifiers),\r\n                        time: new Date().getTime(),\r\n                        result: data,\r\n                        changeType: type,\r\n                        changedRows: changedRows\r\n                    }, t._db._triggerEvents);\r\n                }\r\n                callBack(data, t._db);\r\n            };\r\n            var execArgs = {\r\n                table: _t,\r\n                query: [t._action].concat(t._modifiers),\r\n                viewOrAction: t._AV,\r\n                onSuccess: function (rows, type, affectedRows) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(rows, t._db);\r\n                    }\r\n                    else {\r\n                        _tEvent(rows, res, type, affectedRows, false);\r\n                    }\r\n                },\r\n                onFail: function (err) {\r\n                    if (t._db.doingTransaction) {\r\n                        res(err, t._db);\r\n                    }\r\n                    else {\r\n                        t._db._triggerEvents = [\"error\"];\r\n                        if (rej)\r\n                            _tEvent(err, rej, \"error\", [], true);\r\n                    }\r\n                }\r\n            };\r\n            if (t._db._queryMod) {\r\n                t._db._queryMod(execArgs, function (newArgs) {\r\n                    t._db.backend._exec(newArgs);\r\n                });\r\n            }\r\n            else {\r\n                t._db.backend._exec(execArgs);\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\nvar _NanoSQLStatic = new NanoSQLInstance();\r\nexports.nSQL = function (setTablePointer) {\r\n    return _NanoSQLStatic.table(setTablePointer);\r\n};\r\n"
    },
    {
      "id": 1,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
      "name": "./src/db-index.ts",
      "index": 2,
      "index2": 4,
      "size": 9753,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
      "issuerId": 0,
      "issuerName": "./src/index.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "module": "./src/index.ts",
          "moduleName": "./src/index.ts",
          "type": "cjs require",
          "userRequest": "./db-index",
          "loc": "2:17-38"
        },
        {
          "moduleId": 3,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
          "module": "./src/db-query.ts",
          "moduleName": "./src/db-query.ts",
          "type": "cjs require",
          "userRequest": "./db-index",
          "loc": "3:17-38"
        },
        {
          "moduleId": 4,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "module": "./src/db-storage.ts",
          "moduleName": "./src/db-storage.ts",
          "type": "cjs require",
          "userRequest": "./db-index",
          "loc": "3:17-38"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar lie_ts_1 = require(\"lie-ts\");\r\nvar db_storage_1 = require(\"./db-storage\");\r\nvar db_query_1 = require(\"./db-query\");\r\nexports._str = function (index) {\r\n    return [\"_utility\", \"_historyPoints\", \"_pointer\", \"_historyDataRowIDs\"][index];\r\n};\r\nvar _NanoSQLDB = (function () {\r\n    function _NanoSQLDB() {\r\n        var t = this;\r\n        t._pendingQuerys = [];\r\n        t._queryCache = {};\r\n    }\r\n    _NanoSQLDB.prototype._connect = function (connectArgs) {\r\n        var t = this;\r\n        t._databaseID = index_1.NanoSQLInstance._hash(JSON.stringify(connectArgs._models)).toString();\r\n        t._parent = connectArgs._parent;\r\n        t._store = new db_storage_1._NanoSQL_Storage(t, connectArgs);\r\n    };\r\n    _NanoSQLDB.prototype._exec = function (execArgs) {\r\n        var t = this;\r\n        new db_query_1._NanoSQLQuery(t)._doQuery(execArgs);\r\n    };\r\n    _NanoSQLDB.prototype._invalidateCache = function (changedTableID, changedRows, type, action) {\r\n        var t = this;\r\n        t._queryCache[changedTableID] = {};\r\n        if (changedRows.length && action) {\r\n            t._parent.triggerEvent({\r\n                name: \"change\",\r\n                actionOrView: \"\",\r\n                table: t._store._tables[changedTableID]._name,\r\n                query: [],\r\n                time: new Date().getTime(),\r\n                result: [{ msg: action + \" was performed.\", type: action }],\r\n                changedRows: changedRows,\r\n                changeType: type\r\n            }, [\"change\"]);\r\n        }\r\n    };\r\n    _NanoSQLDB.prototype._deepFreeze = function (obj, tableID) {\r\n        if (!obj)\r\n            return obj;\r\n        var t = this;\r\n        t._store._models[tableID].forEach(function (model) {\r\n            var prop = obj[model.key];\r\n            if ([\"map\", \"array\"].indexOf(typeof prop) >= 0) {\r\n                obj[model.key] = t._deepFreeze(prop, tableID);\r\n            }\r\n        });\r\n        return Object.freeze(obj);\r\n    };\r\n    _NanoSQLDB.prototype._transaction = function (type) {\r\n        var t = this;\r\n        if (type === \"start\") {\r\n            t._store._transactionData = {};\r\n            t._store._doingTransaction = true;\r\n        }\r\n        ;\r\n        if (type === \"end\") {\r\n            t._store._doingTransaction = false;\r\n            t._store._execTransaction();\r\n        }\r\n        ;\r\n        return !!t._store._doingTransaction;\r\n    };\r\n    _NanoSQLDB.prototype._extend = function (db, command) {\r\n        var t = this;\r\n        var i;\r\n        var h;\r\n        var j;\r\n        var rowID;\r\n        var rowData;\r\n        var rowKey;\r\n        var store;\r\n        var shiftRowIDs = function (direction, callBack) {\r\n            var results = {};\r\n            var check = (t._store._historyLength - t._store._historyPoint);\r\n            t._store._read(\"_historyPoints\", function (row) {\r\n                return row.historyPoint === check;\r\n            }, function (hps) {\r\n                j = 0;\r\n                var nextPoint = function () {\r\n                    if (j < hps.length) {\r\n                        i = 0;\r\n                        var tableID_1 = hps[j].tableID;\r\n                        var table_1 = t._store._tables[tableID_1];\r\n                        var rows_1 = [];\r\n                        var nextRow_1 = function () {\r\n                            if (i < hps[j].rowKeys.length) {\r\n                                rowID = hps[j].rowKeys[i];\r\n                                if (table_1._pkType === \"int\")\r\n                                    rowID = parseInt(rowID);\r\n                                t._store._read(table_1._name, rowID, function (rowData) {\r\n                                    if (direction > 0)\r\n                                        rows_1.push(rowData[0]);\r\n                                    t._store._read(\"_\" + table_1._name + \"_hist__meta\", rowID, function (row) {\r\n                                        row = index_1._assign(row);\r\n                                        row[0][exports._str(2)] += direction;\r\n                                        var historyRowID = row[0][exports._str(3)][row[0][exports._str(2)]];\r\n                                        t._store._upsert(\"_\" + table_1._name + \"_hist__meta\", rowID, row[0], function () {\r\n                                            t._store._read(\"_\" + table_1._name + \"_hist__data\", historyRowID, function (row) {\r\n                                                var newRow = row[0] ? index_1._assign(row[0]) : null;\r\n                                                t._store._upsert(table_1._name, rowID, newRow, function () {\r\n                                                    if (direction < 0)\r\n                                                        rows_1.push(newRow);\r\n                                                    if (!results[tableID_1])\r\n                                                        results[tableID_1] = { type: hps[j].type, rows: [] };\r\n                                                    results[tableID_1].rows = results[tableID_1].rows.concat(rows_1);\r\n                                                    i++;\r\n                                                    nextRow_1();\r\n                                                });\r\n                                            });\r\n                                        });\r\n                                    });\r\n                                });\r\n                            }\r\n                            else {\r\n                                j++;\r\n                                nextPoint();\r\n                            }\r\n                        };\r\n                        nextRow_1();\r\n                    }\r\n                    else {\r\n                        callBack(results);\r\n                    }\r\n                };\r\n                nextPoint();\r\n            });\r\n        };\r\n        return new lie_ts_1.Promise(function (res, rej) {\r\n            switch (command) {\r\n                case \"<\":\r\n                    if (!t._store._historyLength || t._store._historyPoint === t._store._historyLength) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        shiftRowIDs(1, function (affectedTables) {\r\n                            t._store._historyPoint++;\r\n                            t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                var description = affectedTables[tableID].type;\r\n                                switch (description) {\r\n                                    case \"inserted\":\r\n                                        description = \"deleted\";\r\n                                        break;\r\n                                    case \"deleted\":\r\n                                        description = \"inserted\";\r\n                                        break;\r\n                                }\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, description, \"undo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \">\":\r\n                    if (!t._store._historyLength || t._store._historyPoint < 1) {\r\n                        res(false);\r\n                    }\r\n                    else {\r\n                        t._store._historyPoint--;\r\n                        t._store._utility(\"w\", \"historyPoint\", t._store._historyPoint);\r\n                        shiftRowIDs(-1, function (affectedTables) {\r\n                            Object.keys(affectedTables).forEach(function (tableID) {\r\n                                t._invalidateCache(parseInt(tableID), affectedTables[tableID].rows, affectedTables[tableID].type, \"redo\");\r\n                            });\r\n                            res(true);\r\n                        });\r\n                    }\r\n                    break;\r\n                case \"?\":\r\n                    h = [t._store._historyLength, t._store._historyLength - t._store._historyPoint];\r\n                    if (t._store._historyArray.join(\"+\") !== h.join(\"+\")) {\r\n                        t._store._historyArray = h;\r\n                    }\r\n                    res(t._store._historyArray);\r\n                    break;\r\n                case \"flush_history\":\r\n                case \"flush_db\":\r\n                    t._store._utility(\"w\", \"historyPoint\", 0);\r\n                    t._store._utility(\"w\", \"historyLength\", 0);\r\n                    t._store._historyPoint = 0;\r\n                    t._store._historyLength = 0;\r\n                    Object.keys(t._store._tables).forEach(function (tableID) {\r\n                        var rows;\r\n                        if (t._store._tables[parseInt(tableID)]._name.indexOf(\"_\") === 0) {\r\n                            rows = [];\r\n                        }\r\n                        else {\r\n                            rows = t._store._tables[parseInt(tableID)]._rows;\r\n                            rows = Object.keys(rows).map(function (r) { return rows[r]; });\r\n                        }\r\n                        t._invalidateCache(parseInt(tableID), rows, \"remove\", \"clear\");\r\n                    });\r\n                    if (command === \"flush_db\") {\r\n                        t._store._clear(\"all\", res);\r\n                    }\r\n                    else {\r\n                        t._store._clear(\"hist\", res);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    return _NanoSQLDB;\r\n}());\r\nexports._NanoSQLDB = _NanoSQLDB;\r\n"
    },
    {
      "id": 2,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\lie-ts\\index.js",
      "name": "./~/lie-ts/index.js",
      "index": 3,
      "index2": 0,
      "size": 8489,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
      "issuerId": 0,
      "issuerName": "./src/index.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\index.ts",
          "module": "./src/index.ts",
          "moduleName": "./src/index.ts",
          "type": "cjs require",
          "userRequest": "lie-ts",
          "loc": "3:15-32"
        },
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "module": "./src/db-index.ts",
          "moduleName": "./src/db-index.ts",
          "type": "cjs require",
          "userRequest": "lie-ts",
          "loc": "3:15-32"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar _INTERNAL = function () { };\r\nvar _REJECTED = ['R'];\r\nvar _FULFILLED = ['F'];\r\nvar _PENDING = ['P'];\r\nvar setFast = typeof setImmediate !== \"undefined\" ? setImmediate : setTimeout;\r\nvar Promise = (function () {\r\n    function Promise(resolver) {\r\n        this._state = _PENDING;\r\n        this._queue = [];\r\n        this._outcome = void 0;\r\n        if (resolver !== _INTERNAL) {\r\n            _safelyResolveThenable(this, resolver);\r\n        }\r\n    }\r\n    Promise.prototype.catch = function (onRejected) {\r\n        return this.then(function () { }, onRejected);\r\n    };\r\n    Promise.prototype.then = function (onFulfilled, onRejected) {\r\n        if (typeof onFulfilled !== 'function' && this._state === _FULFILLED ||\r\n            typeof onRejected !== 'function' && this._state === _REJECTED) {\r\n            return this;\r\n        }\r\n        var promise = new Promise(_INTERNAL);\r\n        if (this._state !== _PENDING) {\r\n            var resolver = this._state === _FULFILLED ? onFulfilled : onRejected;\r\n            _unwrap(promise, resolver, this._outcome);\r\n        }\r\n        else {\r\n            this._queue.push(new _QueueItem(promise, onFulfilled, onRejected));\r\n        }\r\n        return promise;\r\n    };\r\n    /**\r\n     *\r\n     * @static\r\n     * @param {any} value\r\n     * @returns\r\n     *\r\n     * @memberOf Promise\r\n     */\r\n    Promise.resolve = function (value) {\r\n        if (value instanceof this) {\r\n            return value;\r\n        }\r\n        return _handlers._resolve(new Promise(_INTERNAL), value);\r\n    };\r\n    /**\r\n     *\r\n     * @static\r\n     * @param {any} reason\r\n     * @returns\r\n     *\r\n     * @memberOf Promise\r\n     */\r\n    Promise.reject = function (reason) {\r\n        return _handlers._reject(new Promise(_INTERNAL), reason);\r\n    };\r\n    Promise.all = function (iterable) {\r\n        var self = this;\r\n        var len = iterable.length;\r\n        var called = false;\r\n        var values = new Array(len);\r\n        var resolved = 0;\r\n        var i = -1;\r\n        var promise = new Promise(_INTERNAL);\r\n        if (!len) {\r\n            return this.resolve([]);\r\n        }\r\n        while (++i < len) {\r\n            allResolver(iterable[i], i);\r\n        }\r\n        return promise;\r\n        function allResolver(value, i) {\r\n            self.resolve(value).then(resolveFromAll, function (error) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._reject(promise, error);\r\n                }\r\n            });\r\n            function resolveFromAll(outValue) {\r\n                values[i] = outValue;\r\n                if (++resolved === len && !called) {\r\n                    called = true;\r\n                    _handlers._resolve(promise, values);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Promise.race = function (iterable) {\r\n        var self = this;\r\n        var len = iterable.length;\r\n        var called = false;\r\n        var i = -1;\r\n        var promise = new Promise(_INTERNAL);\r\n        if (Array.isArray(iterable) !== false) {\r\n            return this.reject(new TypeError());\r\n        }\r\n        function resolver(value) {\r\n            self.resolve(value).then(function (response) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._resolve(promise, response);\r\n                }\r\n            }, function (error) {\r\n                if (!called) {\r\n                    called = true;\r\n                    _handlers._reject(promise, error);\r\n                }\r\n            });\r\n        }\r\n        if (!len) {\r\n            return this.resolve([]);\r\n        }\r\n        while (++i < len) {\r\n            resolver(iterable[i]);\r\n        }\r\n        return promise;\r\n    };\r\n    return Promise;\r\n}());\r\nexports.Promise = Promise;\r\n/**\r\n * @internal\r\n *\r\n * @export\r\n * @class _QueueItem\r\n */\r\nvar _QueueItem = (function () {\r\n    function _QueueItem(promise, onFulfilled, onRejected) {\r\n        this._promise = promise;\r\n        if (typeof onFulfilled === 'function') {\r\n            this._onFulfilled = onFulfilled;\r\n            this._callFulfilled = this._otherCallFulfilled;\r\n        }\r\n        if (typeof onRejected === 'function') {\r\n            this._onRejected = onRejected;\r\n            this._callRejected = this._otherCallRejected;\r\n        }\r\n    }\r\n    _QueueItem.prototype._callFulfilled = function (value) {\r\n        _handlers._resolve(this._promise, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._otherCallFulfilled = function (value) {\r\n        _unwrap(this._promise, this._onFulfilled, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._callRejected = function (value) {\r\n        _handlers._reject(this._promise, value);\r\n    };\r\n    ;\r\n    _QueueItem.prototype._otherCallRejected = function (value) {\r\n        _unwrap(this._promise, this._onRejected, value);\r\n    };\r\n    ;\r\n    return _QueueItem;\r\n}());\r\nexports._QueueItem = _QueueItem;\r\n/**\r\n *\r\n * @internal\r\n * @param {any} promise\r\n * @param {any} func\r\n * @param {any} value\r\n */\r\nfunction _unwrap(promise, func, value) {\r\n    setFast(function () {\r\n        var returnValue;\r\n        try {\r\n            returnValue = func.apply(null, value);\r\n        }\r\n        catch (e) {\r\n            return _handlers._reject(promise, e);\r\n        }\r\n        if (returnValue === promise) {\r\n            _handlers._reject(promise, new TypeError());\r\n        }\r\n        else {\r\n            _handlers._resolve(promise, returnValue);\r\n        }\r\n        return null;\r\n    });\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @class _handlers\r\n */\r\nvar _handlers = (function () {\r\n    function _handlers() {\r\n    }\r\n    _handlers._resolve = function (self, value) {\r\n        var result = _tryCatch(_getThen, value);\r\n        var thenable = result._value;\r\n        var i = -1;\r\n        var len = self._queue.length;\r\n        if (result._status === 'error') {\r\n            return _handlers._reject(self, result._value);\r\n        }\r\n        if (thenable) {\r\n            _safelyResolveThenable(self, thenable);\r\n        }\r\n        else {\r\n            self._state = _FULFILLED;\r\n            self._outcome = value;\r\n            while (++i < len) {\r\n                self._queue[i]._callFulfilled(value);\r\n            }\r\n        }\r\n        return self;\r\n    };\r\n    ;\r\n    _handlers._reject = function (self, error) {\r\n        self._state = _REJECTED;\r\n        self._outcome = error;\r\n        var i = -1;\r\n        var len = self._queue.length;\r\n        while (++i < len) {\r\n            self._queue[i]._callRejected(error);\r\n        }\r\n        return self;\r\n    };\r\n    ;\r\n    return _handlers;\r\n}());\r\n/**\r\n *\r\n * @internal\r\n * @param {any} obj\r\n * @returns\r\n */\r\nfunction _getThen(obj) {\r\n    // Make sure we only access the accessor once as required by the spec\r\n    var then = obj && obj.then;\r\n    if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\r\n        return function appyThen() {\r\n            then.apply(obj, arguments);\r\n        };\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @param {Promise<any>} self\r\n * @param {(onSuccess:(...T) => void, onFail:(...T) => void) => void} thenable\r\n */\r\nfunction _safelyResolveThenable(self, thenable) {\r\n    // Either fulfill, reject or reject with error\r\n    var called = false;\r\n    function onError() {\r\n        var value = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            value[_i] = arguments[_i];\r\n        }\r\n        if (called) {\r\n            return;\r\n        }\r\n        called = true;\r\n        _handlers._reject(self, value);\r\n    }\r\n    function onSuccess() {\r\n        var value = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            value[_i] = arguments[_i];\r\n        }\r\n        if (called) {\r\n            return;\r\n        }\r\n        called = true;\r\n        _handlers._resolve(self, value);\r\n    }\r\n    function tryToUnwrap() {\r\n        thenable(onSuccess, onError);\r\n    }\r\n    var result = _tryCatch(tryToUnwrap);\r\n    if (result._status === 'error') {\r\n        onError(result._value);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n * @param {any} func\r\n * @param {*} [values]\r\n * @returns\r\n */\r\nfunction _tryCatch(func, values) {\r\n    var out = { _status: null, _value: null };\r\n    try {\r\n        out._value = func(values);\r\n        out._status = 'success';\r\n    }\r\n    catch (e) {\r\n        out._status = 'error';\r\n        out._value = e;\r\n    }\r\n    return out;\r\n}\r\n"
    },
    {
      "id": 3,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-query.ts",
      "name": "./src/db-query.ts",
      "index": 5,
      "index2": 1,
      "size": 42349,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
      "issuerId": 1,
      "issuerName": "./src/db-index.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "module": "./src/db-index.ts",
          "moduleName": "./src/db-index.ts",
          "type": "cjs require",
          "userRequest": "./db-query",
          "loc": "5:17-38"
        },
        {
          "moduleId": 4,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "module": "./src/db-storage.ts",
          "moduleName": "./src/db-storage.ts",
          "type": "cjs require",
          "userRequest": "./db-query",
          "loc": "4:17-38"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar minMax = function (type, row, args, ptr, prev) {\r\n    var key = args[0];\r\n    if (ptr[0] === 0)\r\n        prev[key] = type === -1 ? Number.MAX_VALUE : Number.MIN_VALUE;\r\n    var nextRow = {};\r\n    if (type === -1 ? parseFloat(row[key]) < parseFloat(prev[key]) : parseFloat(row[key]) > parseFloat(prev[key])) {\r\n        nextRow = row;\r\n    }\r\n    else {\r\n        nextRow = prev;\r\n    }\r\n    if (ptr[0] === ptr[1]) {\r\n        var r = index_1._assign(nextRow);\r\n        r[type === -1 ? \"MIN\" : \"MAX\"] = nextRow[key];\r\n        return r;\r\n    }\r\n    else {\r\n        return nextRow;\r\n    }\r\n};\r\nexports._functions = {\r\n    SUM: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.SUM = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    MIN: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(-1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    MAX: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            return minMax(1, row, args, ptr, prev);\r\n        }\r\n    },\r\n    AVG: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            prev += parseInt(row[args[0]]);\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.AVG = (prev / (ptr[1] + 1)) || prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    },\r\n    COUNT: {\r\n        type: \"aggregate\",\r\n        call: function (row, args, ptr, prev) {\r\n            if (ptr[0] === 0)\r\n                prev = 0;\r\n            if (args[0] === \"*\") {\r\n                prev++;\r\n            }\r\n            else {\r\n                prev += row[args[0]] ? 1 : 0;\r\n            }\r\n            if (ptr[0] === ptr[1]) {\r\n                var r = index_1._assign(row);\r\n                r.COUNT = prev;\r\n                return r;\r\n            }\r\n            else {\r\n                return prev;\r\n            }\r\n        }\r\n    }\r\n};\r\nvar _NanoSQLQuery = (function () {\r\n    function _NanoSQLQuery(database) {\r\n        this._db = database;\r\n    }\r\n    _NanoSQLQuery.prototype._doQuery = function (query) {\r\n        var t = this;\r\n        t._tableID = index_1.NanoSQLInstance._hash(query.table);\r\n        t._mod = [];\r\n        t._act = undefined;\r\n        var simpleQuery = [];\r\n        query.query.forEach(function (q) {\r\n            if ([\"upsert\", \"select\", \"delete\", \"drop\"].indexOf(q.type) >= 0) {\r\n                t._act = q;\r\n                if (q.type === \"select\")\r\n                    t._queryHash = index_1.NanoSQLInstance._hash(JSON.stringify(query.query));\r\n            }\r\n            else if ([\"show tables\", \"describe\"].indexOf(q.type) >= 0) {\r\n                simpleQuery.push(q);\r\n            }\r\n            else {\r\n                t._mod.push(q);\r\n            }\r\n        });\r\n        if (simpleQuery.length) {\r\n            switch (simpleQuery[0].type) {\r\n                case \"show tables\":\r\n                    query.onSuccess([{ tables: Object.keys(t._db._store._tables).map(function (ta) { return t._db._store._tables[ta]._name; }) }], \"info\", []);\r\n                    break;\r\n                case \"describe\":\r\n                    var getTable_1;\r\n                    var tableName_1 = t._tableID;\r\n                    var rows = {};\r\n                    Object.keys(t._db._store._tables).forEach(function (ta) {\r\n                        if (parseInt(ta) === t._tableID) {\r\n                            getTable_1 = index_1._assign(t._db._store._models[ta]);\r\n                            tableName_1 = t._db._store._tables[ta]._name;\r\n                        }\r\n                    });\r\n                    rows[tableName_1] = getTable_1;\r\n                    query.onSuccess([rows], \"info\", []);\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            t._execQuery(function (result, changeType, affectedRows) {\r\n                query.onSuccess(result, changeType, affectedRows);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getMod = function (name) {\r\n        return this._mod.filter(function (v) { return v.type === name; }).pop();\r\n    };\r\n    _NanoSQLQuery.prototype._execQuery = function (callBack) {\r\n        var t = this;\r\n        if (!t._act)\r\n            return;\r\n        var doQuery = function (rows) {\r\n            if (!t._act)\r\n                return;\r\n            switch (t._act.type) {\r\n                case \"upsert\":\r\n                    t._upsert(rows, callBack);\r\n                    break;\r\n                case \"select\":\r\n                    t._select(rows, callBack);\r\n                    break;\r\n                case \"drop\":\r\n                case \"delete\":\r\n                    t._remove(rows, callBack);\r\n                    break;\r\n            }\r\n        };\r\n        var tableData = t._db._store._tables[t._tableID];\r\n        if (!t._getMod(\"join\") && t._act.type !== \"drop\") {\r\n            if (t._getMod(\"where\")) {\r\n                var whereArgs_1 = t._getMod(\"where\").args;\r\n                var isOptimizedWhere_1 = function (wArgs) {\r\n                    if ([\"=\", \"IN\", \"BETWEEN\"].indexOf(wArgs[1]) !== -1) {\r\n                        if (wArgs[0] === tableData._pk) {\r\n                            return 0;\r\n                        }\r\n                        else if (tableData._secondaryIndexes.indexOf(wArgs[0]) !== -1) {\r\n                            return 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                    return 1;\r\n                };\r\n                var doFastWhere_1 = function (wArgs, callBack) {\r\n                    var tableName = wArgs[0] === tableData._pk ? tableData._name : \"_\" + tableData._name + \"_idx_\" + wArgs[0];\r\n                    switch (wArgs[1]) {\r\n                        case \"=\":\r\n                            t._db._store._read(tableName, wArgs[2], function (rows) {\r\n                                callBack(rows);\r\n                            });\r\n                            break;\r\n                        case \"IN\":\r\n                            var ptr_1 = 0;\r\n                            var resultRows_1 = [];\r\n                            var step_1 = function () {\r\n                                if (ptr_1 < wArgs[2].length) {\r\n                                    t._db._store._read(tableName, wArgs[2][ptr_1], function (rows) {\r\n                                        resultRows_1 = resultRows_1.concat(rows);\r\n                                        ptr_1++;\r\n                                        step_1();\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    callBack(resultRows_1);\r\n                                }\r\n                            };\r\n                            step_1();\r\n                            break;\r\n                        case \"BETWEEN\":\r\n                            t._db._store._readRange(tableName, wArgs[0], wArgs[2], callBack);\r\n                            break;\r\n                    }\r\n                };\r\n                var doFastRead = false;\r\n                if (typeof whereArgs_1[0] === \"string\") {\r\n                    doFastRead = isOptimizedWhere_1(whereArgs_1) === 0;\r\n                }\r\n                else {\r\n                    doFastRead = whereArgs_1.reduce(function (prev, cur, i) {\r\n                        if (i % 2 === 1)\r\n                            return prev;\r\n                        return prev + isOptimizedWhere_1(cur);\r\n                    }, 0) === 0;\r\n                }\r\n                if (doFastRead) {\r\n                    if (typeof whereArgs_1[0] === \"string\") {\r\n                        doFastWhere_1(whereArgs_1, doQuery);\r\n                    }\r\n                    else {\r\n                        var resultRows_2 = [];\r\n                        var ptr_2 = 0;\r\n                        var lastCommand_1 = \"\";\r\n                        var nextWhere_1 = function () {\r\n                            if (ptr_2 < whereArgs_1.length) {\r\n                                if (ptr_2 % 2 === 1) {\r\n                                    lastCommand_1 = whereArgs_1[ptr_2];\r\n                                    ptr_2++;\r\n                                    nextWhere_1();\r\n                                }\r\n                                else {\r\n                                    doFastWhere_1(whereArgs_1[ptr_2], function (rows) {\r\n                                        if (lastCommand_1 === \"AND\") {\r\n                                            var idx_1 = rows.map(function (r) { return r[tableData._pk]; });\r\n                                            resultRows_2 = resultRows_2.filter(function (row) {\r\n                                                return idx_1.indexOf(row[tableData._pk]) !== -1;\r\n                                            });\r\n                                        }\r\n                                        else {\r\n                                            resultRows_2 = resultRows_2.concat(rows);\r\n                                        }\r\n                                        ptr_2++;\r\n                                        nextWhere_1();\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                doQuery(resultRows_2);\r\n                            }\r\n                        };\r\n                        nextWhere_1();\r\n                    }\r\n                }\r\n                else {\r\n                    t._db._store._read(tableData._name, function (row) {\r\n                        return row && t._where(row, whereArgs_1);\r\n                    }, function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n            }\r\n            else if (t._getMod(\"range\")) {\r\n                var rangeArgs = t._getMod(\"range\").args;\r\n                t._getRange(rangeArgs[0], rangeArgs[1], doQuery);\r\n            }\r\n            else if (t._getMod(\"trie\")) {\r\n                var trieArgs = t._getMod(\"trie\").args;\r\n                var words_1 = tableData._trieObjects[trieArgs[0]].getPrefix(String(trieArgs[1]).toLocaleLowerCase());\r\n                var indexTable_1 = \"_\" + tableData._name + \"_idx_\" + trieArgs[0];\r\n                var ptr_3 = 0;\r\n                var resultRows_3 = [];\r\n                var step_2 = function () {\r\n                    if (ptr_3 < words_1.length) {\r\n                        t._db._store._read(indexTable_1, words_1[ptr_3], function (rows) {\r\n                            resultRows_3 = resultRows_3.concat(rows);\r\n                            ptr_3++;\r\n                            step_2();\r\n                        });\r\n                    }\r\n                    else {\r\n                        doQuery(resultRows_3);\r\n                    }\r\n                };\r\n                step_2();\r\n            }\r\n            else {\r\n                if (t._act.type !== \"upsert\") {\r\n                    t._db._store._read(tableData._name, \"all\", function (rows) {\r\n                        doQuery(rows);\r\n                    });\r\n                }\r\n                else {\r\n                    doQuery([]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            doQuery([]);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getRange = function (limit, offset, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var startIndex = table._index[offset];\r\n        var endIndex = table._index[offset + (limit - 1)];\r\n        t._db._store._readRange(table._name, table._pk, [startIndex, endIndex], function (rows) {\r\n            callBack(rows);\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._updateRow = function (rowPK, callBack) {\r\n        var t = this;\r\n        var table = t._db._store._tables[t._tableID];\r\n        var qArgs = t._act.args;\r\n        var updateType = (function () {\r\n            if (t._act) {\r\n                if (t._act.type === \"delete\" && !qArgs.length) {\r\n                    return \"drop\";\r\n                }\r\n            }\r\n            return t._act ? t._act.type : \"\";\r\n        })();\r\n        var updateSecondaryIndex = function (newRow, rem) {\r\n            if (table._name.indexOf(\"_\") !== 0) {\r\n                var emptyColumns_1 = [];\r\n                table._secondaryIndexes.forEach(function (key) {\r\n                    var idxTable = \"_\" + table._name + \"_idx_\" + key;\r\n                    var rowID = String(newRow[key]).toLocaleLowerCase();\r\n                    t._db._store._read(idxTable, rowID, function (rows) {\r\n                        var indexedRows = [];\r\n                        if (rows.length && rows[0].rowPK)\r\n                            indexedRows = indexedRows.concat(rows[0].rowPK);\r\n                        if (!rem)\r\n                            indexedRows.push(newRow[table._pk]);\r\n                        indexedRows = indexedRows.filter(function (item, pos) {\r\n                            return indexedRows.indexOf(item) === pos || !(rem && item === newRow[table._pk]);\r\n                        });\r\n                        if (indexedRows.length) {\r\n                            t._db._store._upsert(idxTable, rowID, {\r\n                                id: newRow[key],\r\n                                rowPK: indexedRows\r\n                            }, function () { });\r\n                        }\r\n                        else {\r\n                            emptyColumns_1.push(key);\r\n                            t._db._store._delete(idxTable, rowID);\r\n                        }\r\n                    }, true);\r\n                });\r\n                table._trieColumns.forEach(function (key) {\r\n                    var word = String(newRow[key]).toLocaleLowerCase();\r\n                    if (emptyColumns_1.indexOf(key) !== -1) {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].removeWord(word);\r\n                    }\r\n                    else {\r\n                        t._db._store._tables[t._tableID]._trieObjects[key].addWord(word);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        var writeChanges = function (newRow) {\r\n            if (updateType === \"upsert\") {\r\n                updateSecondaryIndex(newRow);\r\n                t._db._store._upsert(table._name, rowPK, newRow, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n            else {\r\n                updateSecondaryIndex(newRow, true);\r\n                t._db._store._delete(table._name, rowPK, function () {\r\n                    callBack();\r\n                });\r\n            }\r\n        };\r\n        if (t._db._store._doingTransaction) {\r\n            if (updateType === \"upsert\") {\r\n                writeChanges(qArgs);\r\n            }\r\n            else {\r\n                writeChanges({});\r\n            }\r\n            return;\r\n        }\r\n        t._db._store._read(table._name, rowPK, function (rows) {\r\n            var newRow = {};\r\n            var oldRow = rows[0] || {};\r\n            var doRemove = false;\r\n            switch (updateType) {\r\n                case \"upsert\":\r\n                    newRow = oldRow ? index_1._assign(oldRow) : {};\r\n                    Object.keys(qArgs).forEach(function (k) {\r\n                        newRow[k] = qArgs[k];\r\n                    });\r\n                    var table_1 = t._db._store._tables[t._tableID];\r\n                    table_1._keys.forEach(function (k, i) {\r\n                        var def = table_1._defaults[i];\r\n                        if (!newRow[k] && def)\r\n                            newRow[k] = def;\r\n                    });\r\n                    break;\r\n                case \"delete\":\r\n                    newRow = oldRow ? index_1._assign(oldRow) : {};\r\n                    if (qArgs && qArgs.length) {\r\n                        qArgs.forEach(function (column) {\r\n                            newRow[column] = null;\r\n                        });\r\n                    }\r\n                    else {\r\n                        doRemove = true;\r\n                        newRow = {};\r\n                    }\r\n                    break;\r\n            }\r\n            var finishUpdate = function () {\r\n                if (table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory && table._pk.length) {\r\n                    t._db._store._read(\"_\" + table._name + \"_hist__meta\", rowPK, function (rows) {\r\n                        if (!rows.length || !rows[0]) {\r\n                            rows[0] = {};\r\n                            rows[0][db_index_1._str(2)] = 0;\r\n                            rows[0][db_index_1._str(3)] = [];\r\n                            rows[0].id = rowPK;\r\n                        }\r\n                        rows[0][db_index_1._str(3)].unshift(len);\r\n                        t._db._store._upsert(\"_\" + table._name + \"_hist__meta\", rowPK, rows[0]);\r\n                    });\r\n                }\r\n                writeChanges(newRow);\r\n            };\r\n            var len = 0;\r\n            if (!doRemove && table._name.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                t._db._store._upsert(\"_\" + table._name + \"_hist__data\", null, newRow, function (rowID) {\r\n                    len = parseInt(rowID);\r\n                    finishUpdate();\r\n                });\r\n            }\r\n            else {\r\n                finishUpdate();\r\n            }\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._tableChanged = function (updatedRowPKs, describe, callBack) {\r\n        var _this = this;\r\n        var t = this, k = 0, j = 0;\r\n        if (t._db._store._doingTransaction) {\r\n            callBack([], \"trans\", []);\r\n            return;\r\n        }\r\n        if (updatedRowPKs.length > 0) {\r\n            var completeChange_1 = function () {\r\n                if (t._db._store._doHistory) {\r\n                    if (!t._db._store._doingTransaction && t._db._store._historyPoint === 0) {\r\n                        t._db._store._historyLength++;\r\n                    }\r\n                    t._db._store._utility(\"w\", \"historyLength\", t._db._store._historyLength);\r\n                    t._db._store._utility(\"w\", \"historyPoint\", t._db._store._historyPoint);\r\n                    t._db._store._upsert(\"_historyPoints\", null, {\r\n                        historyPoint: t._db._store._historyLength - t._db._store._historyPoint,\r\n                        tableID: t._tableID,\r\n                        rowKeys: updatedRowPKs.map(function (r) { return parseInt(r); }),\r\n                        type: describe\r\n                    }, function (rowID) {\r\n                        var table = t._db._store._tables[_this._tableID];\r\n                        t._db._invalidateCache(t._tableID, [], \"\");\r\n                        t._db._store._read(table._name, function (row) {\r\n                            return row && updatedRowPKs.indexOf(row[table._pk]) !== -1;\r\n                        }, function (rows) {\r\n                            callBack([{ msg: updatedRowPKs.length + \" row(s) \" + describe }], describe, rows);\r\n                        });\r\n                    });\r\n                }\r\n                else {\r\n                    var table_2 = t._db._store._tables[t._tableID];\r\n                    t._db._invalidateCache(t._tableID, [], \"\");\r\n                    t._db._store._read(table_2._name, function (row) {\r\n                        return row && updatedRowPKs.indexOf(row[table_2._pk]) !== -1;\r\n                    }, function (rows) {\r\n                        callBack([{ msg: updatedRowPKs.length + \" row(s) \" + describe }], describe, rows);\r\n                    });\r\n                }\r\n            };\r\n            if (t._db._store._doHistory) {\r\n                if (t._db._store._historyPoint > 0) {\r\n                    t._db._store._read(\"_historyPoints\", function (hp) {\r\n                        if (hp.historyPoint > t._db._store._historyLength - t._db._store._historyPoint)\r\n                            return true;\r\n                        return false;\r\n                    }, function (historyPoints) {\r\n                        j = 0;\r\n                        var nextPoint = function () {\r\n                            if (j < historyPoints.length) {\r\n                                var tableName_2 = t._db._store._tables[historyPoints[j].tableID]._name;\r\n                                k = 0;\r\n                                var nextRow_1 = function () {\r\n                                    if (k < historyPoints[j].rowKeys.length) {\r\n                                        t._db._store._read(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], function (rows) {\r\n                                            rows[0] = index_1._assign(rows[0]);\r\n                                            rows[0][db_index_1._str(2)] = 0;\r\n                                            var del = rows[0][db_index_1._str(3)].shift();\r\n                                            t._db._store._upsert(\"_\" + tableName_2 + \"_hist__meta\", historyPoints[j].rowKeys[k], rows[0], function () {\r\n                                                if (del) {\r\n                                                    t._db._store._delete(\"_\" + tableName_2 + \"_hist__data\", del, function () {\r\n                                                        k++;\r\n                                                        nextRow_1();\r\n                                                    });\r\n                                                }\r\n                                                else {\r\n                                                    k++;\r\n                                                    nextRow_1();\r\n                                                }\r\n                                            });\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        j++;\r\n                                        nextPoint();\r\n                                    }\r\n                                };\r\n                                t._db._store._delete(\"_historyPoints\", historyPoints[j].id, function () {\r\n                                    nextRow_1();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._db._store._historyLength -= t._db._store._historyPoint;\r\n                                t._db._store._historyPoint = 0;\r\n                                completeChange_1();\r\n                                return;\r\n                            }\r\n                        };\r\n                        nextPoint();\r\n                    });\r\n                }\r\n                else {\r\n                    completeChange_1();\r\n                }\r\n            }\r\n            else {\r\n                completeChange_1();\r\n            }\r\n        }\r\n        else {\r\n            callBack([{ msg: \"0 rows \" + describe }], describe, []);\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._upsert = function (queryRows, callBack) {\r\n        var t = this;\r\n        var scribe = \"\", i, changedPKs = [];\r\n        var qArgs = t._act.args || {}, table = t._db._store._tables[t._tableID], pk = table._pk, whereMod = t._getMod(\"where\");\r\n        if (whereMod) {\r\n            scribe = \"modified\";\r\n            changedPKs = queryRows.map(function (r) { return r[table._pk]; });\r\n            i = 0;\r\n            var update_1 = function () {\r\n                if (i < queryRows.length) {\r\n                    t._updateRow(queryRows[i][pk], function () {\r\n                        i++;\r\n                        update_1();\r\n                    });\r\n                }\r\n                else {\r\n                    t._tableChanged(changedPKs, scribe, callBack);\r\n                }\r\n            };\r\n            update_1();\r\n        }\r\n        else {\r\n            scribe = \"inserted\";\r\n            if (!qArgs[pk]) {\r\n                switch (table._pkType) {\r\n                    case \"int\":\r\n                        qArgs[pk] = table._incriment++;\r\n                        break;\r\n                    case \"uuid\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.uuid();\r\n                        break;\r\n                    case \"timeId\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid();\r\n                        break;\r\n                    case \"timeIdms\":\r\n                        qArgs[pk] = index_1.NanoSQLInstance.timeid(true);\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (table._pkType === \"int\") {\r\n                    table._incriment = Math.max(qArgs[pk] + 1, table._incriment);\r\n                }\r\n            }\r\n            var objPK = qArgs[pk] ? qArgs[pk] : table._index.length;\r\n            changedPKs = [objPK];\r\n            if (table._index.indexOf(objPK) === -1) {\r\n                var tableName = t._db._store._tables[t._tableID]._name;\r\n                if (tableName.indexOf(\"_\") !== 0 && t._db._store._doHistory) {\r\n                    var histTable = \"_\" + tableName + \"_hist__meta\";\r\n                    var histRow = {};\r\n                    histRow[db_index_1._str(2)] = 0;\r\n                    histRow[db_index_1._str(3)] = [0];\r\n                    t._db._store._upsert(histTable, objPK, histRow);\r\n                }\r\n                table._index.push(objPK);\r\n            }\r\n            t._updateRow(objPK, function () {\r\n                t._tableChanged(changedPKs, scribe, callBack);\r\n            });\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._getTableID = function () {\r\n        return this._joinTable ? this._joinTable : this._tableID;\r\n    };\r\n    _NanoSQLQuery.prototype._select = function (queryRows, callBack) {\r\n        var t = this;\r\n        if (t._db._queryCache[t._tableID][t._queryHash]) {\r\n            callBack(t._db._queryCache[t._tableID][t._queryHash], \"none\", []);\r\n            return;\r\n        }\r\n        var mods = [\"join\", \"groupby\", \"having\", \"orderby\", \"offset\", \"limit\"];\r\n        var curMod, column, i, k, rows, obj, rowData, groups = {};\r\n        var sortObj = function (objA, objB, columns) {\r\n            return Object.keys(columns).reduce(function (prev, cur) {\r\n                if (!prev) {\r\n                    if (objA[cur] === objB[cur])\r\n                        return 0;\r\n                    return (objA[cur] > objB[cur] ? 1 : -1) * (columns[cur] === \"desc\" ? -1 : 1);\r\n                }\r\n                else {\r\n                    return prev;\r\n                }\r\n            }, 0);\r\n        };\r\n        var modifyQuery = function (tableIndex, modIndex, next) {\r\n            curMod = t._getMod(mods[modIndex]);\r\n            if (modIndex === 2) {\r\n                var functions_1 = [];\r\n                if (qArgs.length) {\r\n                    var funcs_1 = Object.keys(exports._functions).map(function (f) { return f + \"(\"; });\r\n                    var keepColumns_1 = [];\r\n                    functions_1 = qArgs.filter(function (q) {\r\n                        var hasFunc = funcs_1.reduce(function (prev, cur) {\r\n                            return (q.indexOf(cur) < 0 ? 0 : 1) + prev;\r\n                        }, 0) || 0;\r\n                        if (hasFunc > 0) {\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            keepColumns_1.push(q);\r\n                            return false;\r\n                        }\r\n                    }).map(function (selectString) {\r\n                        var regex = selectString.match(/(.*)\\((.*)\\)/);\r\n                        var funcName = regex[1].trim();\r\n                        var columnName = (selectString.match(/\\sAS\\s(.*)/) || []).pop() || funcName;\r\n                        var args = regex[2].split(\",\").map(function (s) { return s.trim(); });\r\n                        if (exports._functions[funcName].type === \"simple\" && columnName === funcName) {\r\n                            columnName = args[0];\r\n                        }\r\n                        keepColumns_1.push(columnName);\r\n                        return {\r\n                            name: funcName,\r\n                            args: args,\r\n                            as: columnName.trim(),\r\n                            type: exports._functions[funcName].type\r\n                        };\r\n                    });\r\n                    var rows_1 = [];\r\n                    if (functions_1.length) {\r\n                        var prevFunc_1;\r\n                        var doFunctions_1 = function (rows) {\r\n                            return functions_1.sort(function (a, b) {\r\n                                return a.type > b.type ? 1 : -1;\r\n                            }).reduce(function (prev, curr) {\r\n                                var len = prev.length - 1;\r\n                                if (curr.type === \"aggregate\") {\r\n                                    var newRows = rows.slice();\r\n                                    len = newRows.length - 1;\r\n                                    newRows = [newRows.reduce(function (p, v, i) {\r\n                                            return exports._functions[curr.name].call(v, curr.args, [i, len], p);\r\n                                        }, {})];\r\n                                    if (prevFunc_1) {\r\n                                        newRows[0][prevFunc_1] = prev[0][prevFunc_1];\r\n                                    }\r\n                                    prev = newRows;\r\n                                    prevFunc_1 = curr.name;\r\n                                }\r\n                                else {\r\n                                    prev = prev.map(function (v, i) {\r\n                                        return exports._functions[curr.name].call(v, curr.args, [i, len]);\r\n                                    });\r\n                                }\r\n                                if (curr.name !== curr.as) {\r\n                                    keepColumns_1.push(curr.name + \" AS \" + curr.as);\r\n                                }\r\n                                else {\r\n                                    keepColumns_1.push(curr.name);\r\n                                }\r\n                                return prev;\r\n                            }, rows.slice());\r\n                        };\r\n                        var groupKeys = Object.keys(groups);\r\n                        if (groupKeys.length) {\r\n                            rows_1 = groupKeys\r\n                                .map(function (k) { return prevFunc_1 = null, doFunctions_1(groups[k]); })\r\n                                .reduce(function (prev, curr) {\r\n                                return prev = prev.concat(curr), prev;\r\n                            }, []);\r\n                        }\r\n                        else {\r\n                            rows_1 = doFunctions_1(tableIndex);\r\n                        }\r\n                    }\r\n                    else {\r\n                        rows_1 = tableIndex;\r\n                    }\r\n                    var convertKeys_1 = keepColumns_1.map(function (n) {\r\n                        return n.match(/(.*)\\sAS\\s(.*)/) || n;\r\n                    }).filter(function (n) { return n; }) || [];\r\n                    if (convertKeys_1.length) {\r\n                        rows_1 = rows_1.map(function (r) {\r\n                            r = index_1._assign(r);\r\n                            var newRow = {};\r\n                            convertKeys_1.forEach(function (key) {\r\n                                if (typeof key === \"string\") {\r\n                                    newRow[key] = r[key];\r\n                                }\r\n                                else {\r\n                                    newRow[key[2]] = r[key[1]];\r\n                                }\r\n                            });\r\n                            return newRow;\r\n                        });\r\n                    }\r\n                    tableIndex = rows_1;\r\n                }\r\n            }\r\n            if (!curMod)\r\n                return next(tableIndex);\r\n            switch (modIndex) {\r\n                case 0:\r\n                    var joinConditions = void 0;\r\n                    if (curMod.args.type !== \"cross\") {\r\n                        joinConditions = {\r\n                            _left: curMod.args.where[0].split(\".\").pop(),\r\n                            _check: curMod.args.where[1],\r\n                            _right: curMod.args.where[2].split(\".\").pop()\r\n                        };\r\n                    }\r\n                    var leftTableID = t._tableID;\r\n                    var rightTableID = index_1.NanoSQLInstance._hash(curMod.args.table);\r\n                    var where_1 = t._getMod(\"where\");\r\n                    var range_1 = t._getMod(\"range\");\r\n                    t._join(curMod.args.type, leftTableID, rightTableID, joinConditions, function (joinedRows) {\r\n                        if (where_1) {\r\n                            next(joinedRows.filter(function (row) {\r\n                                return t._where(row, where_1.args);\r\n                            }));\r\n                        }\r\n                        else if (range_1) {\r\n                            t._getRange(range_1.args[0], range_1.args[1], next);\r\n                        }\r\n                        else {\r\n                            next(joinedRows);\r\n                        }\r\n                    });\r\n                    break;\r\n                case 1:\r\n                    var columns_1 = curMod.args;\r\n                    var sortGroups_1 = {};\r\n                    if (columns_1) {\r\n                        groups = tableIndex.reduce(function (prev, curr) {\r\n                            var key = Object.keys(columns_1).reduce(function (p, c) { return p + \".\" + String(curr[c]); }, \"\").slice(1);\r\n                            (prev[key] = prev[key] || []).push(curr);\r\n                            sortGroups_1[key] = Object.keys(columns_1).reduce(function (pr, cu) {\r\n                                pr[cu] = curr[cu];\r\n                                return pr;\r\n                            }, {});\r\n                            return prev;\r\n                        }, {});\r\n                        next(Object.keys(groups).sort(function (a, b) {\r\n                            return sortObj(sortGroups_1[a], sortGroups_1[b], columns_1);\r\n                        }).reduce(function (prev, curr) {\r\n                            return prev.concat(groups[curr]);\r\n                        }, []));\r\n                    }\r\n                    else {\r\n                        next(tableIndex);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    next(tableIndex.filter(function (row) {\r\n                        return t._where(row, t._getMod(\"having\").args);\r\n                    }));\r\n                    break;\r\n                case 3:\r\n                    next(tableIndex.sort(function (a, b) {\r\n                        return sortObj(a, b, curMod.args);\r\n                    }));\r\n                    break;\r\n                case 4:\r\n                    next(tableIndex.filter(function (row, index) {\r\n                        return curMod ? index >= curMod.args : true;\r\n                    }));\r\n                    break;\r\n                case 5:\r\n                    next(tableIndex.filter(function (row, index) {\r\n                        return curMod ? index < curMod.args : true;\r\n                    }));\r\n                    break;\r\n            }\r\n        };\r\n        i = -1;\r\n        var qArgs = t._act.args || [];\r\n        var stepQuery = function (rowPKs) {\r\n            if (i < mods.length) {\r\n                i++;\r\n                modifyQuery(rowPKs, i, function (resultRows) {\r\n                    stepQuery(resultRows);\r\n                });\r\n            }\r\n            else {\r\n                rowPKs = rowPKs.filter(function (r) { return r; });\r\n                if (!t._getMod(\"join\")) {\r\n                    t._db._queryCache[t._tableID][t._queryHash] = rowPKs;\r\n                }\r\n                callBack(rowPKs, \"none\", []);\r\n            }\r\n        };\r\n        stepQuery(queryRows);\r\n    };\r\n    _NanoSQLQuery.prototype._remove = function (queryRows, callBack) {\r\n        var scribe = \"deleted\", i;\r\n        var t = this;\r\n        var qArgs = t._act.args || [];\r\n        var pk = t._db._store._tables[t._tableID]._pk;\r\n        i = 0;\r\n        var remove = function () {\r\n            if (i < queryRows.length) {\r\n                t._updateRow(queryRows[i][pk], function () {\r\n                    i++;\r\n                    remove();\r\n                });\r\n            }\r\n            else {\r\n                if (qArgs.length)\r\n                    scribe = \"modified\";\r\n                t._tableChanged(queryRows.map(function (r) { return r[pk]; }), scribe, callBack);\r\n            }\r\n        };\r\n        remove();\r\n    };\r\n    _NanoSQLQuery.prototype._where = function (row, conditions) {\r\n        var t = this;\r\n        var commands = [\"AND\", \"OR\"];\r\n        if (typeof conditions[0] !== \"string\") {\r\n            var prevCmd_1;\r\n            return conditions.reduce(function (prev, cur, i) {\r\n                if (commands.indexOf(cur) !== -1) {\r\n                    prevCmd_1 = cur;\r\n                    return prev;\r\n                }\r\n                else {\r\n                    var compare = t._compare(cur[2], cur[1], row[cur[0]]) === 0 ? true : false;\r\n                    if (i === 0)\r\n                        return compare;\r\n                    if (prevCmd_1 === \"AND\") {\r\n                        return prev && compare;\r\n                    }\r\n                    else {\r\n                        return prev || compare;\r\n                    }\r\n                }\r\n            }, true);\r\n        }\r\n        else {\r\n            return t._compare(conditions[2], conditions[1], row[conditions[0]]) === 0 ? true : false;\r\n        }\r\n    };\r\n    _NanoSQLQuery.prototype._join = function (type, leftTableID, rightTableID, joinConditions, complete) {\r\n        var L = \"left\";\r\n        var R = \"right\";\r\n        var O = \"outer\";\r\n        var joinHelper = {};\r\n        var t = this;\r\n        var leftTableData = t._db._store._tables[leftTableID];\r\n        var rightTableData = t._db._store._tables[rightTableID];\r\n        var doJoinRows = function (leftRow, rightRow) {\r\n            return [leftTableData, rightTableData].reduce(function (prev, cur, i) {\r\n                cur._keys.forEach(function (k) {\r\n                    prev[cur._name + \".\" + k] = ((i === 0 ? leftRow : rightRow) || {})[k];\r\n                });\r\n                return prev;\r\n            }, {});\r\n        };\r\n        var joinTable = [];\r\n        var rightUsedPKs = [];\r\n        t._db._store._read(leftTableData._name, \"all\", function (leftRows) {\r\n            t._db._store._read(rightTableData._name, \"all\", function (rightRows) {\r\n                leftRows.forEach(function (leftRow) {\r\n                    var joinRows = rightRows.filter(function (rightRow) {\r\n                        if (!joinConditions)\r\n                            return true;\r\n                        var joinedRow = doJoinRows(leftRow, rightRow);\r\n                        var keep = t._where(joinedRow, [joinConditions._left, joinConditions._check, joinConditions._right]);\r\n                        if (keep)\r\n                            rightUsedPKs.push(rightRow[rightTableData._pk]);\r\n                        return keep;\r\n                    });\r\n                    if (joinRows.length) {\r\n                        joinTable = joinTable.concat(joinRows);\r\n                    }\r\n                    else if ([L, O].indexOf(type) >= 0) {\r\n                        joinTable.push(doJoinRows(leftRow, null));\r\n                    }\r\n                });\r\n                rightUsedPKs = rightUsedPKs.sort().filter(function (item, pos, ary) {\r\n                    return !pos || item !== ary[pos - 1];\r\n                });\r\n                if ([R, O].indexOf(type) >= 0) {\r\n                    rightRows.filter(function (r) {\r\n                        return rightUsedPKs.indexOf(r[rightTableData._pk]) === -1;\r\n                    }).forEach(function (rightRow) {\r\n                        joinTable.push(doJoinRows(null, rightRow));\r\n                    });\r\n                }\r\n                complete(joinTable);\r\n            });\r\n        });\r\n    };\r\n    _NanoSQLQuery.prototype._compare = function (val1, compare, val2) {\r\n        var setValue = function (val) {\r\n            if (compare !== \"LIKE\")\r\n                return val;\r\n            if (typeof val === \"string\")\r\n                return String(val).toLowerCase();\r\n            if (Array.isArray(val))\r\n                return val.map(function (v) { return setValue(v); });\r\n            return val;\r\n        };\r\n        var left = setValue(val2);\r\n        var right = setValue(val1);\r\n        switch (compare) {\r\n            case \"=\": return left === right ? 0 : 1;\r\n            case \">\": return left > right ? 0 : 1;\r\n            case \"<\": return left < right ? 0 : 1;\r\n            case \"<=\": return left <= right ? 0 : 1;\r\n            case \">=\": return left >= right ? 0 : 1;\r\n            case \"IN\": return right.indexOf(left) < 0 ? 1 : 0;\r\n            case \"NOT IN\": return right.indexOf(left) < 0 ? 0 : 1;\r\n            case \"REGEX\":\r\n            case \"LIKE\": return left.search(right) < 0 ? 1 : 0;\r\n            case \"BETWEEN\": return right[0] <= left && right[1] >= left ? 0 : 1;\r\n            case \"HAVE\": return (left || []).indexOf(right) < 0 ? 1 : 0;\r\n            default: return 0;\r\n        }\r\n    };\r\n    return _NanoSQLQuery;\r\n}());\r\nexports._NanoSQLQuery = _NanoSQLQuery;\r\n"
    },
    {
      "id": 4,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
      "name": "./src/db-storage.ts",
      "index": 4,
      "index2": 3,
      "size": 35100,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
      "issuerId": 1,
      "issuerName": "./src/db-index.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-index.ts",
          "module": "./src/db-index.ts",
          "moduleName": "./src/db-index.ts",
          "type": "cjs require",
          "userRequest": "./db-storage",
          "loc": "4:19-42"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar index_1 = require(\"./index\");\r\nvar db_index_1 = require(\"./db-index\");\r\nvar db_query_1 = require(\"./db-query\");\r\nvar trie_1 = require(\"./trie\");\r\nvar _NanoSQL_Storage = (function () {\r\n    function _NanoSQL_Storage(database, args) {\r\n        this._savedArgs = args;\r\n        this.init(database, args);\r\n    }\r\n    _NanoSQL_Storage.prototype.init = function (database, args) {\r\n        var _this = this;\r\n        var t = this;\r\n        t._models = {};\r\n        t._tables = {};\r\n        t._levelDBs = {};\r\n        t._historyPoint = 0;\r\n        t._historyLength = 0;\r\n        t._historyArray = [0, 0];\r\n        t._doingTransaction = false;\r\n        t._doHistory = true;\r\n        t._storeMemory = true;\r\n        t._persistent = false;\r\n        t._utilityTable = {};\r\n        t._mode = 0;\r\n        t._parent = database;\r\n        var size = 5;\r\n        if (args._config.length) {\r\n            t._persistent = args._config[0].persistent !== undefined ? args._config[0].persistent : false;\r\n            t._doHistory = args._config[0].history !== undefined ? args._config[0].history : true;\r\n            t._storeMemory = args._config[0].memory !== undefined ? args._config[0].memory : true;\r\n            size = args._config[0].size || 5;\r\n            t._mode = {\r\n                IDB: 1,\r\n                LS: 2,\r\n                LVL: 4\r\n            }[args._config[0].mode] || 0;\r\n            if (args._config[0].rebuildIndexes)\r\n                t._rebuildIndexes = true;\r\n            if (args._config[0].id)\r\n                t._parent._databaseID = String(args._config[0].id);\r\n        }\r\n        var upgrading = false;\r\n        var index = 0;\r\n        var isNewStore = true;\r\n        Object.keys(args._models).forEach(function (t) {\r\n            var pkRow = { key: \"x\", type: \"x\" };\r\n            var secondaryIndexes = [];\r\n            args._models[t].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    pkRow = index_1._assign(m);\r\n                }\r\n                if (m.props && (m.props.indexOf(\"idx\") !== -1 || m.props.indexOf(\"trie\") !== -1)) {\r\n                    secondaryIndexes.push(m);\r\n                }\r\n            });\r\n            if (pkRow.key !== \"x\" && pkRow.type !== \"x\") {\r\n                args._models[\"_\" + t + \"_hist__data\"] = index_1._assign(args._models[t]).map(function (m) {\r\n                    delete m.props;\r\n                    return m;\r\n                });\r\n                args._models[\"_\" + t + \"_hist__meta\"] = [\r\n                    pkRow,\r\n                    { key: \"_pointer\", type: \"int\" },\r\n                    { key: \"_historyDataRowIDs\", type: \"array\" },\r\n                ];\r\n            }\r\n            if (secondaryIndexes.length && (pkRow.key !== \"x\" && pkRow.type !== \"x\")) {\r\n                secondaryIndexes.forEach(function (s) {\r\n                    args._models[\"_\" + t + \"_idx_\" + s.key] = [\r\n                        { key: \"id\", type: s.type, props: [\"pk\"] },\r\n                        { key: \"rowPK\", type: pkRow.type }\r\n                    ];\r\n                });\r\n            }\r\n        });\r\n        args._models[db_index_1._str(0)] = [\r\n            { key: \"key\", type: \"string\", props: [\"pk\"] },\r\n            { key: \"value\", type: \"blob\" },\r\n        ];\r\n        args._models[db_index_1._str(1)] = [\r\n            { key: \"id\", type: \"int\", props: [\"ai\", \"pk\"] },\r\n            { key: \"tableID\", type: \"int\" },\r\n            { key: \"historyPoint\", type: \"int\" },\r\n            { key: \"rowKeys\", type: \"array\" },\r\n            { key: \"type\", type: \"string\" }\r\n        ];\r\n        var tables = Object.keys(args._models);\r\n        var beforeHist;\r\n        var beforeMode;\r\n        Object.keys(args._models).forEach(function (tableName) {\r\n            t._newTable(tableName, args._models[tableName]);\r\n        });\r\n        Object.keys(args._functions || []).forEach(function (f) {\r\n            db_query_1._functions[f] = args._functions[f];\r\n        });\r\n        var rebuildTries = function () {\r\n            var rebuildJob = {};\r\n            var jobLength = 0;\r\n            Object.keys(args._models).forEach(function (table) {\r\n                if (table.indexOf(\"_\") !== 0) {\r\n                    var ta = index_1.NanoSQLInstance._hash(table);\r\n                    if (t._tables[ta]._trieColumns.length) {\r\n                        rebuildJob[table] = t._tables[ta]._trieColumns;\r\n                        jobLength++;\r\n                    }\r\n                }\r\n            });\r\n            if (jobLength === 0) {\r\n                args._onSuccess();\r\n            }\r\n            else {\r\n                var tables_1 = Object.keys(rebuildJob);\r\n                var ptr_1 = 0;\r\n                var step_1 = function () {\r\n                    if (ptr_1 < tables_1.length) {\r\n                        var ta_1 = index_1.NanoSQLInstance._hash(tables_1[ptr_1]);\r\n                        t._read(tables_1[ptr_1], \"all\", function (rows) {\r\n                            rows.forEach(function (row, i) {\r\n                                rebuildJob[tables_1[ptr_1]].forEach(function (key) {\r\n                                    if (row[key])\r\n                                        t._tables[ta_1]._trieObjects[key].addWord(String(row[key]).toLocaleLowerCase());\r\n                                });\r\n                            });\r\n                            ptr_1++;\r\n                            step_1();\r\n                        });\r\n                    }\r\n                    else {\r\n                        args._onSuccess();\r\n                    }\r\n                };\r\n                step_1();\r\n            }\r\n        };\r\n        var rebuildSecondaryIndexes = function () {\r\n            if (!t._rebuildIndexes) {\r\n                rebuildTries();\r\n            }\r\n            else {\r\n                var rebuildJob_1 = {};\r\n                Object.keys(args._models).forEach(function (table) {\r\n                    if (table.indexOf(\"_\") !== 0) {\r\n                        var ta = index_1.NanoSQLInstance._hash(table);\r\n                        if (t._tables[ta]._secondaryIndexes.length) {\r\n                            rebuildJob_1[table] = t._tables[ta]._secondaryIndexes;\r\n                        }\r\n                    }\r\n                });\r\n                var tables_2 = Object.keys(rebuildJob_1);\r\n                var tablePTR_1 = 0;\r\n                var step_2 = function () {\r\n                    if (tablePTR_1 < tables_2.length) {\r\n                        var ta_2 = index_1.NanoSQLInstance._hash(tables_2[tablePTR_1]);\r\n                        var rowPTR_1 = 0;\r\n                        _this._read(tables_2[tablePTR_1], \"all\", function (rows) {\r\n                            var PK = t._tables[ta_2]._pk;\r\n                            var step2 = function () {\r\n                                if (rowPTR_1 < rows.length) {\r\n                                    var ptr3_1 = 0;\r\n                                    var step3_1 = function () {\r\n                                        if (ptr3_1 < rebuildJob_1[tables_2[tablePTR_1]].length) {\r\n                                            var key_1 = rebuildJob_1[tables_2[tablePTR_1]][ptr3_1];\r\n                                            var idxTbl_1 = \"_\" + tables_2[tablePTR_1] + \"_idx_\" + key_1;\r\n                                            var rowKey_1 = String(rows[rowPTR_1][key_1]).toLocaleLowerCase();\r\n                                            t._read(idxTbl_1, rowKey_1, function (readRows) {\r\n                                                var indexedRows = [rows[rowPTR_1][PK]];\r\n                                                if (readRows.length && readRows[0].rowPK) {\r\n                                                    indexedRows = indexedRows.concat(readRows[0].rowPK).filter(function (item, pos) {\r\n                                                        return indexedRows.indexOf(item) === pos;\r\n                                                    });\r\n                                                }\r\n                                                t._upsert(idxTbl_1, rowKey_1, {\r\n                                                    id: rows[rowPTR_1][key_1],\r\n                                                    rowPK: indexedRows\r\n                                                }, function () {\r\n                                                    ptr3_1++;\r\n                                                    step3_1();\r\n                                                });\r\n                                            }, true);\r\n                                        }\r\n                                        else {\r\n                                            rowPTR_1++;\r\n                                            step2();\r\n                                        }\r\n                                    };\r\n                                    step3_1();\r\n                                }\r\n                                else {\r\n                                    tablePTR_1++;\r\n                                    step_2();\r\n                                }\r\n                            };\r\n                            step2();\r\n                        });\r\n                    }\r\n                    else {\r\n                        rebuildTries();\r\n                    }\r\n                };\r\n                step_2();\r\n            }\r\n        };\r\n        var completeSetup = function () {\r\n            var tables = Object.keys(args._models);\r\n            var i = 0;\r\n            t._mode = beforeMode;\r\n            if (beforeHist) {\r\n                t._read(db_index_1._str(0), \"all\", function (rows) {\r\n                    rows.forEach(function (d) {\r\n                        t._utility(\"w\", d.key, d.value);\r\n                        if (d.key === \"historyPoint\")\r\n                            t._historyPoint = d.value || 0;\r\n                        if (d.key === \"historyLength\")\r\n                            t._historyLength = d.value || 0;\r\n                    });\r\n                });\r\n            }\r\n            if (isNewStore) {\r\n                var step_3 = function () {\r\n                    if (i < tables.length) {\r\n                        if (tables[i].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[i], 0, null, function () {\r\n                                i++;\r\n                                step_3();\r\n                            });\r\n                        }\r\n                        else {\r\n                            i++;\r\n                            step_3();\r\n                        }\r\n                    }\r\n                    else {\r\n                        t._doHistory = beforeHist;\r\n                        rebuildSecondaryIndexes();\r\n                    }\r\n                };\r\n                step_3();\r\n            }\r\n            else {\r\n                t._doHistory = beforeHist;\r\n                rebuildSecondaryIndexes();\r\n            }\r\n        };\r\n        beforeMode = t._mode;\r\n        if (t._persistent) {\r\n            if (t._mode !== 0) {\r\n                switch (t._mode) {\r\n                    case 1:\r\n                        if (typeof indexedDB === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 2:\r\n                        if (typeof localStorage === \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                    case 4:\r\n                        if (typeof window !== \"undefined\")\r\n                            t._mode = 0;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (typeof window !== \"undefined\") {\r\n                    if (typeof localStorage !== \"undefined\")\r\n                        t._mode = 2;\r\n                    if (typeof indexedDB !== \"undefined\")\r\n                        t._mode = 1;\r\n                }\r\n                if (typeof global !== \"undefined\") {\r\n                    if (typeof global._levelup !== \"undefined\" && typeof global._fs !== \"undefined\") {\r\n                        t._mode = 4;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            t._mode = 0;\r\n            completeSetup();\r\n        }\r\n        beforeHist = t._doHistory;\r\n        beforeMode = t._mode;\r\n        t._mode = 0;\r\n        t._doHistory = false;\r\n        var createTables = function (makeTable, complete) {\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    makeTable(tables[index], ta, t._tables[ta]);\r\n                    index++;\r\n                    next();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        var cacheTableData = function (args) {\r\n            isNewStore = false;\r\n            var index = 0;\r\n            var next = function () {\r\n                if (index < tables.length) {\r\n                    var ta_3 = index_1.NanoSQLInstance._hash(tables[index]);\r\n                    if (!beforeHist && (tables[index].indexOf(\"_hist__data\") !== -1 || tables[index].indexOf(\"_hist__meta\") !== -1)) {\r\n                        index++;\r\n                        next();\r\n                        return;\r\n                    }\r\n                    if (t._storeMemory) {\r\n                        args.requestTable(tables[index], function (tableData) {\r\n                            if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                                t._tables[ta_3]._index.push(\"0\");\r\n                                t._tables[ta_3]._rows[\"0\"] = null;\r\n                                t._tables[ta_3]._incriment++;\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                            else {\r\n                                t._parent._parent.loadJS(tables[index], tableData).then(function () {\r\n                                    index++;\r\n                                    next();\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                    else if (!t._storeMemory || args.forceIndex) {\r\n                        args.requestIndex(tables[index], function (indexData) {\r\n                            t._parent._store._tables[ta_3]._index = indexData;\r\n                            t._parent._store._tables[ta_3]._incriment = indexData.reduce(function (prev, cur) {\r\n                                return Math.max(prev, parseInt(cur) || 0);\r\n                            }, 0);\r\n                            t._parent._store._tables[ta_3]._incriment++;\r\n                            index++;\r\n                            next();\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    if (args.cleanup) {\r\n                        args.cleanup(function () {\r\n                            completeSetup();\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeSetup();\r\n                    }\r\n                    return;\r\n                }\r\n            };\r\n            next();\r\n        };\r\n        switch (beforeMode) {\r\n            case 0:\r\n                completeSetup();\r\n                break;\r\n            case 1:\r\n                var idb = indexedDB.open(t._parent._databaseID, 1);\r\n                idb.onupgradeneeded = function (event) {\r\n                    upgrading = true;\r\n                    var db = event.target.result;\r\n                    var transaction = event.target.transaction;\r\n                    t._indexedDB = db;\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        var config = tableObj._pk ? { keyPath: tableObj._pk } : {};\r\n                        db.createObjectStore(tableName, config);\r\n                    }, function () {\r\n                        transaction.oncomplete = function () {\r\n                            completeSetup();\r\n                        };\r\n                    });\r\n                };\r\n                idb.onsuccess = function (event) {\r\n                    t._indexedDB = event.target.result;\r\n                    if (!upgrading) {\r\n                        var getIDBData_1 = function (tName, callBack) {\r\n                            var items = [];\r\n                            var transaction = t._indexedDB.transaction(tName, \"readonly\");\r\n                            var store = transaction.objectStore(tName);\r\n                            var cursorRequest = store.openCursor();\r\n                            cursorRequest.onsuccess = function (evt) {\r\n                                var cursor = evt.target.result;\r\n                                if (cursor) {\r\n                                    items.push(t._storeMemory ? cursor.value : cursor.key);\r\n                                    cursor.continue();\r\n                                }\r\n                            };\r\n                            transaction.oncomplete = function () {\r\n                                callBack(items);\r\n                            };\r\n                        };\r\n                        cacheTableData({\r\n                            requestIndex: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            },\r\n                            requestTable: function (tableName, complete) {\r\n                                getIDBData_1(tableName, complete);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                break;\r\n            case 2:\r\n                if (localStorage.getItem(\"dbID\") !== t._parent._databaseID) {\r\n                    localStorage.setItem(\"dbID\", t._parent._databaseID);\r\n                    createTables(function (tableName, tableHash, tableObj) {\r\n                        localStorage.setItem(tableName, JSON.stringify([]));\r\n                    }, function () {\r\n                        completeSetup();\r\n                    });\r\n                }\r\n                else {\r\n                    cacheTableData({\r\n                        forceIndex: true,\r\n                        requestIndex: function (tableName, complete) {\r\n                            var tableIndex = JSON.parse(localStorage.getItem(tableName) || \"[]\");\r\n                            complete(tableIndex);\r\n                        },\r\n                        requestTable: function (tableName, complete) {\r\n                            var items = [];\r\n                            JSON.parse(localStorage.getItem(tableName) || \"[]\").forEach(function (ptr) {\r\n                                items.push(JSON.parse(localStorage.getItem(tableName + \"-\" + ptr) || \"\"));\r\n                            });\r\n                            complete(items);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._execTransaction = function () {\r\n        var t = this;\r\n        switch (t._mode) {\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._clear = function (type, complete) {\r\n        var t = this;\r\n        var tables = Object.keys(t._tables).map(function (k) { return t._tables[k]._name; });\r\n        var index = 0;\r\n        var setupNewHist = function () {\r\n            var index = 0;\r\n            var histStep = function () {\r\n                if (index < tables.length) {\r\n                    if (tables[index].indexOf(\"_hist__meta\") !== -1) {\r\n                        var referenceTable_1 = String(tables[index]).slice(1).replace(\"_hist__meta\", \"\");\r\n                        var ta = index_1.NanoSQLInstance._hash(referenceTable_1);\r\n                        var pk_1 = t._tables[ta]._pk;\r\n                        t._read(referenceTable_1, \"all\", function (rows) {\r\n                            rows.forEach(function (row, i) {\r\n                                var hist = {};\r\n                                hist[db_index_1._str(2)] = 0;\r\n                                hist[db_index_1._str(3)] = [i + 1];\r\n                                t._upsert(tables[index], row[pk_1], hist);\r\n                                t._upsert(\"_\" + referenceTable_1 + \"_hist__data\", i + 1, row);\r\n                            });\r\n                            index++;\r\n                            histStep();\r\n                        });\r\n                    }\r\n                    else {\r\n                        index++;\r\n                        histStep();\r\n                    }\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            };\r\n            histStep();\r\n        };\r\n        var step = function () {\r\n            if (index < tables.length) {\r\n                var deleteTable = false;\r\n                if (type === \"hist\" && (tables[index] === \"_historyPoints\" || tables[index].indexOf(\"_hist__meta\") !== -1 || tables[index].indexOf(\"_hist__data\") !== -1)) {\r\n                    deleteTable = true;\r\n                }\r\n                if (type === \"all\" && tables[index] !== \"_utility\") {\r\n                    deleteTable = true;\r\n                }\r\n                if (deleteTable) {\r\n                    t._delete(tables[index], \"all\", function () {\r\n                        if (tables[index].indexOf(\"_hist__data\") !== -1) {\r\n                            t._upsert(tables[index], 0, null);\r\n                        }\r\n                        index++;\r\n                        step();\r\n                    });\r\n                }\r\n                else {\r\n                    index++;\r\n                    step();\r\n                }\r\n            }\r\n            else {\r\n                if (type === \"hist\") {\r\n                    setupNewHist();\r\n                }\r\n                else {\r\n                    complete();\r\n                }\r\n            }\r\n        };\r\n        step();\r\n    };\r\n    _NanoSQL_Storage.prototype._delete = function (tableName, rowID, callBack) {\r\n        var t = this;\r\n        var editingHistory = false;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        var deleteRowIDS = [];\r\n        if (rowID === \"all\") {\r\n            deleteRowIDS = t._tables[ta]._index.slice();\r\n            t._tables[ta]._index = [];\r\n        }\r\n        else {\r\n            deleteRowIDS.push(rowID);\r\n            t._tables[ta]._index.splice(t._tables[ta]._index.indexOf(rowID), 1);\r\n        }\r\n        if (t._storeMemory) {\r\n            if (rowID === \"all\") {\r\n                t._tables[ta]._rows = {};\r\n            }\r\n            else {\r\n                delete t._tables[ta]._rows[rowID];\r\n            }\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(true);\r\n        }\r\n        if (t._mode > 0) {\r\n            var i_1 = 0;\r\n            var step_4 = function () {\r\n                if (i_1 < deleteRowIDS.length) {\r\n                    switch (t._mode) {\r\n                        case 1:\r\n                            t._indexedDB.transaction(tableName, \"readwrite\").objectStore(tableName).delete(parseInt(deleteRowIDS[i_1]));\r\n                            i_1++;\r\n                            step_4();\r\n                            break;\r\n                        case 2:\r\n                            localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                            localStorage.removeItem(tableName + \"-\" + String(deleteRowIDS[i_1]));\r\n                            i_1++;\r\n                            step_4();\r\n                            break;\r\n                        default:\r\n                            i_1++;\r\n                            step_4();\r\n                    }\r\n                }\r\n                else {\r\n                    if (callBack)\r\n                        callBack(true);\r\n                }\r\n            };\r\n            step_4();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._upsert = function (tableName, rowID, value, callBack) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (rowID === undefined || rowID === null) {\r\n            t._models[ta].forEach(function (m) {\r\n                if (m.props && m.props.indexOf(\"pk\") !== -1) {\r\n                    if (m.type === \"uuid\") {\r\n                        rowID = index_1.NanoSQLInstance.uuid();\r\n                    }\r\n                    else {\r\n                        rowID = t._tables[ta]._incriment++;\r\n                    }\r\n                }\r\n            });\r\n            if (!rowID)\r\n                rowID = parseInt(t._tables[ta]._index[t._tables[ta]._index.length - 1] || \"0\") + 1;\r\n        }\r\n        if (t._tables[ta]._pkType === \"int\")\r\n            rowID = parseInt(rowID);\r\n        var pk = t._tables[ta]._pk;\r\n        if (pk && pk.length && value && !value[pk]) {\r\n            value[pk] = rowID;\r\n        }\r\n        if (t._tables[ta]._index.indexOf(rowID) === -1) {\r\n            t._tables[ta]._index.push(rowID);\r\n        }\r\n        if (t._storeMemory) {\r\n            t._tables[ta]._rows[rowID] = t._parent._deepFreeze(value, ta);\r\n            if (t._mode === 0 && callBack)\r\n                return callBack(rowID);\r\n        }\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readwrite\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (pk.length && value) {\r\n                    store.put(value);\r\n                }\r\n                else {\r\n                    if (tableName.indexOf(\"_hist__data\") !== -1) {\r\n                        store.put(value, rowID);\r\n                    }\r\n                    else {\r\n                        if (value)\r\n                            store.put(value);\r\n                        if (!value)\r\n                            store.delete(rowID);\r\n                    }\r\n                }\r\n                transaction.oncomplete = function () {\r\n                    if (callBack)\r\n                        callBack(rowID);\r\n                };\r\n                break;\r\n            case 2:\r\n                localStorage.setItem(tableName + \"-\" + String(rowID), value ? JSON.stringify(value) : \"\");\r\n                localStorage.setItem(tableName, JSON.stringify(t._tables[ta]._index));\r\n                if (callBack)\r\n                    callBack(rowID);\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._indexRead = function (tableName, rows, callBack, getIndex) {\r\n        var _this = this;\r\n        var isSecondIndex = tableName.indexOf(\"_\") === 0 && tableName.indexOf(\"_idx_\") !== -1;\r\n        if (!isSecondIndex || getIndex) {\r\n            callBack(rows);\r\n        }\r\n        else {\r\n            var parentTable_1 = !isSecondIndex ? \"\" : tableName.slice(1, tableName.indexOf(\"_idx_\"));\r\n            var allRowIDs_1 = rows.reduce(function (prev, cur) {\r\n                return prev.concat(cur.rowPK);\r\n            }, []);\r\n            var resultRows_1 = [];\r\n            var ptr_2 = 0;\r\n            var step_5 = function () {\r\n                if (ptr_2 < allRowIDs_1.length) {\r\n                    _this._read(parentTable_1, allRowIDs_1[ptr_2], function (rows) {\r\n                        resultRows_1 = resultRows_1.concat(rows);\r\n                        ptr_2++;\r\n                        step_5();\r\n                    });\r\n                }\r\n                else {\r\n                    callBack(resultRows_1);\r\n                }\r\n            };\r\n            step_5();\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._readRange = function (tableName, key, between, callBack) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        if (t._mode === 0 || t._mode === 2) {\r\n            var startPtr_1 = t._tables[ta]._index.indexOf(between[0]);\r\n            var resultRows_2 = [];\r\n            var stepRead_1 = function () {\r\n                var pk = t._tables[ta]._index[startPtr_1];\r\n                if (pk <= between[1]) {\r\n                    _this._read(tableName, pk, function (rows) {\r\n                        resultRows_2 = resultRows_2.concat(rows);\r\n                        startPtr_1++;\r\n                        stepRead_1();\r\n                    });\r\n                }\r\n                else {\r\n                    _this._indexRead(tableName, resultRows_2, callBack);\r\n                }\r\n            };\r\n            stepRead_1();\r\n            return;\r\n        }\r\n        var rows = [];\r\n        switch (t._mode) {\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                var cursorRequest = store.openCursor(IDBKeyRange.bound(between[0], between[1]));\r\n                transaction.oncomplete = function () {\r\n                    _this._indexRead(tableName, rows, callBack);\r\n                };\r\n                cursorRequest.onsuccess = function (evt) {\r\n                    var cursor = evt.target.result;\r\n                    if (cursor) {\r\n                        rows.push(cursor.value);\r\n                        cursor.continue();\r\n                    }\r\n                };\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._read = function (tableName, row, callBack, readIndex) {\r\n        var _this = this;\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        switch (t._mode) {\r\n            case 0:\r\n                var rows_1 = t._tables[ta]._rows;\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var allRows = Object.keys(rows_1).map(function (r) { return rows_1[r]; });\r\n                    if (row === \"all\") {\r\n                        this._indexRead(tableName, allRows.filter(function (r) { return r; }), callBack, readIndex);\r\n                    }\r\n                    else {\r\n                        this._indexRead(tableName, allRows.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    this._indexRead(tableName, [rows_1[row]].filter(function (r) { return r; }), callBack, readIndex);\r\n                }\r\n                break;\r\n            case 1:\r\n                var transaction = t._indexedDB.transaction(tableName, \"readonly\");\r\n                var store = transaction.objectStore(tableName);\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var cursorRequest = store.openCursor();\r\n                    var rows_2 = [];\r\n                    transaction.oncomplete = function () {\r\n                        _this._indexRead(tableName, rows_2, callBack, readIndex);\r\n                    };\r\n                    cursorRequest.onsuccess = function (evt) {\r\n                        var cursor = evt.target.result;\r\n                        if (cursor) {\r\n                            if (row !== \"all\") {\r\n                                if (row(cursor.value))\r\n                                    rows_2.push(cursor.value);\r\n                            }\r\n                            else {\r\n                                rows_2.push(cursor.value);\r\n                            }\r\n                            cursor.continue();\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    var singleReq_1 = store.get(row);\r\n                    singleReq_1.onsuccess = function (event) {\r\n                        _this._indexRead(tableName, [singleReq_1.result], callBack, readIndex);\r\n                    };\r\n                }\r\n                break;\r\n            case 2:\r\n                if (row === \"all\" || typeof row === \"function\") {\r\n                    var rows_3 = t._tables[ta]._index.map(function (idx) {\r\n                        var item = localStorage.getItem(tableName + \"-\" + idx);\r\n                        return item && item.length ? JSON.parse(item) : null;\r\n                    });\r\n                    if (row !== \"all\") {\r\n                        this._indexRead(tableName, rows_3.filter(function (r) { return row(r); }), callBack, readIndex);\r\n                    }\r\n                    else {\r\n                        this._indexRead(tableName, rows_3, callBack, readIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    var item = localStorage.getItem(tableName + \"-\" + row);\r\n                    this._indexRead(tableName, [item && item.length ? JSON.parse(item) : null], callBack, readIndex);\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._utility = function (type, key, value) {\r\n        var t = this;\r\n        if (type === \"r\") {\r\n            if (t._utilityTable[key]) {\r\n                return t._utilityTable[key].value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            t._upsert(db_index_1._str(0), key, { key: key, value: value });\r\n            t._utility[key] = {\r\n                key: key,\r\n                value: value\r\n            };\r\n            return value;\r\n        }\r\n    };\r\n    _NanoSQL_Storage.prototype._newTable = function (tableName, dataModels) {\r\n        var t = this;\r\n        var ta = index_1.NanoSQLInstance._hash(tableName);\r\n        t._models[ta] = dataModels;\r\n        t._parent._queryCache[ta] = {};\r\n        t._tables[ta] = {\r\n            _pk: \"\",\r\n            _pkType: \"\",\r\n            _keys: [],\r\n            _defaults: [],\r\n            _secondaryIndexes: [],\r\n            _trieColumns: [],\r\n            _trieObjects: {},\r\n            _name: tableName,\r\n            _incriment: 1,\r\n            _index: [],\r\n            _rows: {}\r\n        };\r\n        var i = t._models[ta].length;\r\n        var keys = [];\r\n        var defaults = [];\r\n        while (i--) {\r\n            var p = t._models[ta][i];\r\n            t._tables[ta]._keys.unshift(p.key);\r\n            t._tables[ta]._defaults[i] = p.default;\r\n            if (p.props && p.props.indexOf(\"pk\") >= 0) {\r\n                t._tables[ta]._pk = p.key;\r\n                t._tables[ta]._pkType = p.type;\r\n            }\r\n            if (p.props && (p.props.indexOf(\"idx\") >= 0 || p.props.indexOf(\"trie\") >= 0)) {\r\n                t._tables[ta]._secondaryIndexes.push(p.key);\r\n            }\r\n            if (p.props && p.props.indexOf(\"trie\") >= 0) {\r\n                t._tables[ta]._trieColumns.push(p.key);\r\n                t._tables[ta]._trieObjects[p.key] = new trie_1.Trie([]);\r\n            }\r\n        }\r\n        return tableName;\r\n    };\r\n    return _NanoSQL_Storage;\r\n}());\r\nexports._NanoSQL_Storage = _NanoSQL_Storage;\r\n"
    },
    {
      "id": 5,
      "identifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\trie.ts",
      "name": "./src/trie.ts",
      "index": 6,
      "index2": 2,
      "size": 3262,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
      "issuerId": 4,
      "issuerName": "./src/db-storage.ts",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "C:\\Users\\Scott\\nano-sql\\node_modules\\ts-loader\\index.js!C:\\Users\\Scott\\nano-sql\\node_modules\\webpack-strip-block\\index.js?start=NODE-START&end=NODE-END!C:\\Users\\Scott\\nano-sql\\src\\db-storage.ts",
          "module": "./src/db-storage.ts",
          "moduleName": "./src/db-storage.ts",
          "type": "cjs require",
          "userRequest": "./trie",
          "loc": "5:13-30"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "Object.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction append(trie, letter, index, array) {\r\n    trie[letter] = trie[letter] || {};\r\n    trie = trie[letter];\r\n    if (index === array.length - 1) {\r\n        trie[config.END_WORD] = 1;\r\n    }\r\n    return trie;\r\n}\r\nfunction checkPrefix(prefixNode, prefix) {\r\n    var input = prefix.toLowerCase().split(\"\");\r\n    var prefixFound = input.every(function (letter, index) {\r\n        if (!prefixNode[letter]) {\r\n            return false;\r\n        }\r\n        return prefixNode = prefixNode[letter];\r\n    });\r\n    return {\r\n        prefixFound: prefixFound,\r\n        prefixNode: prefixNode,\r\n    };\r\n}\r\nfunction create(input) {\r\n    var trie = input.reduce(function (accumulator, item) {\r\n        item\r\n            .toLowerCase()\r\n            .split(\"\")\r\n            .reduce(append, accumulator);\r\n        return accumulator;\r\n    }, {});\r\n    return trie;\r\n}\r\nfunction recursePrefix(node, prefix, prefixes) {\r\n    if (prefixes === void 0) { prefixes = []; }\r\n    var word = prefix;\r\n    for (var branch in node) {\r\n        if (branch === config.END_WORD) {\r\n            prefixes.push(word);\r\n            word = \"\";\r\n        }\r\n        recursePrefix(node[branch], prefix + branch, prefixes);\r\n    }\r\n    return prefixes.sort();\r\n}\r\nvar utils = {\r\n    objectCopy: function (obj) {\r\n        if (typeof obj === \"undefined\") {\r\n            return {};\r\n        }\r\n        return JSON.parse(JSON.stringify(obj));\r\n    },\r\n    stringify: function (obj, spacer) {\r\n        if (spacer === void 0) { spacer = 2; }\r\n        if (typeof obj === \"undefined\") {\r\n            return \"\";\r\n        }\r\n        return JSON.stringify(obj, null, spacer);\r\n    },\r\n};\r\nvar config = {\r\n    END_WORD: \"$\",\r\n    PERMS_MIN_LEN: 2,\r\n};\r\nvar PERMS_MIN_LEN = config.PERMS_MIN_LEN;\r\nvar Trie = (function () {\r\n    function Trie(input) {\r\n        this._trie = create(input);\r\n    }\r\n    Trie.prototype.dump = function (spacer) {\r\n        if (spacer === void 0) { spacer = 0; }\r\n        return utils.stringify(this._trie, spacer);\r\n    };\r\n    Trie.prototype.addWord = function (word) {\r\n        var reducer = function (previousValue, currentValue, currentIndex, array) {\r\n            return append(previousValue, currentValue, currentIndex, array);\r\n        };\r\n        var input = word.toLowerCase().split(\"\");\r\n        input.reduce(reducer, this._trie);\r\n        return this;\r\n    };\r\n    Trie.prototype.removeWord = function (word) {\r\n        var _a = checkPrefix(this._trie, word), prefixFound = _a.prefixFound, prefixNode = _a.prefixNode;\r\n        if (prefixFound) {\r\n            delete prefixNode[config.END_WORD];\r\n        }\r\n        return this;\r\n    };\r\n    Trie.prototype.isPrefix = function (prefix) {\r\n        var prefixFound = checkPrefix(this._trie, prefix).prefixFound;\r\n        return prefixFound;\r\n    };\r\n    Trie.prototype.getPrefix = function (strPrefix) {\r\n        if (!this.isPrefix(strPrefix)) {\r\n            return [];\r\n        }\r\n        var prefixNode = checkPrefix(this._trie, strPrefix).prefixNode;\r\n        return recursePrefix(prefixNode, strPrefix);\r\n    };\r\n    Trie.prototype.getWords = function () {\r\n        return recursePrefix(this._trie, \"\");\r\n    };\r\n    return Trie;\r\n}());\r\nexports.Trie = Trie;\r\n"
    },
    {
      "id": 6,
      "identifier": "multi C:\\Users\\Scott\\nano-sql\\src\\index.ts",
      "name": "multi ./src/index.ts",
      "index": 0,
      "index2": 6,
      "size": 28,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "usedExports": true,
      "providedExports": null,
      "depth": 0
    }
  ],
  "filteredModules": 0,
  "children": []
}
